/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/leaflet/dist/leaflet-src.js":
/*!**************************************************!*\
  !*** ./node_modules/leaflet/dist/leaflet-src.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* @preserve
 * Leaflet 1.8.0, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) { 'use strict';

  var version = "1.8.0";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
  	var i, j, len, src;

  	for (j = 1, len = arguments.length; j < len; j++) {
  		src = arguments[j];
  		for (i in src) {
  			dest[i] = src[i];
  		}
  	}
  	return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create$2 = Object.create || (function () {
  	function F() {}
  	return function (proto) {
  		F.prototype = proto;
  		return new F();
  	};
  })();

  // @function bind(fn: Function, …): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
  	var slice = Array.prototype.slice;

  	if (fn.bind) {
  		return fn.bind.apply(fn, slice.call(arguments, 1));
  	}

  	var args = slice.call(arguments, 2);

  	return function () {
  		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  	};
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
  	if (!('_leaflet_id' in obj)) {
  		obj['_leaflet_id'] = ++lastId;
  	}
  	return obj._leaflet_id;
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
  	var lock, args, wrapperFn, later;

  	later = function () {
  		// reset lock and call if queued
  		lock = false;
  		if (args) {
  			wrapperFn.apply(context, args);
  			args = false;
  		}
  	};

  	wrapperFn = function () {
  		if (lock) {
  			// called too soon, queue to call later
  			args = arguments;

  		} else {
  			// call and lock until later
  			fn.apply(context, arguments);
  			setTimeout(later, time);
  			lock = true;
  		}
  	};

  	return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
  	var max = range[1],
  	    min = range[0],
  	    d = max - min;
  	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() { return false; }

  // @function formatNum(num: Number, precision?: Number|false): Number
  // Returns the number `num` rounded with specified `precision`.
  // The default `precision` value is 6 decimal places.
  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
  function formatNum(num, precision) {
  	if (precision === false) { return num; }
  	var pow = Math.pow(10, precision === undefined ? 6 : precision);
  	return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
  	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
  	return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
  	if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
  		obj.options = obj.options ? create$2(obj.options) : {};
  	}
  	for (var i in options) {
  		obj.options[i] = options[i];
  	}
  	return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
  	var params = [];
  	for (var i in obj) {
  		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
  	}
  	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_ -]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values — they will be evaluated passing `data` as an argument.
  function template(str, data) {
  	return str.replace(templateRe, function (str, key) {
  		var value = data[key];

  		if (value === undefined) {
  			throw new Error('No value provided for variable ' + str);

  		} else if (typeof value === 'function') {
  			value = value(data);
  		}
  		return value;
  	});
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray = Array.isArray || function (obj) {
  	return (Object.prototype.toString.call(obj) === '[object Array]');
  };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
  	for (var i = 0; i < array.length; i++) {
  		if (array[i] === el) { return i; }
  	}
  	return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
  	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
  	var time = +new Date(),
  	    timeToCall = Math.max(0, 16 - (time - lastTime));

  	lastTime = time + timeToCall;
  	return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
  		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
  	if (immediate && requestFn === timeoutDefer) {
  		fn.call(context);
  	} else {
  		return requestFn.call(window, bind(fn, context));
  	}
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
  	if (id) {
  		cancelFn.call(window, id);
  	}
  }

  var Util = {
    __proto__: null,
    extend: extend,
    create: create$2,
    bind: bind,
    get lastId () { return lastId; },
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  };

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {

  	// @function extend(props: Object): Function
  	// [Extends the current class](#class-inheritance) given the properties to be included.
  	// Returns a Javascript function that is a class constructor (to be called with `new`).
  	var NewClass = function () {

  		setOptions(this);

  		// call the constructor
  		if (this.initialize) {
  			this.initialize.apply(this, arguments);
  		}

  		// call all constructor hooks
  		this.callInitHooks();
  	};

  	var parentProto = NewClass.__super__ = this.prototype;

  	var proto = create$2(parentProto);
  	proto.constructor = NewClass;

  	NewClass.prototype = proto;

  	// inherit parent's statics
  	for (var i in this) {
  		if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
  			NewClass[i] = this[i];
  		}
  	}

  	// mix static properties into the class
  	if (props.statics) {
  		extend(NewClass, props.statics);
  	}

  	// mix includes into the prototype
  	if (props.includes) {
  		checkDeprecatedMixinEvents(props.includes);
  		extend.apply(null, [proto].concat(props.includes));
  	}

  	// mix given properties into the prototype
  	extend(proto, props);
  	delete proto.statics;
  	delete proto.includes;

  	// merge options
  	if (proto.options) {
  		proto.options = parentProto.options ? create$2(parentProto.options) : {};
  		extend(proto.options, props.options);
  	}

  	proto._initHooks = [];

  	// add method for calling all hooks
  	proto.callInitHooks = function () {

  		if (this._initHooksCalled) { return; }

  		if (parentProto.callInitHooks) {
  			parentProto.callInitHooks.call(this);
  		}

  		this._initHooksCalled = true;

  		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
  			proto._initHooks[i].call(this);
  		}
  	};

  	return NewClass;
  };


  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
  	var parentOptions = this.prototype.options;
  	extend(this.prototype, props);
  	if (props.options) {
  		this.prototype.options = parentOptions;
  		this.mergeOptions(props.options);
  	}
  	return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
  	extend(this.prototype.options, options);
  	return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) { // (Function) || (String, args...)
  	var args = Array.prototype.slice.call(arguments, 1);

  	var init = typeof fn === 'function' ? fn : function () {
  		this[fn].apply(this, args);
  	};

  	this.prototype._initHooks = this.prototype._initHooks || [];
  	this.prototype._initHooks.push(init);
  	return this;
  };

  function checkDeprecatedMixinEvents(includes) {
  	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

  	includes = isArray(includes) ? includes : [includes];

  	for (var i = 0; i < includes.length; i++) {
  		if (includes[i] === L.Mixin.Events) {
  			console.warn('Deprecated include of L.Mixin.Events: ' +
  				'this property will be removed in future releases, ' +
  				'please inherit from L.Evented instead.', new Error().stack);
  		}
  	}
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
  	/* @method on(type: String, fn: Function, context?: Object): this
  	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  	 *
  	 * @alternative
  	 * @method on(eventMap: Object): this
  	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  	 */
  	on: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context);
  			}
  		}

  		return this;
  	},

  	/* @method off(type: String, fn?: Function, context?: Object): this
  	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  	 *
  	 * @alternative
  	 * @method off(eventMap: Object): this
  	 * Removes a set of type/listener pairs.
  	 *
  	 * @alternative
  	 * @method off: this
  	 * Removes all listeners to all events on the object. This includes implicitly attached events.
  	 */
  	off: function (types, fn, context) {

  		if (!arguments.length) {
  			// clear all listeners if called without arguments
  			delete this._events;

  		} else if (typeof types === 'object') {
  			for (var type in types) {
  				this._off(type, types[type], fn);
  			}

  		} else {
  			types = splitWords(types);

  			var removeAll = arguments.length === 1;
  			for (var i = 0, len = types.length; i < len; i++) {
  				if (removeAll) {
  					this._off(types[i]);
  				} else {
  					this._off(types[i], fn, context);
  				}
  			}
  		}

  		return this;
  	},

  	// attach listener (without syntactic sugar now)
  	_on: function (type, fn, context) {
  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}
  		this._events = this._events || {};

  		/* get/init listeners for type */
  		var typeListeners = this._events[type];
  		if (!typeListeners) {
  			typeListeners = [];
  			this._events[type] = typeListeners;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}
  		var newListener = {fn: fn, ctx: context},
  		    listeners = typeListeners;

  		// check if fn already there
  		for (var i = 0, len = listeners.length; i < len; i++) {
  			if (listeners[i].fn === fn && listeners[i].ctx === context) {
  				return;
  			}
  		}

  		listeners.push(newListener);
  	},

  	_off: function (type, fn, context) {
  		var listeners,
  		    i,
  		    len;

  		if (!this._events) { return; }

  		listeners = this._events[type];

  		if (!listeners) {
  			return;
  		}

  		if (arguments.length === 1) { // remove all
  			if (this._firingCount) {
  				// Set all removed listeners to noop
  				// so they are not called if remove happens in fire
  				for (i = 0, len = listeners.length; i < len; i++) {
  					listeners[i].fn = falseFn;
  				}
  			}
  			// clear all listeners for a type if function isn't specified
  			delete this._events[type];
  			return;
  		}

  		if (context === this) {
  			context = undefined;
  		}

  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}
  		// find fn and remove it
  		for (i = 0, len = listeners.length; i < len; i++) {
  			var l = listeners[i];
  			if (l.ctx !== context) { continue; }
  			if (l.fn === fn) {
  				if (this._firingCount) {
  					// set the removed listener to noop so that's not called if remove happens in fire
  					l.fn = falseFn;

  					/* copy array in case events are being fired */
  					this._events[type] = listeners = listeners.slice();
  				}
  				listeners.splice(i, 1);

  				return;
  			}
  		}
  		console.warn('listener not found');
  	},

  	// @method fire(type: String, data?: Object, propagate?: Boolean): this
  	// Fires an event of the specified type. You can optionally provide a data
  	// object — the first argument of the listener function will contain its
  	// properties. The event can optionally be propagated to event parents.
  	fire: function (type, data, propagate) {
  		if (!this.listens(type, propagate)) { return this; }

  		var event = extend({}, data, {
  			type: type,
  			target: this,
  			sourceTarget: data && data.sourceTarget || this
  		});

  		if (this._events) {
  			var listeners = this._events[type];

  			if (listeners) {
  				this._firingCount = (this._firingCount + 1) || 1;
  				for (var i = 0, len = listeners.length; i < len; i++) {
  					var l = listeners[i];
  					l.fn.call(l.ctx || this, event);
  				}

  				this._firingCount--;
  			}
  		}

  		if (propagate) {
  			// propagate the event to parents (set with addEventParent)
  			this._propagateEvent(event);
  		}

  		return this;
  	},

  	// @method listens(type: String, propagate?: Boolean): Boolean
  	// Returns `true` if a particular event type has any listeners attached to it.
  	// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
  	listens: function (type, propagate) {
  		if (typeof type !== 'string') {
  			console.warn('"string" type argument expected');
  		}
  		var listeners = this._events && this._events[type];
  		if (listeners && listeners.length) { return true; }

  		if (propagate) {
  			// also check parents for listeners if event propagates
  			for (var id in this._eventParents) {
  				if (this._eventParents[id].listens(type, propagate)) { return true; }
  			}
  		}
  		return false;
  	},

  	// @method once(…): this
  	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
  	once: function (types, fn, context) {

  		if (typeof types === 'object') {
  			for (var type in types) {
  				this.once(type, types[type], fn);
  			}
  			return this;
  		}

  		var handler = bind(function () {
  			this
  			    .off(types, fn, context)
  			    .off(types, handler, context);
  		}, this);

  		// add a listener that's executed once and removed after that
  		return this
  		    .on(types, fn, context)
  		    .on(types, handler, context);
  	},

  	// @method addEventParent(obj: Evented): this
  	// Adds an event parent - an `Evented` that will receive propagated events
  	addEventParent: function (obj) {
  		this._eventParents = this._eventParents || {};
  		this._eventParents[stamp(obj)] = obj;
  		return this;
  	},

  	// @method removeEventParent(obj: Evented): this
  	// Removes an event parent, so it will stop receiving propagated events
  	removeEventParent: function (obj) {
  		if (this._eventParents) {
  			delete this._eventParents[stamp(obj)];
  		}
  		return this;
  	},

  	_propagateEvent: function (e) {
  		for (var id in this._eventParents) {
  			this._eventParents[id].fire(e.type, extend({
  				layer: e.target,
  				propagatedFrom: e.target
  			}, e), true);
  		}
  	}
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(…): this
  // Alias to [`on(…)`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(…): this
  // Alias to [`off(…)`](#evented-off)

  // @method clearAllEventListeners(…): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(…): this
  // Alias to [`once(…)`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(…): this
  // Alias to [`fire(…)`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(…): Boolean
  // Alias to [`listens(…)`](#evented-listens)
  Events.hasEventListeners = Events.listens;

  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
  	// @property x: Number; The `x` coordinate of the point
  	this.x = (round ? Math.round(x) : x);
  	// @property y: Number; The `y` coordinate of the point
  	this.y = (round ? Math.round(y) : y);
  }

  var trunc = Math.trunc || function (v) {
  	return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {

  	// @method clone(): Point
  	// Returns a copy of the current point.
  	clone: function () {
  		return new Point(this.x, this.y);
  	},

  	// @method add(otherPoint: Point): Point
  	// Returns the result of addition of the current and the given points.
  	add: function (point) {
  		// non-destructive, returns a new point
  		return this.clone()._add(toPoint(point));
  	},

  	_add: function (point) {
  		// destructive, used directly for performance in situations where it's safe to modify existing point
  		this.x += point.x;
  		this.y += point.y;
  		return this;
  	},

  	// @method subtract(otherPoint: Point): Point
  	// Returns the result of subtraction of the given point from the current.
  	subtract: function (point) {
  		return this.clone()._subtract(toPoint(point));
  	},

  	_subtract: function (point) {
  		this.x -= point.x;
  		this.y -= point.y;
  		return this;
  	},

  	// @method divideBy(num: Number): Point
  	// Returns the result of division of the current point by the given number.
  	divideBy: function (num) {
  		return this.clone()._divideBy(num);
  	},

  	_divideBy: function (num) {
  		this.x /= num;
  		this.y /= num;
  		return this;
  	},

  	// @method multiplyBy(num: Number): Point
  	// Returns the result of multiplication of the current point by the given number.
  	multiplyBy: function (num) {
  		return this.clone()._multiplyBy(num);
  	},

  	_multiplyBy: function (num) {
  		this.x *= num;
  		this.y *= num;
  		return this;
  	},

  	// @method scaleBy(scale: Point): Point
  	// Multiply each coordinate of the current point by each coordinate of
  	// `scale`. In linear algebra terms, multiply the point by the
  	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  	// defined by `scale`.
  	scaleBy: function (point) {
  		return new Point(this.x * point.x, this.y * point.y);
  	},

  	// @method unscaleBy(scale: Point): Point
  	// Inverse of `scaleBy`. Divide each coordinate of the current point by
  	// each coordinate of `scale`.
  	unscaleBy: function (point) {
  		return new Point(this.x / point.x, this.y / point.y);
  	},

  	// @method round(): Point
  	// Returns a copy of the current point with rounded coordinates.
  	round: function () {
  		return this.clone()._round();
  	},

  	_round: function () {
  		this.x = Math.round(this.x);
  		this.y = Math.round(this.y);
  		return this;
  	},

  	// @method floor(): Point
  	// Returns a copy of the current point with floored coordinates (rounded down).
  	floor: function () {
  		return this.clone()._floor();
  	},

  	_floor: function () {
  		this.x = Math.floor(this.x);
  		this.y = Math.floor(this.y);
  		return this;
  	},

  	// @method ceil(): Point
  	// Returns a copy of the current point with ceiled coordinates (rounded up).
  	ceil: function () {
  		return this.clone()._ceil();
  	},

  	_ceil: function () {
  		this.x = Math.ceil(this.x);
  		this.y = Math.ceil(this.y);
  		return this;
  	},

  	// @method trunc(): Point
  	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
  	trunc: function () {
  		return this.clone()._trunc();
  	},

  	_trunc: function () {
  		this.x = trunc(this.x);
  		this.y = trunc(this.y);
  		return this;
  	},

  	// @method distanceTo(otherPoint: Point): Number
  	// Returns the cartesian distance between the current and the given points.
  	distanceTo: function (point) {
  		point = toPoint(point);

  		var x = point.x - this.x,
  		    y = point.y - this.y;

  		return Math.sqrt(x * x + y * y);
  	},

  	// @method equals(otherPoint: Point): Boolean
  	// Returns `true` if the given point has the same coordinates.
  	equals: function (point) {
  		point = toPoint(point);

  		return point.x === this.x &&
  		       point.y === this.y;
  	},

  	// @method contains(otherPoint: Point): Boolean
  	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  	contains: function (point) {
  		point = toPoint(point);

  		return Math.abs(point.x) <= Math.abs(this.x) &&
  		       Math.abs(point.y) <= Math.abs(this.y);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point for debugging purposes.
  	toString: function () {
  		return 'Point(' +
  		        formatNum(this.x) + ', ' +
  		        formatNum(this.y) + ')';
  	}
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
  	if (x instanceof Point) {
  		return x;
  	}
  	if (isArray(x)) {
  		return new Point(x[0], x[1]);
  	}
  	if (x === undefined || x === null) {
  		return x;
  	}
  	if (typeof x === 'object' && 'x' in x && 'y' in x) {
  		return new Point(x.x, x.y);
  	}
  	return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
  	if (!a) { return; }

  	var points = b ? [a, b] : a;

  	for (var i = 0, len = points.length; i < len; i++) {
  		this.extend(points[i]);
  	}
  }

  Bounds.prototype = {
  	// @method extend(point: Point): this
  	// Extends the bounds to contain the given point.
  	extend: function (point) { // (Point)
  		point = toPoint(point);

  		// @property min: Point
  		// The top left corner of the rectangle.
  		// @property max: Point
  		// The bottom right corner of the rectangle.
  		if (!this.min && !this.max) {
  			this.min = point.clone();
  			this.max = point.clone();
  		} else {
  			this.min.x = Math.min(point.x, this.min.x);
  			this.max.x = Math.max(point.x, this.max.x);
  			this.min.y = Math.min(point.y, this.min.y);
  			this.max.y = Math.max(point.y, this.max.y);
  		}
  		return this;
  	},

  	// @method getCenter(round?: Boolean): Point
  	// Returns the center point of the bounds.
  	getCenter: function (round) {
  		return new Point(
  		        (this.min.x + this.max.x) / 2,
  		        (this.min.y + this.max.y) / 2, round);
  	},

  	// @method getBottomLeft(): Point
  	// Returns the bottom-left point of the bounds.
  	getBottomLeft: function () {
  		return new Point(this.min.x, this.max.y);
  	},

  	// @method getTopRight(): Point
  	// Returns the top-right point of the bounds.
  	getTopRight: function () { // -> Point
  		return new Point(this.max.x, this.min.y);
  	},

  	// @method getTopLeft(): Point
  	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
  	getTopLeft: function () {
  		return this.min; // left, top
  	},

  	// @method getBottomRight(): Point
  	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
  	getBottomRight: function () {
  		return this.max; // right, bottom
  	},

  	// @method getSize(): Point
  	// Returns the size of the given bounds
  	getSize: function () {
  		return this.max.subtract(this.min);
  	},

  	// @method contains(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle contains the given one.
  	// @alternative
  	// @method contains(point: Point): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) {
  		var min, max;

  		if (typeof obj[0] === 'number' || obj instanceof Point) {
  			obj = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  		}

  		if (obj instanceof Bounds) {
  			min = obj.min;
  			max = obj.max;
  		} else {
  			min = max = obj;
  		}

  		return (min.x >= this.min.x) &&
  		       (max.x <= this.max.x) &&
  		       (min.y >= this.min.y) &&
  		       (max.y <= this.max.y);
  	},

  	// @method intersects(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds
  	// intersect if they have at least one point in common.
  	intersects: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
  		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

  		return xIntersects && yIntersects;
  	},

  	// @method overlaps(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
  	// overlap if their intersection is an area.
  	overlaps: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
  		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

  		return xOverlaps && yOverlaps;
  	},

  	isValid: function () {
  		return !!(this.min && this.max);
  	}
  };


  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
  	if (!a || a instanceof Bounds) {
  		return a;
  	}
  	return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
  	if (!corner1) { return; }

  	var latlngs = corner2 ? [corner1, corner2] : corner1;

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		this.extend(latlngs[i]);
  	}
  }

  LatLngBounds.prototype = {

  	// @method extend(latlng: LatLng): this
  	// Extend the bounds to contain the given point

  	// @alternative
  	// @method extend(otherBounds: LatLngBounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLng) {
  			sw2 = obj;
  			ne2 = obj;

  		} else if (obj instanceof LatLngBounds) {
  			sw2 = obj._southWest;
  			ne2 = obj._northEast;

  			if (!sw2 || !ne2) { return this; }

  		} else {
  			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
  		}

  		if (!sw && !ne) {
  			this._southWest = new LatLng(sw2.lat, sw2.lng);
  			this._northEast = new LatLng(ne2.lat, ne2.lng);
  		} else {
  			sw.lat = Math.min(sw2.lat, sw.lat);
  			sw.lng = Math.min(sw2.lng, sw.lng);
  			ne.lat = Math.max(ne2.lat, ne.lat);
  			ne.lng = Math.max(ne2.lng, ne.lng);
  		}

  		return this;
  	},

  	// @method pad(bufferRatio: Number): LatLngBounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
  		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

  		return new LatLngBounds(
  		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
  		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
  	},

  	// @method getCenter(): LatLng
  	// Returns the center point of the bounds.
  	getCenter: function () {
  		return new LatLng(
  		        (this._southWest.lat + this._northEast.lat) / 2,
  		        (this._southWest.lng + this._northEast.lng) / 2);
  	},

  	// @method getSouthWest(): LatLng
  	// Returns the south-west point of the bounds.
  	getSouthWest: function () {
  		return this._southWest;
  	},

  	// @method getNorthEast(): LatLng
  	// Returns the north-east point of the bounds.
  	getNorthEast: function () {
  		return this._northEast;
  	},

  	// @method getNorthWest(): LatLng
  	// Returns the north-west point of the bounds.
  	getNorthWest: function () {
  		return new LatLng(this.getNorth(), this.getWest());
  	},

  	// @method getSouthEast(): LatLng
  	// Returns the south-east point of the bounds.
  	getSouthEast: function () {
  		return new LatLng(this.getSouth(), this.getEast());
  	},

  	// @method getWest(): Number
  	// Returns the west longitude of the bounds
  	getWest: function () {
  		return this._southWest.lng;
  	},

  	// @method getSouth(): Number
  	// Returns the south latitude of the bounds
  	getSouth: function () {
  		return this._southWest.lat;
  	},

  	// @method getEast(): Number
  	// Returns the east longitude of the bounds
  	getEast: function () {
  		return this._northEast.lng;
  	},

  	// @method getNorth(): Number
  	// Returns the north latitude of the bounds
  	getNorth: function () {
  		return this._northEast.lat;
  	},

  	// @method contains(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle contains the given one.

  	// @alternative
  	// @method contains (latlng: LatLng): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
  		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
  			obj = toLatLng(obj);
  		} else {
  			obj = toLatLngBounds(obj);
  		}

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLngBounds) {
  			sw2 = obj.getSouthWest();
  			ne2 = obj.getNorthEast();
  		} else {
  			sw2 = ne2 = obj;
  		}

  		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
  		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
  	},

  	// @method intersects(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
  	intersects: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
  		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

  		return latIntersects && lngIntersects;
  	},

  	// @method overlaps(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
  	overlaps: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
  		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

  		return latOverlaps && lngOverlaps;
  	},

  	// @method toBBoxString(): String
  	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
  	toBBoxString: function () {
  		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
  	},

  	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
  	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (bounds, maxMargin) {
  		if (!bounds) { return false; }

  		bounds = toLatLngBounds(bounds);

  		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
  		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this._southWest && this._northEast);
  	}
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
  	if (a instanceof LatLngBounds) {
  		return a;
  	}
  	return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
  	if (isNaN(lat) || isNaN(lng)) {
  		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
  	}

  	// @property lat: Number
  	// Latitude in degrees
  	this.lat = +lat;

  	// @property lng: Number
  	// Longitude in degrees
  	this.lng = +lng;

  	// @property alt: Number
  	// Altitude in meters (optional)
  	if (alt !== undefined) {
  		this.alt = +alt;
  	}
  }

  LatLng.prototype = {
  	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
  	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (obj, maxMargin) {
  		if (!obj) { return false; }

  		obj = toLatLng(obj);

  		var margin = Math.max(
  		        Math.abs(this.lat - obj.lat),
  		        Math.abs(this.lng - obj.lng));

  		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point (for debugging purposes).
  	toString: function (precision) {
  		return 'LatLng(' +
  		        formatNum(this.lat, precision) + ', ' +
  		        formatNum(this.lng, precision) + ')';
  	},

  	// @method distanceTo(otherLatLng: LatLng): Number
  	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
  	distanceTo: function (other) {
  		return Earth.distance(this, toLatLng(other));
  	},

  	// @method wrap(): LatLng
  	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
  	wrap: function () {
  		return Earth.wrapLatLng(this);
  	},

  	// @method toBounds(sizeInMeters: Number): LatLngBounds
  	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
  	toBounds: function (sizeInMeters) {
  		var latAccuracy = 180 * sizeInMeters / 40075017,
  		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

  		return toLatLngBounds(
  		        [this.lat - latAccuracy, this.lng - lngAccuracy],
  		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
  	},

  	clone: function () {
  		return new LatLng(this.lat, this.lng, this.alt);
  	}
  };



  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
  	if (a instanceof LatLng) {
  		return a;
  	}
  	if (isArray(a) && typeof a[0] !== 'object') {
  		if (a.length === 3) {
  			return new LatLng(a[0], a[1], a[2]);
  		}
  		if (a.length === 2) {
  			return new LatLng(a[0], a[1]);
  		}
  		return null;
  	}
  	if (a === undefined || a === null) {
  		return a;
  	}
  	if (typeof a === 'object' && 'lat' in a) {
  		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
  	}
  	if (b === undefined) {
  		return null;
  	}
  	return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
  	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
  	// Projects geographical coordinates into pixel coordinates for a given zoom.
  	latLngToPoint: function (latlng, zoom) {
  		var projectedPoint = this.projection.project(latlng),
  		    scale = this.scale(zoom);

  		return this.transformation._transform(projectedPoint, scale);
  	},

  	// @method pointToLatLng(point: Point, zoom: Number): LatLng
  	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
  	// zoom into geographical coordinates.
  	pointToLatLng: function (point, zoom) {
  		var scale = this.scale(zoom),
  		    untransformedPoint = this.transformation.untransform(point, scale);

  		return this.projection.unproject(untransformedPoint);
  	},

  	// @method project(latlng: LatLng): Point
  	// Projects geographical coordinates into coordinates in units accepted for
  	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
  	project: function (latlng) {
  		return this.projection.project(latlng);
  	},

  	// @method unproject(point: Point): LatLng
  	// Given a projected coordinate returns the corresponding LatLng.
  	// The inverse of `project`.
  	unproject: function (point) {
  		return this.projection.unproject(point);
  	},

  	// @method scale(zoom: Number): Number
  	// Returns the scale used when transforming projected coordinates into
  	// pixel coordinates for a particular zoom. For example, it returns
  	// `256 * 2^zoom` for Mercator-based CRS.
  	scale: function (zoom) {
  		return 256 * Math.pow(2, zoom);
  	},

  	// @method zoom(scale: Number): Number
  	// Inverse of `scale()`, returns the zoom level corresponding to a scale
  	// factor of `scale`.
  	zoom: function (scale) {
  		return Math.log(scale / 256) / Math.LN2;
  	},

  	// @method getProjectedBounds(zoom: Number): Bounds
  	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
  	getProjectedBounds: function (zoom) {
  		if (this.infinite) { return null; }

  		var b = this.projection.bounds,
  		    s = this.scale(zoom),
  		    min = this.transformation.transform(b.min, s),
  		    max = this.transformation.transform(b.max, s);

  		return new Bounds(min, max);
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates.

  	// @property code: String
  	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
  	//
  	// @property wrapLng: Number[]
  	// An array of two numbers defining whether the longitude (horizontal) coordinate
  	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
  	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
  	//
  	// @property wrapLat: Number[]
  	// Like `wrapLng`, but for the latitude (vertical) axis.

  	// wrapLng: [min, max],
  	// wrapLat: [min, max],

  	// @property infinite: Boolean
  	// If true, the coordinate space will be unbounded (infinite in both axes)
  	infinite: false,

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where lat and lng has been wrapped according to the
  	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
  	wrapLatLng: function (latlng) {
  		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
  		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
  		    alt = latlng.alt;

  		return new LatLng(lat, lng, alt);
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring
  	// that its center is within the CRS's bounds.
  	// Only accepts actual `L.LatLngBounds` instances, not arrays.
  	wrapLatLngBounds: function (bounds) {
  		var center = bounds.getCenter(),
  		    newCenter = this.wrapLatLng(center),
  		    latShift = center.lat - newCenter.lat,
  		    lngShift = center.lng - newCenter.lng;

  		if (latShift === 0 && lngShift === 0) {
  			return bounds;
  		}

  		var sw = bounds.getSouthWest(),
  		    ne = bounds.getNorthEast(),
  		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
  		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

  		return new LatLngBounds(newSw, newNe);
  	}
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
  	wrapLng: [-180, 180],

  	// Mean Earth Radius, as recommended for use by
  	// the International Union of Geodesy and Geophysics,
  	// see https://rosettacode.org/wiki/Haversine_formula
  	R: 6371000,

  	// distance between two geographical points using spherical law of cosines approximation
  	distance: function (latlng1, latlng2) {
  		var rad = Math.PI / 180,
  		    lat1 = latlng1.lat * rad,
  		    lat2 = latlng2.lat * rad,
  		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
  		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
  		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
  		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  		return this.R * c;
  	}
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection — the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;

  var SphericalMercator = {

  	R: earthRadius,
  	MAX_LATITUDE: 85.0511287798,

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    max = this.MAX_LATITUDE,
  		    lat = Math.max(Math.min(max, latlng.lat), -max),
  		    sin = Math.sin(lat * d);

  		return new Point(
  			this.R * latlng.lng * d,
  			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI;

  		return new LatLng(
  			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
  			point.x * d / this.R);
  	},

  	bounds: (function () {
  		var d = earthRadius * Math.PI;
  		return new Bounds([-d, -d], [d, d]);
  	})()
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */


  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
  	if (isArray(a)) {
  		// use array properties
  		this._a = a[0];
  		this._b = a[1];
  		this._c = a[2];
  		this._d = a[3];
  		return;
  	}
  	this._a = a;
  	this._b = b;
  	this._c = c;
  	this._d = d;
  }

  Transformation.prototype = {
  	// @method transform(point: Point, scale?: Number): Point
  	// Returns a transformed point, optionally multiplied by the given scale.
  	// Only accepts actual `L.Point` instances, not arrays.
  	transform: function (point, scale) { // (Point, Number) -> Point
  		return this._transform(point.clone(), scale);
  	},

  	// destructive transform (faster)
  	_transform: function (point, scale) {
  		scale = scale || 1;
  		point.x = scale * (this._a * point.x + this._b);
  		point.y = scale * (this._c * point.y + this._d);
  		return point;
  	},

  	// @method untransform(point: Point, scale?: Number): Point
  	// Returns the reverse transformation of the given point, optionally divided
  	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
  	untransform: function (point, scale) {
  		scale = scale || 1;
  		return new Point(
  		        (point.x / scale - this._b) / this._a,
  		        (point.y / scale - this._d) / this._c);
  	}
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
  	return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
  	code: 'EPSG:3857',
  	projection: SphericalMercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * SphericalMercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  var EPSG900913 = extend({}, EPSG3857, {
  	code: 'EPSG:900913'
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
  	return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
  	var str = '',
  	i, j, len, len2, points, p;

  	for (i = 0, len = rings.length; i < len; i++) {
  		points = rings[i];

  		for (j = 0, len2 = points.length; j < len2; j++) {
  			p = points[j];
  			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
  		}

  		// closes the ring for polygons; "x" is VML syntax
  		str += closed ? (Browser.svg ? 'z' : 'x') : '';
  	}

  	// SVG complains about empty path strings
  	return str || 'M0 0';
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = 'ActiveXObject' in window;

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains('webkit');

  // @property android: Boolean
  // **Deprecated.** `true` for any browser running on an Android platform.
  var android = userAgentContains('android');

  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
  var android23 = userAgentContains('android 2') || userAgentContains('android 3');

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains('chrome');

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains('safari');

  var phantom = userAgentContains('phantom');

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = 'OTransition' in style;

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf('Win') === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && ('transition' in style);

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = 'MozPerspective' in style;

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touchNative: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // **This does not necessarily mean** that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;

  // @property touch: Boolean
  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
  var touch = !window.L_NO_TOUCH && (touchNative || pointer);

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = (function () {
  	var supportsPassiveOption = false;
  	try {
  		var opts = Object.defineProperty({}, 'passive', {
  			get: function () { // eslint-disable-line getter-return
  				supportsPassiveOption = true;
  			}
  		});
  		window.addEventListener('testPassiveEventSupport', falseFn, opts);
  		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
  	} catch (e) {
  		// Errors can safely be ignored since this is only a browser support test.
  	}
  	return supportsPassiveOption;
  }());

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas$1 = (function () {
  	return !!document.createElement('canvas').getContext;
  }());

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);

  var inlineSvg = !!svg$1 && (function () {
  	var div = document.createElement('div');
  	div.innerHTML = '<svg/>';
  	return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';
  })();

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml = !svg$1 && (function () {
  	try {
  		var div = document.createElement('div');
  		div.innerHTML = '<v:shape adj="1"/>';

  		var shape = div.firstChild;
  		shape.style.behavior = 'url(#default#VML)';

  		return shape && (typeof shape.adj === 'object');

  	} catch (e) {
  		return false;
  	}
  }());

  function userAgentContains(str) {
  	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }


  var Browser = {
  	ie: ie,
  	ielt9: ielt9,
  	edge: edge,
  	webkit: webkit,
  	android: android,
  	android23: android23,
  	androidStock: androidStock,
  	opera: opera,
  	chrome: chrome,
  	gecko: gecko,
  	safari: safari,
  	phantom: phantom,
  	opera12: opera12,
  	win: win,
  	ie3d: ie3d,
  	webkit3d: webkit3d,
  	gecko3d: gecko3d,
  	any3d: any3d,
  	mobile: mobile,
  	mobileWebkit: mobileWebkit,
  	mobileWebkit3d: mobileWebkit3d,
  	msPointer: msPointer,
  	pointer: pointer,
  	touch: touch,
  	touchNative: touchNative,
  	mobileOpera: mobileOpera,
  	mobileGecko: mobileGecko,
  	retina: retina,
  	passiveEvents: passiveEvents,
  	canvas: canvas$1,
  	svg: svg$1,
  	vml: vml,
  	inlineSvg: inlineSvg
  };

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';
  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';
  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';
  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';
  var pEvent = {
  	touchstart  : POINTER_DOWN,
  	touchmove   : POINTER_MOVE,
  	touchend    : POINTER_UP,
  	touchcancel : POINTER_CANCEL
  };
  var handle = {
  	touchstart  : _onPointerStart,
  	touchmove   : _handlePointer,
  	touchend    : _handlePointer,
  	touchcancel : _handlePointer
  };
  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler) {
  	if (type === 'touchstart') {
  		_addPointerDocListener();
  	}
  	if (!handle[type]) {
  		console.warn('wrong event specified:', type);
  		return L.Util.falseFn;
  	}
  	handler = handle[type].bind(this, handler);
  	obj.addEventListener(pEvent[type], handler, false);
  	return handler;
  }

  function removePointerListener(obj, type, handler) {
  	if (!pEvent[type]) {
  		console.warn('wrong event specified:', type);
  		return;
  	}
  	obj.removeEventListener(pEvent[type], handler, false);
  }

  function _globalPointerDown(e) {
  	_pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
  	if (_pointers[e.pointerId]) {
  		_pointers[e.pointerId] = e;
  	}
  }

  function _globalPointerUp(e) {
  	delete _pointers[e.pointerId];
  }

  function _addPointerDocListener() {
  	// need to keep track of what pointers and how many are active to provide e.touches emulation
  	if (!_pointerDocListener) {
  		// we listen document as any drags that end by moving the touch off the screen get fired there
  		document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
  		document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
  		document.addEventListener(POINTER_UP, _globalPointerUp, true);
  		document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

  		_pointerDocListener = true;
  	}
  }

  function _handlePointer(handler, e) {
  	if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }

  	e.touches = [];
  	for (var i in _pointers) {
  		e.touches.push(_pointers[i]);
  	}
  	e.changedTouches = [e];

  	handler(e);
  }

  function _onPointerStart(handler, e) {
  	// IE10 specific: MsTouch needs preventDefault. See #2000
  	if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
  		preventDefault(e);
  	}
  	_handlePointer(handler, e);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */

  function makeDblclick(event) {
  	// in modern browsers `type` cannot be just overridden:
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
  	var newEvent = {},
  	    prop, i;
  	for (i in event) {
  		prop = event[i];
  		newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  	}
  	event = newEvent;
  	newEvent.type = 'dblclick';
  	newEvent.detail = 2;
  	newEvent.isTrusted = false;
  	newEvent._simulated = true; // for debug purposes
  	return newEvent;
  }

  var delay = 200;
  function addDoubleTapListener(obj, handler) {
  	// Most browsers handle double tap natively
  	obj.addEventListener('dblclick', handler);

  	// On some platforms the browser doesn't fire native dblclicks for touch events.
  	// It seems that in all such cases `detail` property of `click` event is always `1`.
  	// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
  	var last = 0,
  	    detail;
  	function simDblclick(e) {
  		if (e.detail !== 1) {
  			detail = e.detail; // keep in sync to avoid false dblclick in some cases
  			return;
  		}

  		if (e.pointerType === 'mouse' ||
  			(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {

  			return;
  		}

  		var now = Date.now();
  		if (now - last <= delay) {
  			detail++;
  			if (detail === 2) {
  				handler(makeDblclick(e));
  			}
  		} else {
  			detail = 1;
  		}
  		last = now;
  	}

  	obj.addEventListener('click', simDblclick);

  	return {
  		dblclick: handler,
  		simDblclick: simDblclick
  	};
  }

  function removeDoubleTapListener(obj, handlers) {
  	obj.removeEventListener('dblclick', handlers.dblclick);
  	obj.removeEventListener('click', handlers.simDblclick);
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */


  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp(
  	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp(
  	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END =
  	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
  	return typeof id === 'string' ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
  	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

  	if ((!value || value === 'auto') && document.defaultView) {
  		var css = document.defaultView.getComputedStyle(el, null);
  		value = css ? css[style] : null;
  	}
  	return value === 'auto' ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
  	var el = document.createElement(tagName);
  	el.className = className || '';

  	if (container) {
  		container.appendChild(el);
  	}
  	return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
  	var parent = el.parentNode;
  	if (parent) {
  		parent.removeChild(el);
  	}
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
  	while (el.firstChild) {
  		el.removeChild(el.firstChild);
  	}
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
  	var parent = el.parentNode;
  	if (parent && parent.lastChild !== el) {
  		parent.appendChild(el);
  	}
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
  	var parent = el.parentNode;
  	if (parent && parent.firstChild !== el) {
  		parent.insertBefore(el, parent.firstChild);
  	}
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
  	if (el.classList !== undefined) {
  		return el.classList.contains(name);
  	}
  	var className = getClass(el);
  	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
  	if (el.classList !== undefined) {
  		var classes = splitWords(name);
  		for (var i = 0, len = classes.length; i < len; i++) {
  			el.classList.add(classes[i]);
  		}
  	} else if (!hasClass(el, name)) {
  		var className = getClass(el);
  		setClass(el, (className ? className + ' ' : '') + name);
  	}
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
  	if (el.classList !== undefined) {
  		el.classList.remove(name);
  	} else {
  		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  	}
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
  	if (el.className.baseVal === undefined) {
  		el.className = name;
  	} else {
  		// in case of SVG element
  		el.className.baseVal = name;
  	}
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
  	// Check if the element is an SVGElementInstance and use the correspondingElement instead
  	// (Required for linked SVG elements in IE11.)
  	if (el.correspondingElement) {
  		el = el.correspondingElement;
  	}
  	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
  	if ('opacity' in el.style) {
  		el.style.opacity = value;
  	} else if ('filter' in el.style) {
  		_setOpacityIE(el, value);
  	}
  }

  function _setOpacityIE(el, value) {
  	var filter = false,
  	    filterName = 'DXImageTransform.Microsoft.Alpha';

  	// filters collection throws an error if we try to retrieve a filter that doesn't exist
  	try {
  		filter = el.filters.item(filterName);
  	} catch (e) {
  		// don't set opacity to 1 if we haven't already set an opacity,
  		// it isn't needed and breaks transparent pngs.
  		if (value === 1) { return; }
  	}

  	value = Math.round(value * 100);

  	if (filter) {
  		filter.Enabled = (value !== 100);
  		filter.Opacity = value;
  	} else {
  		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
  	}
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
  	var style = document.documentElement.style;

  	for (var i = 0; i < props.length; i++) {
  		if (props[i] in style) {
  			return props[i];
  		}
  	}
  	return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
  	var pos = offset || new Point(0, 0);

  	el.style[TRANSFORM] =
  		(Browser.ie3d ?
  			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
  			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
  		(scale ? ' scale(' + scale + ')' : '');
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {

  	/*eslint-disable */
  	el._leaflet_pos = point;
  	/* eslint-enable */

  	if (Browser.any3d) {
  		setTransform(el, point);
  	} else {
  		el.style.left = point.x + 'px';
  		el.style.top = point.y + 'px';
  	}
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
  	// this method is only used for elements previously positioned using setPosition,
  	// so it's safe to cache the position for performance

  	return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ('onselectstart' in document) {
  	disableTextSelection = function () {
  		on(window, 'selectstart', preventDefault);
  	};
  	enableTextSelection = function () {
  		off(window, 'selectstart', preventDefault);
  	};
  } else {
  	var userSelectProperty = testProp(
  		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

  	disableTextSelection = function () {
  		if (userSelectProperty) {
  			var style = document.documentElement.style;
  			_userSelect = style[userSelectProperty];
  			style[userSelectProperty] = 'none';
  		}
  	};
  	enableTextSelection = function () {
  		if (userSelectProperty) {
  			document.documentElement.style[userSelectProperty] = _userSelect;
  			_userSelect = undefined;
  		}
  	};
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
  	on(window, 'dragstart', preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
  	off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
  	while (element.tabIndex === -1) {
  		element = element.parentNode;
  	}
  	if (!element.style) { return; }
  	restoreOutline();
  	_outlineElement = element;
  	_outlineStyle = element.style.outline;
  	element.style.outline = 'none';
  	on(window, 'keydown', restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
  	if (!_outlineElement) { return; }
  	_outlineElement.style.outline = _outlineStyle;
  	_outlineElement = undefined;
  	_outlineStyle = undefined;
  	off(window, 'keydown', restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
  	do {
  		element = element.parentNode;
  	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  	return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
  	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

  	return {
  		x: rect.width / element.offsetWidth || 1,
  		y: rect.height / element.offsetHeight || 1,
  		boundingClientRect: rect
  	};
  }

  var DomUtil = {
    __proto__: null,
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    get disableTextSelection () { return disableTextSelection; },
    get enableTextSelection () { return enableTextSelection; },
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {

  	if (types && typeof types === 'object') {
  		for (var type in types) {
  			addOne(obj, type, types[type], fn);
  		}
  	} else {
  		types = splitWords(types);

  		for (var i = 0, len = types.length; i < len; i++) {
  			addOne(obj, types[i], fn, context);
  		}
  	}

  	return this;
  }

  var eventsKey = '_leaflet_events';

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  // @alternative
  // @function off(el: HTMLElement, types: String): this
  // Removes all previously added listeners of given types.

  // @alternative
  // @function off(el: HTMLElement): this
  // Removes all previously added listeners from given HTMLElement
  function off(obj, types, fn, context) {

  	if (arguments.length === 1) {
  		batchRemove(obj);
  		delete obj[eventsKey];

  	} else if (types && typeof types === 'object') {
  		for (var type in types) {
  			removeOne(obj, type, types[type], fn);
  		}

  	} else {
  		types = splitWords(types);

  		if (arguments.length === 2) {
  			batchRemove(obj, function (type) {
  				return indexOf(types, type) !== -1;
  			});
  		} else {
  			for (var i = 0, len = types.length; i < len; i++) {
  				removeOne(obj, types[i], fn, context);
  			}
  		}
  	}

  	return this;
  }

  function batchRemove(obj, filterFn) {
  	for (var id in obj[eventsKey]) {
  		var type = id.split(/\d/)[0];
  		if (!filterFn || filterFn(type)) {
  			removeOne(obj, type, null, null, id);
  		}
  	}
  }

  var mouseSubst = {
  	mouseenter: 'mouseover',
  	mouseleave: 'mouseout',
  	wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
  	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

  	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

  	var handler = function (e) {
  		return fn.call(context || obj, e || window.event);
  	};

  	var originalHandler = handler;

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		// Needs DomEvent.Pointer.js
  		handler = addPointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		handler = addDoubleTapListener(obj, handler);

  	} else if ('addEventListener' in obj) {

  		if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {
  			obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);

  		} else if (type === 'mouseenter' || type === 'mouseleave') {
  			handler = function (e) {
  				e = e || window.event;
  				if (isExternalTarget(obj, e)) {
  					originalHandler(e);
  				}
  			};
  			obj.addEventListener(mouseSubst[type], handler, false);

  		} else {
  			obj.addEventListener(type, originalHandler, false);
  		}

  	} else {
  		obj.attachEvent('on' + type, handler);
  	}

  	obj[eventsKey] = obj[eventsKey] || {};
  	obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context, id) {
  	id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');
  	var handler = obj[eventsKey] && obj[eventsKey][id];

  	if (!handler) { return this; }

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		removePointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		removeDoubleTapListener(obj, handler);

  	} else if ('removeEventListener' in obj) {

  		obj.removeEventListener(mouseSubst[type] || type, handler, false);

  	} else {
  		obj.detachEvent('on' + type, handler);
  	}

  	obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {

  	if (e.stopPropagation) {
  		e.stopPropagation();
  	} else if (e.originalEvent) {  // In case of Leaflet event.
  		e.originalEvent._stopped = true;
  	} else {
  		e.cancelBubble = true;
  	}

  	return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
  	addOne(el, 'wheel', stopPropagation);
  	return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
  	on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);
  	el['_leaflet_disable_click'] = true;
  	return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
  	if (e.preventDefault) {
  		e.preventDefault();
  	} else {
  		e.returnValue = false;
  	}
  	return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
  	preventDefault(e);
  	stopPropagation(e);
  	return this;
  }

  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
  	if (!container) {
  		return new Point(e.clientX, e.clientY);
  	}

  	var scale = getScale(container),
  	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

  	return new Point(
  		// offset.left/top values are in page scale (like clientX/Y),
  		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
  		(e.clientX - offset.left) / scale.x - container.clientLeft,
  		(e.clientY - offset.top) / scale.y - container.clientTop
  	);
  }

  // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
  // and Firefox scrolls device pixels, not CSS pixels
  var wheelPxFactor =
  	(Browser.win && Browser.chrome) ? 2 * window.devicePixelRatio :
  	Browser.gecko ? window.devicePixelRatio : 1;

  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
  	return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
  	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
  	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
  	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
  	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
  	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
  	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
  	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
  	       0;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {

  	var related = e.relatedTarget;

  	if (!related) { return true; }

  	try {
  		while (related && (related !== el)) {
  			related = related.parentNode;
  		}
  	} catch (err) {
  		return false;
  	}
  	return (related !== el);
  }

  var DomEvent = {
    __proto__: null,
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var fx = new L.PosAnimation();
   * fx.run(el, [300, 500], 0.5);
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({

  	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
  	// Run an animation of a given element to a new position, optionally setting
  	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
  	// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
  	// `0.5` by default).
  	run: function (el, newPos, duration, easeLinearity) {
  		this.stop();

  		this._el = el;
  		this._inProgress = true;
  		this._duration = duration || 0.25;
  		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

  		this._startPos = getPosition(el);
  		this._offset = newPos.subtract(this._startPos);
  		this._startTime = +new Date();

  		// @event start: Event
  		// Fired when the animation starts
  		this.fire('start');

  		this._animate();
  	},

  	// @method stop()
  	// Stops the animation (if currently running).
  	stop: function () {
  		if (!this._inProgress) { return; }

  		this._step(true);
  		this._complete();
  	},

  	_animate: function () {
  		// animation loop
  		this._animId = requestAnimFrame(this._animate, this);
  		this._step();
  	},

  	_step: function (round) {
  		var elapsed = (+new Date()) - this._startTime,
  		    duration = this._duration * 1000;

  		if (elapsed < duration) {
  			this._runFrame(this._easeOut(elapsed / duration), round);
  		} else {
  			this._runFrame(1);
  			this._complete();
  		}
  	},

  	_runFrame: function (progress, round) {
  		var pos = this._startPos.add(this._offset.multiplyBy(progress));
  		if (round) {
  			pos._round();
  		}
  		setPosition(this._el, pos);

  		// @event step: Event
  		// Fired continuously during the animation.
  		this.fire('step');
  	},

  	_complete: function () {
  		cancelAnimFrame(this._animId);

  		this._inProgress = false;
  		// @event end: Event
  		// Fired when the animation ends.
  		this.fire('end');
  	},

  	_easeOut: function (t) {
  		return 1 - Math.pow(1 - t, this._easeOutPower);
  	}
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API — it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({

  	options: {
  		// @section Map State Options
  		// @option crs: CRS = L.CRS.EPSG3857
  		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
  		// sure what it means.
  		crs: EPSG3857,

  		// @option center: LatLng = undefined
  		// Initial geographic center of the map
  		center: undefined,

  		// @option zoom: Number = undefined
  		// Initial map zoom level
  		zoom: undefined,

  		// @option minZoom: Number = *
  		// Minimum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the lowest of their `minZoom` options will be used instead.
  		minZoom: undefined,

  		// @option maxZoom: Number = *
  		// Maximum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the highest of their `maxZoom` options will be used instead.
  		maxZoom: undefined,

  		// @option layers: Layer[] = []
  		// Array of layers that will be added to the map initially
  		layers: [],

  		// @option maxBounds: LatLngBounds = null
  		// When this option is set, the map restricts the view to the given
  		// geographical bounds, bouncing the user back if the user tries to pan
  		// outside the view. To set the restriction dynamically, use
  		// [`setMaxBounds`](#map-setmaxbounds) method.
  		maxBounds: undefined,

  		// @option renderer: Renderer = *
  		// The default method for drawing vector layers on the map. `L.SVG`
  		// or `L.Canvas` by default depending on browser support.
  		renderer: undefined,


  		// @section Animation Options
  		// @option zoomAnimation: Boolean = true
  		// Whether the map zoom animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		zoomAnimation: true,

  		// @option zoomAnimationThreshold: Number = 4
  		// Won't animate zoom if the zoom difference exceeds this value.
  		zoomAnimationThreshold: 4,

  		// @option fadeAnimation: Boolean = true
  		// Whether the tile fade animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		fadeAnimation: true,

  		// @option markerZoomAnimation: Boolean = true
  		// Whether markers animate their zoom with the zoom animation, if disabled
  		// they will disappear for the length of the animation. By default it's
  		// enabled in all browsers that support CSS3 Transitions except Android.
  		markerZoomAnimation: true,

  		// @option transform3DLimit: Number = 2^23
  		// Defines the maximum size of a CSS translation transform. The default
  		// value should not be changed unless a web browser positions layers in
  		// the wrong place after doing a large `panBy`.
  		transform3DLimit: 8388608, // Precision limit of a 32-bit float

  		// @section Interaction Options
  		// @option zoomSnap: Number = 1
  		// Forces the map's zoom level to always be a multiple of this, particularly
  		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
  		// By default, the zoom level snaps to the nearest integer; lower values
  		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
  		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
  		zoomSnap: 1,

  		// @option zoomDelta: Number = 1
  		// Controls how much the map's zoom level will change after a
  		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
  		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
  		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
  		zoomDelta: 1,

  		// @option trackResize: Boolean = true
  		// Whether the map automatically handles browser window resize to update itself.
  		trackResize: true
  	},

  	initialize: function (id, options) { // (HTMLElement or String, Object)
  		options = setOptions(this, options);

  		// Make sure to assign internal flags at the beginning,
  		// to avoid inconsistent state in some edge cases.
  		this._handlers = [];
  		this._layers = {};
  		this._zoomBoundLayers = {};
  		this._sizeChanged = true;

  		this._initContainer(id);
  		this._initLayout();

  		// hack for https://github.com/Leaflet/Leaflet/issues/1980
  		this._onResize = bind(this._onResize, this);

  		this._initEvents();

  		if (options.maxBounds) {
  			this.setMaxBounds(options.maxBounds);
  		}

  		if (options.zoom !== undefined) {
  			this._zoom = this._limitZoom(options.zoom);
  		}

  		if (options.center && options.zoom !== undefined) {
  			this.setView(toLatLng(options.center), options.zoom, {reset: true});
  		}

  		this.callInitHooks();

  		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
  		this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&
  				this.options.zoomAnimation;

  		// zoom transitions run with the same duration for all layers, so if one of transitionend events
  		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
  		if (this._zoomAnimated) {
  			this._createAnimProxy();
  			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
  		}

  		this._addLayers(this.options.layers);
  	},


  	// @section Methods for modifying map state

  	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) with the given
  	// animation options.
  	setView: function (center, zoom, options) {

  		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
  		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
  		options = options || {};

  		this._stop();

  		if (this._loaded && !options.reset && options !== true) {

  			if (options.animate !== undefined) {
  				options.zoom = extend({animate: options.animate}, options.zoom);
  				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
  			}

  			// try animating pan or zoom
  			var moved = (this._zoom !== zoom) ?
  				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
  				this._tryAnimatedPan(center, options.pan);

  			if (moved) {
  				// prevent resize handler call, the view will refresh after animation anyway
  				clearTimeout(this._sizeTimer);
  				return this;
  			}
  		}

  		// animation didn't start, just reset the map view
  		this._resetView(center, zoom);

  		return this;
  	},

  	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
  	// Sets the zoom of the map.
  	setZoom: function (zoom, options) {
  		if (!this._loaded) {
  			this._zoom = zoom;
  			return this;
  		}
  		return this.setView(this.getCenter(), zoom, {zoom: options});
  	},

  	// @method zoomIn(delta?: Number, options?: Zoom options): this
  	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomIn: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom + delta, options);
  	},

  	// @method zoomOut(delta?: Number, options?: Zoom options): this
  	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomOut: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom - delta, options);
  	},

  	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified geographical point on the map
  	// stationary (e.g. used internally for scroll zoom and double-click zoom).
  	// @alternative
  	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
  	setZoomAround: function (latlng, zoom, options) {
  		var scale = this.getZoomScale(zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

  		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
  		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

  		return this.setView(newCenter, zoom, {zoom: options});
  	},

  	_getBoundsCenterZoom: function (bounds, options) {

  		options = options || {};
  		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

  		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

  		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

  		if (zoom === Infinity) {
  			return {
  				center: bounds.getCenter(),
  				zoom: zoom
  			};
  		}

  		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

  		    swPoint = this.project(bounds.getSouthWest(), zoom),
  		    nePoint = this.project(bounds.getNorthEast(), zoom),
  		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

  		return {
  			center: center,
  			zoom: zoom
  		};
  	},

  	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets a map view that contains the given geographical bounds with the
  	// maximum zoom level possible.
  	fitBounds: function (bounds, options) {

  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			throw new Error('Bounds are not valid.');
  		}

  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.setView(target.center, target.zoom, options);
  	},

  	// @method fitWorld(options?: fitBounds options): this
  	// Sets a map view that mostly contains the whole world with the maximum
  	// zoom level possible.
  	fitWorld: function (options) {
  		return this.fitBounds([[-90, -180], [90, 180]], options);
  	},

  	// @method panTo(latlng: LatLng, options?: Pan options): this
  	// Pans the map to a given center.
  	panTo: function (center, options) { // (LatLng)
  		return this.setView(center, this._zoom, {pan: options});
  	},

  	// @method panBy(offset: Point, options?: Pan options): this
  	// Pans the map by a given number of pixels (animated).
  	panBy: function (offset, options) {
  		offset = toPoint(offset).round();
  		options = options || {};

  		if (!offset.x && !offset.y) {
  			return this.fire('moveend');
  		}
  		// If we pan too far, Chrome gets issues with tiles
  		// and makes them disappear or appear in the wrong place (slightly offset) #2602
  		if (options.animate !== true && !this.getSize().contains(offset)) {
  			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
  			return this;
  		}

  		if (!this._panAnim) {
  			this._panAnim = new PosAnimation();

  			this._panAnim.on({
  				'step': this._onPanTransitionStep,
  				'end': this._onPanTransitionEnd
  			}, this);
  		}

  		// don't fire movestart if animating inertia
  		if (!options.noMoveStart) {
  			this.fire('movestart');
  		}

  		// animate pan unless animate: false specified
  		if (options.animate !== false) {
  			addClass(this._mapPane, 'leaflet-pan-anim');

  			var newPos = this._getMapPanePos().subtract(offset).round();
  			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
  		} else {
  			this._rawPanBy(offset);
  			this.fire('move').fire('moveend');
  		}

  		return this;
  	},

  	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) performing a smooth
  	// pan-zoom animation.
  	flyTo: function (targetCenter, targetZoom, options) {

  		options = options || {};
  		if (options.animate === false || !Browser.any3d) {
  			return this.setView(targetCenter, targetZoom, options);
  		}

  		this._stop();

  		var from = this.project(this.getCenter()),
  		    to = this.project(targetCenter),
  		    size = this.getSize(),
  		    startZoom = this._zoom;

  		targetCenter = toLatLng(targetCenter);
  		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

  		var w0 = Math.max(size.x, size.y),
  		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
  		    u1 = (to.distanceTo(from)) || 1,
  		    rho = 1.42,
  		    rho2 = rho * rho;

  		function r(i) {
  			var s1 = i ? -1 : 1,
  			    s2 = i ? w1 : w0,
  			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
  			    b1 = 2 * s2 * rho2 * u1,
  			    b = t1 / b1,
  			    sq = Math.sqrt(b * b + 1) - b;

  			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
  			    // thus triggering an infinite loop in flyTo
  			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

  			return log;
  		}

  		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
  		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
  		function tanh(n) { return sinh(n) / cosh(n); }

  		var r0 = r(0);

  		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
  		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

  		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

  		var start = Date.now(),
  		    S = (r(1) - r0) / rho,
  		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

  		function frame() {
  			var t = (Date.now() - start) / duration,
  			    s = easeOut(t) * S;

  			if (t <= 1) {
  				this._flyToFrame = requestAnimFrame(frame, this);

  				this._move(
  					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
  					this.getScaleZoom(w0 / w(s), startZoom),
  					{flyTo: true});

  			} else {
  				this
  					._move(targetCenter, targetZoom)
  					._moveEnd(true);
  			}
  		}

  		this._moveStart(true, options.noMoveStart);

  		frame.call(this);
  		return this;
  	},

  	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
  	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
  	flyToBounds: function (bounds, options) {
  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.flyTo(target.center, target.zoom, options);
  	},

  	// @method setMaxBounds(bounds: LatLngBounds): this
  	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
  	setMaxBounds: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			this.options.maxBounds = null;
  			return this.off('moveend', this._panInsideMaxBounds);
  		} else if (this.options.maxBounds) {
  			this.off('moveend', this._panInsideMaxBounds);
  		}

  		this.options.maxBounds = bounds;

  		if (this._loaded) {
  			this._panInsideMaxBounds();
  		}

  		return this.on('moveend', this._panInsideMaxBounds);
  	},

  	// @method setMinZoom(zoom: Number): this
  	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
  	setMinZoom: function (zoom) {
  		var oldZoom = this.options.minZoom;
  		this.options.minZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() < this.options.minZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method setMaxZoom(zoom: Number): this
  	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
  	setMaxZoom: function (zoom) {
  		var oldZoom = this.options.maxZoom;
  		this.options.maxZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() > this.options.maxZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
  	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
  	panInsideBounds: function (bounds, options) {
  		this._enforcingBounds = true;
  		var center = this.getCenter(),
  		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

  		if (!center.equals(newCenter)) {
  			this.panTo(newCenter, options);
  		}

  		this._enforcingBounds = false;
  		return this;
  	},

  	// @method panInside(latlng: LatLng, options?: padding options): this
  	// Pans the map the minimum amount to make the `latlng` visible. Use
  	// padding options to fit the display to more restricted bounds.
  	// If `latlng` is already within the (optionally padded) display bounds,
  	// the map will not be panned.
  	panInside: function (latlng, options) {
  		options = options || {};

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
  		    pixelCenter = this.project(this.getCenter()),
  		    pixelPoint = this.project(latlng),
  		    pixelBounds = this.getPixelBounds(),
  		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),
  		    paddedSize = paddedBounds.getSize();

  		if (!paddedBounds.contains(pixelPoint)) {
  			this._enforcingBounds = true;
  			var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
  			var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
  			pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
  			pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
  			this.panTo(this.unproject(pixelCenter), options);
  			this._enforcingBounds = false;
  		}
  		return this;
  	},

  	// @method invalidateSize(options: Zoom/pan options): this
  	// Checks if the map container size changed and updates the map if so —
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default. If `options.pan` is `false`, panning will not occur.
  	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
  	// that it doesn't happen often even if the method is called many
  	// times in a row.

  	// @alternative
  	// @method invalidateSize(animate: Boolean): this
  	// Checks if the map container size changed and updates the map if so —
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default.
  	invalidateSize: function (options) {
  		if (!this._loaded) { return this; }

  		options = extend({
  			animate: false,
  			pan: true
  		}, options === true ? {animate: true} : options);

  		var oldSize = this.getSize();
  		this._sizeChanged = true;
  		this._lastCenter = null;

  		var newSize = this.getSize(),
  		    oldCenter = oldSize.divideBy(2).round(),
  		    newCenter = newSize.divideBy(2).round(),
  		    offset = oldCenter.subtract(newCenter);

  		if (!offset.x && !offset.y) { return this; }

  		if (options.animate && options.pan) {
  			this.panBy(offset);

  		} else {
  			if (options.pan) {
  				this._rawPanBy(offset);
  			}

  			this.fire('move');

  			if (options.debounceMoveend) {
  				clearTimeout(this._sizeTimer);
  				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
  			} else {
  				this.fire('moveend');
  			}
  		}

  		// @section Map state change events
  		// @event resize: ResizeEvent
  		// Fired when the map is resized.
  		return this.fire('resize', {
  			oldSize: oldSize,
  			newSize: newSize
  		});
  	},

  	// @section Methods for modifying map state
  	// @method stop(): this
  	// Stops the currently running `panTo` or `flyTo` animation, if any.
  	stop: function () {
  		this.setZoom(this._limitZoom(this._zoom));
  		if (!this.options.zoomSnap) {
  			this.fire('viewreset');
  		}
  		return this._stop();
  	},

  	// @section Geolocation methods
  	// @method locate(options?: Locate options): this
  	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
  	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
  	// and optionally sets the map view to the user's location with respect to
  	// detection accuracy (or to the world view if geolocation failed).
  	// Note that, if your page doesn't use HTTPS, this method will fail in
  	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
  	// See `Locate options` for more details.
  	locate: function (options) {

  		options = this._locateOptions = extend({
  			timeout: 10000,
  			watch: false
  			// setView: false
  			// maxZoom: <Number>
  			// maximumAge: 0
  			// enableHighAccuracy: false
  		}, options);

  		if (!('geolocation' in navigator)) {
  			this._handleGeolocationError({
  				code: 0,
  				message: 'Geolocation not supported.'
  			});
  			return this;
  		}

  		var onResponse = bind(this._handleGeolocationResponse, this),
  		    onError = bind(this._handleGeolocationError, this);

  		if (options.watch) {
  			this._locationWatchId =
  			        navigator.geolocation.watchPosition(onResponse, onError, options);
  		} else {
  			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
  		}
  		return this;
  	},

  	// @method stopLocate(): this
  	// Stops watching location previously initiated by `map.locate({watch: true})`
  	// and aborts resetting the map view if map.locate was called with
  	// `{setView: true}`.
  	stopLocate: function () {
  		if (navigator.geolocation && navigator.geolocation.clearWatch) {
  			navigator.geolocation.clearWatch(this._locationWatchId);
  		}
  		if (this._locateOptions) {
  			this._locateOptions.setView = false;
  		}
  		return this;
  	},

  	_handleGeolocationError: function (error) {
  		if (!this._container._leaflet_id) { return; }

  		var c = error.code,
  		    message = error.message ||
  		            (c === 1 ? 'permission denied' :
  		            (c === 2 ? 'position unavailable' : 'timeout'));

  		if (this._locateOptions.setView && !this._loaded) {
  			this.fitWorld();
  		}

  		// @section Location events
  		// @event locationerror: ErrorEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
  		this.fire('locationerror', {
  			code: c,
  			message: 'Geolocation error: ' + message + '.'
  		});
  	},

  	_handleGeolocationResponse: function (pos) {
  		if (!this._container._leaflet_id) { return; }

  		var lat = pos.coords.latitude,
  		    lng = pos.coords.longitude,
  		    latlng = new LatLng(lat, lng),
  		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
  		    options = this._locateOptions;

  		if (options.setView) {
  			var zoom = this.getBoundsZoom(bounds);
  			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
  		}

  		var data = {
  			latlng: latlng,
  			bounds: bounds,
  			timestamp: pos.timestamp
  		};

  		for (var i in pos.coords) {
  			if (typeof pos.coords[i] === 'number') {
  				data[i] = pos.coords[i];
  			}
  		}

  		// @event locationfound: LocationEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method)
  		// went successfully.
  		this.fire('locationfound', data);
  	},

  	// TODO Appropriate docs section?
  	// @section Other Methods
  	// @method addHandler(name: String, HandlerClass: Function): this
  	// Adds a new `Handler` to the map, given its name and constructor function.
  	addHandler: function (name, HandlerClass) {
  		if (!HandlerClass) { return this; }

  		var handler = this[name] = new HandlerClass(this);

  		this._handlers.push(handler);

  		if (this.options[name]) {
  			handler.enable();
  		}

  		return this;
  	},

  	// @method remove(): this
  	// Destroys the map and clears all related event listeners.
  	remove: function () {

  		this._initEvents(true);
  		if (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }

  		if (this._containerId !== this._container._leaflet_id) {
  			throw new Error('Map container is being reused by another instance');
  		}

  		try {
  			// throws error in IE6-8
  			delete this._container._leaflet_id;
  			delete this._containerId;
  		} catch (e) {
  			/*eslint-disable */
  			this._container._leaflet_id = undefined;
  			/* eslint-enable */
  			this._containerId = undefined;
  		}

  		if (this._locationWatchId !== undefined) {
  			this.stopLocate();
  		}

  		this._stop();

  		remove(this._mapPane);

  		if (this._clearControlPos) {
  			this._clearControlPos();
  		}
  		if (this._resizeRequest) {
  			cancelAnimFrame(this._resizeRequest);
  			this._resizeRequest = null;
  		}

  		this._clearHandlers();

  		if (this._loaded) {
  			// @section Map state change events
  			// @event unload: Event
  			// Fired when the map is destroyed with [remove](#map-remove) method.
  			this.fire('unload');
  		}

  		var i;
  		for (i in this._layers) {
  			this._layers[i].remove();
  		}
  		for (i in this._panes) {
  			remove(this._panes[i]);
  		}

  		this._layers = [];
  		this._panes = [];
  		delete this._mapPane;
  		delete this._renderer;

  		return this;
  	},

  	// @section Other Methods
  	// @method createPane(name: String, container?: HTMLElement): HTMLElement
  	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
  	// then returns it. The pane is created as a child of `container`, or
  	// as a child of the main map pane if not set.
  	createPane: function (name, container) {
  		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
  		    pane = create$1('div', className, container || this._mapPane);

  		if (name) {
  			this._panes[name] = pane;
  		}
  		return pane;
  	},

  	// @section Methods for Getting Map State

  	// @method getCenter(): LatLng
  	// Returns the geographical center of the map view
  	getCenter: function () {
  		this._checkIfLoaded();

  		if (this._lastCenter && !this._moved()) {
  			return this._lastCenter;
  		}
  		return this.layerPointToLatLng(this._getCenterLayerPoint());
  	},

  	// @method getZoom(): Number
  	// Returns the current zoom level of the map view
  	getZoom: function () {
  		return this._zoom;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the geographical bounds visible in the current map view
  	getBounds: function () {
  		var bounds = this.getPixelBounds(),
  		    sw = this.unproject(bounds.getBottomLeft()),
  		    ne = this.unproject(bounds.getTopRight());

  		return new LatLngBounds(sw, ne);
  	},

  	// @method getMinZoom(): Number
  	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
  	getMinZoom: function () {
  		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
  	},

  	// @method getMaxZoom(): Number
  	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
  	getMaxZoom: function () {
  		return this.options.maxZoom === undefined ?
  			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
  			this.options.maxZoom;
  	},

  	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
  	// Returns the maximum zoom level on which the given bounds fit to the map
  	// view in its entirety. If `inside` (optional) is set to `true`, the method
  	// instead returns the minimum zoom level on which the map view fits into
  	// the given bounds in its entirety.
  	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
  		bounds = toLatLngBounds(bounds);
  		padding = toPoint(padding || [0, 0]);

  		var zoom = this.getZoom() || 0,
  		    min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    nw = bounds.getNorthWest(),
  		    se = bounds.getSouthEast(),
  		    size = this.getSize().subtract(padding),
  		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1,
  		    scalex = size.x / boundsSize.x,
  		    scaley = size.y / boundsSize.y,
  		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

  		zoom = this.getScaleZoom(scale, zoom);

  		if (snap) {
  			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
  			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
  		}

  		return Math.max(min, Math.min(max, zoom));
  	},

  	// @method getSize(): Point
  	// Returns the current size of the map container (in pixels).
  	getSize: function () {
  		if (!this._size || this._sizeChanged) {
  			this._size = new Point(
  				this._container.clientWidth || 0,
  				this._container.clientHeight || 0);

  			this._sizeChanged = false;
  		}
  		return this._size.clone();
  	},

  	// @method getPixelBounds(): Bounds
  	// Returns the bounds of the current map view in projected pixel
  	// coordinates (sometimes useful in layer and overlay implementations).
  	getPixelBounds: function (center, zoom) {
  		var topLeftPoint = this._getTopLeftPoint(center, zoom);
  		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  	},

  	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
  	// the map pane? "left point of the map layer" can be confusing, specially
  	// since there can be negative offsets.
  	// @method getPixelOrigin(): Point
  	// Returns the projected pixel coordinates of the top left point of
  	// the map layer (useful in custom layer and overlay implementations).
  	getPixelOrigin: function () {
  		this._checkIfLoaded();
  		return this._pixelOrigin;
  	},

  	// @method getPixelWorldBounds(zoom?: Number): Bounds
  	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
  	// If `zoom` is omitted, the map's current zoom level is used.
  	getPixelWorldBounds: function (zoom) {
  		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
  	},

  	// @section Other Methods

  	// @method getPane(pane: String|HTMLElement): HTMLElement
  	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
  	getPane: function (pane) {
  		return typeof pane === 'string' ? this._panes[pane] : pane;
  	},

  	// @method getPanes(): Object
  	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
  	// the panes as values.
  	getPanes: function () {
  		return this._panes;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the map.
  	getContainer: function () {
  		return this._container;
  	},


  	// @section Conversion Methods

  	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
  	// Returns the scale factor to be applied to a map transition from zoom level
  	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
  	getZoomScale: function (toZoom, fromZoom) {
  		// TODO replace with universal implementation after refactoring projections
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		return crs.scale(toZoom) / crs.scale(fromZoom);
  	},

  	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
  	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
  	// level and everything is scaled by a factor of `scale`. Inverse of
  	// [`getZoomScale`](#map-getZoomScale).
  	getScaleZoom: function (scale, fromZoom) {
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		var zoom = crs.zoom(scale * crs.scale(fromZoom));
  		return isNaN(zoom) ? Infinity : zoom;
  	},

  	// @method project(latlng: LatLng, zoom: Number): Point
  	// Projects a geographical coordinate `LatLng` according to the projection
  	// of the map's CRS, then scales it according to `zoom` and the CRS's
  	// `Transformation`. The result is pixel coordinate relative to
  	// the CRS origin.
  	project: function (latlng, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
  	},

  	// @method unproject(point: Point, zoom: Number): LatLng
  	// Inverse of [`project`](#map-project).
  	unproject: function (point, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.pointToLatLng(toPoint(point), zoom);
  	},

  	// @method layerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding geographical coordinate (for the current zoom level).
  	layerPointToLatLng: function (point) {
  		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
  		return this.unproject(projectedPoint);
  	},

  	// @method latLngToLayerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the [origin pixel](#map-getpixelorigin).
  	latLngToLayerPoint: function (latlng) {
  		var projectedPoint = this.project(toLatLng(latlng))._round();
  		return projectedPoint._subtract(this.getPixelOrigin());
  	},

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
  	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
  	// CRS's bounds.
  	// By default this means longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees.
  	wrapLatLng: function (latlng) {
  		return this.options.crs.wrapLatLng(toLatLng(latlng));
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
  	// its center is within the CRS's bounds.
  	// By default this means the center longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees, and the majority of the bounds
  	// overlaps the CRS's bounds.
  	wrapLatLngBounds: function (latlng) {
  		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates according to
  	// the map's CRS. By default this measures distance in meters.
  	distance: function (latlng1, latlng2) {
  		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  	},

  	// @method containerPointToLayerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the map container, returns the corresponding
  	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
  	containerPointToLayerPoint: function (point) { // (Point)
  		return toPoint(point).subtract(this._getMapPanePos());
  	},

  	// @method layerPointToContainerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding pixel coordinate relative to the map container.
  	layerPointToContainerPoint: function (point) { // (Point)
  		return toPoint(point).add(this._getMapPanePos());
  	},

  	// @method containerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the map container, returns
  	// the corresponding geographical coordinate (for the current zoom level).
  	containerPointToLatLng: function (point) {
  		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
  		return this.layerPointToLatLng(layerPoint);
  	},

  	// @method latLngToContainerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the map container.
  	latLngToContainerPoint: function (latlng) {
  		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  	},

  	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to the
  	// map container where the event took place.
  	mouseEventToContainerPoint: function (e) {
  		return getMousePosition(e, this._container);
  	},

  	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to
  	// the [origin pixel](#map-getpixelorigin) where the event took place.
  	mouseEventToLayerPoint: function (e) {
  		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  	},

  	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
  	// Given a MouseEvent object, returns geographical coordinate where the
  	// event took place.
  	mouseEventToLatLng: function (e) { // (MouseEvent)
  		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  	},


  	// map initialization methods

  	_initContainer: function (id) {
  		var container = this._container = get(id);

  		if (!container) {
  			throw new Error('Map container not found.');
  		} else if (container._leaflet_id) {
  			throw new Error('Map container is already initialized.');
  		}

  		on(container, 'scroll', this._onScroll, this);
  		this._containerId = stamp(container);
  	},

  	_initLayout: function () {
  		var container = this._container;

  		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

  		addClass(container, 'leaflet-container' +
  			(Browser.touch ? ' leaflet-touch' : '') +
  			(Browser.retina ? ' leaflet-retina' : '') +
  			(Browser.ielt9 ? ' leaflet-oldie' : '') +
  			(Browser.safari ? ' leaflet-safari' : '') +
  			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

  		var position = getStyle(container, 'position');

  		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
  			container.style.position = 'relative';
  		}

  		this._initPanes();

  		if (this._initControlPos) {
  			this._initControlPos();
  		}
  	},

  	_initPanes: function () {
  		var panes = this._panes = {};
  		this._paneRenderers = {};

  		// @section
  		//
  		// Panes are DOM elements used to control the ordering of layers on the map. You
  		// can access panes with [`map.getPane`](#map-getpane) or
  		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
  		// [`map.createPane`](#map-createpane) method.
  		//
  		// Every map has the following default panes that differ only in zIndex.
  		//
  		// @pane mapPane: HTMLElement = 'auto'
  		// Pane that contains all other map panes

  		this._mapPane = this.createPane('mapPane', this._container);
  		setPosition(this._mapPane, new Point(0, 0));

  		// @pane tilePane: HTMLElement = 200
  		// Pane for `GridLayer`s and `TileLayer`s
  		this.createPane('tilePane');
  		// @pane overlayPane: HTMLElement = 400
  		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
  		this.createPane('overlayPane');
  		// @pane shadowPane: HTMLElement = 500
  		// Pane for overlay shadows (e.g. `Marker` shadows)
  		this.createPane('shadowPane');
  		// @pane markerPane: HTMLElement = 600
  		// Pane for `Icon`s of `Marker`s
  		this.createPane('markerPane');
  		// @pane tooltipPane: HTMLElement = 650
  		// Pane for `Tooltip`s.
  		this.createPane('tooltipPane');
  		// @pane popupPane: HTMLElement = 700
  		// Pane for `Popup`s.
  		this.createPane('popupPane');

  		if (!this.options.markerZoomAnimation) {
  			addClass(panes.markerPane, 'leaflet-zoom-hide');
  			addClass(panes.shadowPane, 'leaflet-zoom-hide');
  		}
  	},


  	// private methods that modify map state

  	// @section Map state change events
  	_resetView: function (center, zoom) {
  		setPosition(this._mapPane, new Point(0, 0));

  		var loading = !this._loaded;
  		this._loaded = true;
  		zoom = this._limitZoom(zoom);

  		this.fire('viewprereset');

  		var zoomChanged = this._zoom !== zoom;
  		this
  			._moveStart(zoomChanged, false)
  			._move(center, zoom)
  			._moveEnd(zoomChanged);

  		// @event viewreset: Event
  		// Fired when the map needs to redraw its content (this usually happens
  		// on map zoom or load). Very useful for creating custom overlays.
  		this.fire('viewreset');

  		// @event load: Event
  		// Fired when the map is initialized (when its center and zoom are set
  		// for the first time).
  		if (loading) {
  			this.fire('load');
  		}
  	},

  	_moveStart: function (zoomChanged, noMoveStart) {
  		// @event zoomstart: Event
  		// Fired when the map zoom is about to change (e.g. before zoom animation).
  		// @event movestart: Event
  		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
  		if (zoomChanged) {
  			this.fire('zoomstart');
  		}
  		if (!noMoveStart) {
  			this.fire('movestart');
  		}
  		return this;
  	},

  	_move: function (center, zoom, data, supressEvent) {
  		if (zoom === undefined) {
  			zoom = this._zoom;
  		}
  		var zoomChanged = this._zoom !== zoom;

  		this._zoom = zoom;
  		this._lastCenter = center;
  		this._pixelOrigin = this._getNewPixelOrigin(center);

  		if (!supressEvent) {
  			// @event zoom: Event
  			// Fired repeatedly during any change in zoom level,
  			// including zoom and fly animations.
  			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
  				this.fire('zoom', data);
  			}

  			// @event move: Event
  			// Fired repeatedly during any movement of the map,
  			// including pan and fly animations.
  			this.fire('move', data);
  		} else if (data && data.pinch) {	// Always fire 'zoom' if pinching because #3530
  			this.fire('zoom', data);
  		}
  		return this;
  	},

  	_moveEnd: function (zoomChanged) {
  		// @event zoomend: Event
  		// Fired when the map zoom changed, after any animations.
  		if (zoomChanged) {
  			this.fire('zoomend');
  		}

  		// @event moveend: Event
  		// Fired when the center of the map stops changing
  		// (e.g. user stopped dragging the map or after non-centered zoom).
  		return this.fire('moveend');
  	},

  	_stop: function () {
  		cancelAnimFrame(this._flyToFrame);
  		if (this._panAnim) {
  			this._panAnim.stop();
  		}
  		return this;
  	},

  	_rawPanBy: function (offset) {
  		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  	},

  	_getZoomSpan: function () {
  		return this.getMaxZoom() - this.getMinZoom();
  	},

  	_panInsideMaxBounds: function () {
  		if (!this._enforcingBounds) {
  			this.panInsideBounds(this.options.maxBounds);
  		}
  	},

  	_checkIfLoaded: function () {
  		if (!this._loaded) {
  			throw new Error('Set map center and zoom first.');
  		}
  	},

  	// DOM event handling

  	// @section Interaction events
  	_initEvents: function (remove) {
  		this._targets = {};
  		this._targets[stamp(this._container)] = this;

  		var onOff = remove ? off : on;

  		// @event click: MouseEvent
  		// Fired when the user clicks (or taps) the map.
  		// @event dblclick: MouseEvent
  		// Fired when the user double-clicks (or double-taps) the map.
  		// @event mousedown: MouseEvent
  		// Fired when the user pushes the mouse button on the map.
  		// @event mouseup: MouseEvent
  		// Fired when the user releases the mouse button on the map.
  		// @event mouseover: MouseEvent
  		// Fired when the mouse enters the map.
  		// @event mouseout: MouseEvent
  		// Fired when the mouse leaves the map.
  		// @event mousemove: MouseEvent
  		// Fired while the mouse moves over the map.
  		// @event contextmenu: MouseEvent
  		// Fired when the user pushes the right mouse button on the map, prevents
  		// default browser context menu from showing if there are listeners on
  		// this event. Also fired on mobile when the user holds a single touch
  		// for a second (also called long press).
  		// @event keypress: KeyboardEvent
  		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
  		// @event keydown: KeyboardEvent
  		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
  		// the `keydown` event is fired for keys that produce a character value and for keys
  		// that do not produce a character value.
  		// @event keyup: KeyboardEvent
  		// Fired when the user releases a key from the keyboard while the map is focused.
  		onOff(this._container, 'click dblclick mousedown mouseup ' +
  			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

  		if (this.options.trackResize) {
  			onOff(window, 'resize', this._onResize, this);
  		}

  		if (Browser.any3d && this.options.transform3DLimit) {
  			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
  		}
  	},

  	_onResize: function () {
  		cancelAnimFrame(this._resizeRequest);
  		this._resizeRequest = requestAnimFrame(
  		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
  	},

  	_onScroll: function () {
  		this._container.scrollTop  = 0;
  		this._container.scrollLeft = 0;
  	},

  	_onMoveEnd: function () {
  		var pos = this._getMapPanePos();
  		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
  			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
  			// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
  			this._resetView(this.getCenter(), this.getZoom());
  		}
  	},

  	_findEventTargets: function (e, type) {
  		var targets = [],
  		    target,
  		    isHover = type === 'mouseout' || type === 'mouseover',
  		    src = e.target || e.srcElement,
  		    dragging = false;

  		while (src) {
  			target = this._targets[stamp(src)];
  			if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {
  				// Prevent firing click after you just dragged an object.
  				dragging = true;
  				break;
  			}
  			if (target && target.listens(type, true)) {
  				if (isHover && !isExternalTarget(src, e)) { break; }
  				targets.push(target);
  				if (isHover) { break; }
  			}
  			if (src === this._container) { break; }
  			src = src.parentNode;
  		}
  		if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
  			targets = [this];
  		}
  		return targets;
  	},

  	_isClickDisabled: function (el) {
  		while (el !== this._container) {
  			if (el['_leaflet_disable_click']) { return true; }
  			el = el.parentNode;
  		}
  	},

  	_handleDOMEvent: function (e) {
  		var el = (e.target || e.srcElement);
  		if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {
  			return;
  		}

  		var type = e.type;

  		if (type === 'mousedown') {
  			// prevents outline when clicking on keyboard-focusable element
  			preventOutline(el);
  		}

  		this._fireDOMEvent(e, type);
  	},

  	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

  	_fireDOMEvent: function (e, type, canvasTargets) {

  		if (e.type === 'click') {
  			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
  			// @event preclick: MouseEvent
  			// Fired before mouse click on the map (sometimes useful when you
  			// want something to happen on click before any existing click
  			// handlers start running).
  			var synth = extend({}, e);
  			synth.type = 'preclick';
  			this._fireDOMEvent(synth, synth.type, canvasTargets);
  		}

  		// Find the layer the event is propagating from and its parents.
  		var targets = this._findEventTargets(e, type);

  		if (canvasTargets) {
  			var filtered = []; // pick only targets with listeners
  			for (var i = 0; i < canvasTargets.length; i++) {
  				if (canvasTargets[i].listens(type, true)) {
  					filtered.push(canvasTargets[i]);
  				}
  			}
  			targets = filtered.concat(targets);
  		}

  		if (!targets.length) { return; }

  		if (type === 'contextmenu') {
  			preventDefault(e);
  		}

  		var target = targets[0];
  		var data = {
  			originalEvent: e
  		};

  		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
  			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
  			data.containerPoint = isMarker ?
  				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
  			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
  			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
  		}

  		for (i = 0; i < targets.length; i++) {
  			targets[i].fire(type, data, true);
  			if (data.originalEvent._stopped ||
  				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
  		}
  	},

  	_draggableMoved: function (obj) {
  		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
  		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
  	},

  	_clearHandlers: function () {
  		for (var i = 0, len = this._handlers.length; i < len; i++) {
  			this._handlers[i].disable();
  		}
  	},

  	// @section Other Methods

  	// @method whenReady(fn: Function, context?: Object): this
  	// Runs the given function `fn` when the map gets initialized with
  	// a view (center and zoom) and at least one layer, or immediately
  	// if it's already initialized, optionally passing a function context.
  	whenReady: function (callback, context) {
  		if (this._loaded) {
  			callback.call(context || this, {target: this});
  		} else {
  			this.on('load', callback, context);
  		}
  		return this;
  	},


  	// private methods for getting map state

  	_getMapPanePos: function () {
  		return getPosition(this._mapPane) || new Point(0, 0);
  	},

  	_moved: function () {
  		var pos = this._getMapPanePos();
  		return pos && !pos.equals([0, 0]);
  	},

  	_getTopLeftPoint: function (center, zoom) {
  		var pixelOrigin = center && zoom !== undefined ?
  			this._getNewPixelOrigin(center, zoom) :
  			this.getPixelOrigin();
  		return pixelOrigin.subtract(this._getMapPanePos());
  	},

  	_getNewPixelOrigin: function (center, zoom) {
  		var viewHalf = this.getSize()._divideBy(2);
  		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  	},

  	_latLngToNewLayerPoint: function (latlng, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return this.project(latlng, zoom)._subtract(topLeft);
  	},

  	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return toBounds([
  			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
  		]);
  	},

  	// layer point of the current center
  	_getCenterLayerPoint: function () {
  		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  	},

  	// offset of the specified place to the current center in pixels
  	_getCenterOffset: function (latlng) {
  		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  	},

  	// adjust center for view to get inside bounds
  	_limitCenter: function (center, zoom, bounds) {

  		if (!bounds) { return center; }

  		var centerPoint = this.project(center, zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
  		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

  		// If offset is less than a pixel, ignore.
  		// This prevents unstable projections from getting into
  		// an infinite loop of tiny offsets.
  		if (offset.round().equals([0, 0])) {
  			return center;
  		}

  		return this.unproject(centerPoint.add(offset), zoom);
  	},

  	// adjust offset for view to get inside bounds
  	_limitOffset: function (offset, bounds) {
  		if (!bounds) { return offset; }

  		var viewBounds = this.getPixelBounds(),
  		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

  		return offset.add(this._getBoundsOffset(newBounds, bounds));
  	},

  	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
  	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
  		var projectedMaxBounds = toBounds(
  		        this.project(maxBounds.getNorthEast(), zoom),
  		        this.project(maxBounds.getSouthWest(), zoom)
  		    ),
  		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
  		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

  		    dx = this._rebound(minOffset.x, -maxOffset.x),
  		    dy = this._rebound(minOffset.y, -maxOffset.y);

  		return new Point(dx, dy);
  	},

  	_rebound: function (left, right) {
  		return left + right > 0 ?
  			Math.round(left - right) / 2 :
  			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  	},

  	_limitZoom: function (zoom) {
  		var min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1;
  		if (snap) {
  			zoom = Math.round(zoom / snap) * snap;
  		}
  		return Math.max(min, Math.min(max, zoom));
  	},

  	_onPanTransitionStep: function () {
  		this.fire('move');
  	},

  	_onPanTransitionEnd: function () {
  		removeClass(this._mapPane, 'leaflet-pan-anim');
  		this.fire('moveend');
  	},

  	_tryAnimatedPan: function (center, options) {
  		// difference between the new and current centers in pixels
  		var offset = this._getCenterOffset(center)._trunc();

  		// don't animate too far unless animate: true specified in options
  		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

  		this.panBy(offset, options);

  		return true;
  	},

  	_createAnimProxy: function () {

  		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
  		this._panes.mapPane.appendChild(proxy);

  		this.on('zoomanim', function (e) {
  			var prop = TRANSFORM,
  			    transform = this._proxy.style[prop];

  			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

  			// workaround for case when transform is the same and so transitionend event is not fired
  			if (transform === this._proxy.style[prop] && this._animatingZoom) {
  				this._onZoomTransitionEnd();
  			}
  		}, this);

  		this.on('load moveend', this._animMoveEnd, this);

  		this._on('unload', this._destroyAnimProxy, this);
  	},

  	_destroyAnimProxy: function () {
  		remove(this._proxy);
  		this.off('load moveend', this._animMoveEnd, this);
  		delete this._proxy;
  	},

  	_animMoveEnd: function () {
  		var c = this.getCenter(),
  		    z = this.getZoom();
  		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  	},

  	_catchTransitionEnd: function (e) {
  		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
  			this._onZoomTransitionEnd();
  		}
  	},

  	_nothingToAnimate: function () {
  		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
  	},

  	_tryAnimatedZoom: function (center, zoom, options) {

  		if (this._animatingZoom) { return true; }

  		options = options || {};

  		// don't animate if disabled, not supported or zoom difference is too large
  		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
  		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

  		// offset is the pixel coords of the zoom origin relative to the current center
  		var scale = this.getZoomScale(zoom),
  		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

  		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
  		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

  		requestAnimFrame(function () {
  			this
  			    ._moveStart(true, false)
  			    ._animateZoom(center, zoom, true);
  		}, this);

  		return true;
  	},

  	_animateZoom: function (center, zoom, startAnim, noUpdate) {
  		if (!this._mapPane) { return; }

  		if (startAnim) {
  			this._animatingZoom = true;

  			// remember what center/zoom to set after animation
  			this._animateToCenter = center;
  			this._animateToZoom = zoom;

  			addClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		// @section Other Events
  		// @event zoomanim: ZoomAnimEvent
  		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
  		this.fire('zoomanim', {
  			center: center,
  			zoom: zoom,
  			noUpdate: noUpdate
  		});

  		if (!this._tempFireZoomEvent) {
  			this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
  		}

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
  		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
  	},

  	_onZoomTransitionEnd: function () {
  		if (!this._animatingZoom) { return; }

  		if (this._mapPane) {
  			removeClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		this._animatingZoom = false;

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		if (this._tempFireZoomEvent) {
  			this.fire('zoom');
  		}
  		delete this._tempFireZoomEvent;

  		this.fire('move');

  		this._moveEnd(true);
  	}
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
  	return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
  	// @section
  	// @aka Control Options
  	options: {
  		// @option position: String = 'topright'
  		// The position of the control (one of the map corners). Possible values are `'topleft'`,
  		// `'topright'`, `'bottomleft'` or `'bottomright'`
  		position: 'topright'
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	/* @section
  	 * Classes extending L.Control will inherit the following methods:
  	 *
  	 * @method getPosition: string
  	 * Returns the position of the control.
  	 */
  	getPosition: function () {
  		return this.options.position;
  	},

  	// @method setPosition(position: string): this
  	// Sets the position of the control.
  	setPosition: function (position) {
  		var map = this._map;

  		if (map) {
  			map.removeControl(this);
  		}

  		this.options.position = position;

  		if (map) {
  			map.addControl(this);
  		}

  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTMLElement that contains the control.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method addTo(map: Map): this
  	// Adds the control to the given map.
  	addTo: function (map) {
  		this.remove();
  		this._map = map;

  		var container = this._container = this.onAdd(map),
  		    pos = this.getPosition(),
  		    corner = map._controlCorners[pos];

  		addClass(container, 'leaflet-control');

  		if (pos.indexOf('bottom') !== -1) {
  			corner.insertBefore(container, corner.firstChild);
  		} else {
  			corner.appendChild(container);
  		}

  		this._map.on('unload', this.remove, this);

  		return this;
  	},

  	// @method remove: this
  	// Removes the control from the map it is currently active on.
  	remove: function () {
  		if (!this._map) {
  			return this;
  		}

  		remove(this._container);

  		if (this.onRemove) {
  			this.onRemove(this._map);
  		}

  		this._map.off('unload', this.remove, this);
  		this._map = null;

  		return this;
  	},

  	_refocusOnMap: function (e) {
  		// if map exists and event is not a keyboard event
  		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
  			this._map.getContainer().focus();
  		}
  	}
  });

  var control = function (options) {
  	return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addControl(control: Control): this
  	// Adds the given control to the map
  	addControl: function (control) {
  		control.addTo(this);
  		return this;
  	},

  	// @method removeControl(control: Control): this
  	// Removes the given control from the map
  	removeControl: function (control) {
  		control.remove();
  		return this;
  	},

  	_initControlPos: function () {
  		var corners = this._controlCorners = {},
  		    l = 'leaflet-',
  		    container = this._controlContainer =
  		            create$1('div', l + 'control-container', this._container);

  		function createCorner(vSide, hSide) {
  			var className = l + vSide + ' ' + l + hSide;

  			corners[vSide + hSide] = create$1('div', className, container);
  		}

  		createCorner('top', 'left');
  		createCorner('top', 'right');
  		createCorner('bottom', 'left');
  		createCorner('bottom', 'right');
  	},

  	_clearControlPos: function () {
  		for (var i in this._controlCorners) {
  			remove(this._controlCorners[i]);
  		}
  		remove(this._controlContainer);
  		delete this._controlCorners;
  		delete this._controlContainer;
  	}
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
  	// @section
  	// @aka Control.Layers options
  	options: {
  		// @option collapsed: Boolean = true
  		// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
  		collapsed: true,
  		position: 'topright',

  		// @option autoZIndex: Boolean = true
  		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
  		autoZIndex: true,

  		// @option hideSingleBase: Boolean = false
  		// If `true`, the base layers in the control will be hidden when there is only one.
  		hideSingleBase: false,

  		// @option sortLayers: Boolean = false
  		// Whether to sort the layers. When `false`, layers will keep the order
  		// in which they were added to the control.
  		sortLayers: false,

  		// @option sortFunction: Function = *
  		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
  		// that will be used for sorting the layers, when `sortLayers` is `true`.
  		// The function receives both the `L.Layer` instances and their names, as in
  		// `sortFunction(layerA, layerB, nameA, nameB)`.
  		// By default, it sorts layers alphabetically by their name.
  		sortFunction: function (layerA, layerB, nameA, nameB) {
  			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
  		}
  	},

  	initialize: function (baseLayers, overlays, options) {
  		setOptions(this, options);

  		this._layerControlInputs = [];
  		this._layers = [];
  		this._lastZIndex = 0;
  		this._handlingClick = false;

  		for (var i in baseLayers) {
  			this._addLayer(baseLayers[i], i);
  		}

  		for (i in overlays) {
  			this._addLayer(overlays[i], i, true);
  		}
  	},

  	onAdd: function (map) {
  		this._initLayout();
  		this._update();

  		this._map = map;
  		map.on('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.on('add remove', this._onLayerChange, this);
  		}

  		return this._container;
  	},

  	addTo: function (map) {
  		Control.prototype.addTo.call(this, map);
  		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
  		return this._expandIfNotCollapsed();
  	},

  	onRemove: function () {
  		this._map.off('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.off('add remove', this._onLayerChange, this);
  		}
  	},

  	// @method addBaseLayer(layer: Layer, name: String): this
  	// Adds a base layer (radio button entry) with the given name to the control.
  	addBaseLayer: function (layer, name) {
  		this._addLayer(layer, name);
  		return (this._map) ? this._update() : this;
  	},

  	// @method addOverlay(layer: Layer, name: String): this
  	// Adds an overlay (checkbox entry) with the given name to the control.
  	addOverlay: function (layer, name) {
  		this._addLayer(layer, name, true);
  		return (this._map) ? this._update() : this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Remove the given layer from the control.
  	removeLayer: function (layer) {
  		layer.off('add remove', this._onLayerChange, this);

  		var obj = this._getLayer(stamp(layer));
  		if (obj) {
  			this._layers.splice(this._layers.indexOf(obj), 1);
  		}
  		return (this._map) ? this._update() : this;
  	},

  	// @method expand(): this
  	// Expand the control container if collapsed.
  	expand: function () {
  		addClass(this._container, 'leaflet-control-layers-expanded');
  		this._section.style.height = null;
  		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
  		if (acceptableHeight < this._section.clientHeight) {
  			addClass(this._section, 'leaflet-control-layers-scrollbar');
  			this._section.style.height = acceptableHeight + 'px';
  		} else {
  			removeClass(this._section, 'leaflet-control-layers-scrollbar');
  		}
  		this._checkDisabledLayers();
  		return this;
  	},

  	// @method collapse(): this
  	// Collapse the control container if expanded.
  	collapse: function () {
  		removeClass(this._container, 'leaflet-control-layers-expanded');
  		return this;
  	},

  	_initLayout: function () {
  		var className = 'leaflet-control-layers',
  		    container = this._container = create$1('div', className),
  		    collapsed = this.options.collapsed;

  		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
  		container.setAttribute('aria-haspopup', true);

  		disableClickPropagation(container);
  		disableScrollPropagation(container);

  		var section = this._section = create$1('section', className + '-list');

  		if (collapsed) {
  			this._map.on('click', this.collapse, this);

  			on(container, {
  				mouseenter: function () {
  					on(section, 'click', preventDefault);
  					this.expand();
  					setTimeout(function () {
  						off(section, 'click', preventDefault);
  					});
  				},
  				mouseleave: this.collapse
  			}, this);
  		}

  		var link = this._layersLink = create$1('a', className + '-toggle', container);
  		link.href = '#';
  		link.title = 'Layers';
  		link.setAttribute('role', 'button');

  		on(link, 'click', preventDefault); // prevent link function
  		on(link, 'focus', this.expand, this);

  		if (!collapsed) {
  			this.expand();
  		}

  		this._baseLayersList = create$1('div', className + '-base', section);
  		this._separator = create$1('div', className + '-separator', section);
  		this._overlaysList = create$1('div', className + '-overlays', section);

  		container.appendChild(section);
  	},

  	_getLayer: function (id) {
  		for (var i = 0; i < this._layers.length; i++) {

  			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
  				return this._layers[i];
  			}
  		}
  	},

  	_addLayer: function (layer, name, overlay) {
  		if (this._map) {
  			layer.on('add remove', this._onLayerChange, this);
  		}

  		this._layers.push({
  			layer: layer,
  			name: name,
  			overlay: overlay
  		});

  		if (this.options.sortLayers) {
  			this._layers.sort(bind(function (a, b) {
  				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
  			}, this));
  		}

  		if (this.options.autoZIndex && layer.setZIndex) {
  			this._lastZIndex++;
  			layer.setZIndex(this._lastZIndex);
  		}

  		this._expandIfNotCollapsed();
  	},

  	_update: function () {
  		if (!this._container) { return this; }

  		empty(this._baseLayersList);
  		empty(this._overlaysList);

  		this._layerControlInputs = [];
  		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

  		for (i = 0; i < this._layers.length; i++) {
  			obj = this._layers[i];
  			this._addItem(obj);
  			overlaysPresent = overlaysPresent || obj.overlay;
  			baseLayersPresent = baseLayersPresent || !obj.overlay;
  			baseLayersCount += !obj.overlay ? 1 : 0;
  		}

  		// Hide base layers section if there's only one layer.
  		if (this.options.hideSingleBase) {
  			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
  			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
  		}

  		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

  		return this;
  	},

  	_onLayerChange: function (e) {
  		if (!this._handlingClick) {
  			this._update();
  		}

  		var obj = this._getLayer(stamp(e.target));

  		// @namespace Map
  		// @section Layer events
  		// @event baselayerchange: LayersControlEvent
  		// Fired when the base layer is changed through the [layers control](#control-layers).
  		// @event overlayadd: LayersControlEvent
  		// Fired when an overlay is selected through the [layers control](#control-layers).
  		// @event overlayremove: LayersControlEvent
  		// Fired when an overlay is deselected through the [layers control](#control-layers).
  		// @namespace Control.Layers
  		var type = obj.overlay ?
  			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
  			(e.type === 'add' ? 'baselayerchange' : null);

  		if (type) {
  			this._map.fire(type, obj);
  		}
  	},

  	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
  	_createRadioElement: function (name, checked) {

  		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
  				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

  		var radioFragment = document.createElement('div');
  		radioFragment.innerHTML = radioHtml;

  		return radioFragment.firstChild;
  	},

  	_addItem: function (obj) {
  		var label = document.createElement('label'),
  		    checked = this._map.hasLayer(obj.layer),
  		    input;

  		if (obj.overlay) {
  			input = document.createElement('input');
  			input.type = 'checkbox';
  			input.className = 'leaflet-control-layers-selector';
  			input.defaultChecked = checked;
  		} else {
  			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
  		}

  		this._layerControlInputs.push(input);
  		input.layerId = stamp(obj.layer);

  		on(input, 'click', this._onInputClick, this);

  		var name = document.createElement('span');
  		name.innerHTML = ' ' + obj.name;

  		// Helps from preventing layer control flicker when checkboxes are disabled
  		// https://github.com/Leaflet/Leaflet/issues/2771
  		var holder = document.createElement('span');

  		label.appendChild(holder);
  		holder.appendChild(input);
  		holder.appendChild(name);

  		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
  		container.appendChild(label);

  		this._checkDisabledLayers();
  		return label;
  	},

  	_onInputClick: function () {
  		var inputs = this._layerControlInputs,
  		    input, layer;
  		var addedLayers = [],
  		    removedLayers = [];

  		this._handlingClick = true;

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;

  			if (input.checked) {
  				addedLayers.push(layer);
  			} else if (!input.checked) {
  				removedLayers.push(layer);
  			}
  		}

  		// Bugfix issue 2318: Should remove all old layers before readding new ones
  		for (i = 0; i < removedLayers.length; i++) {
  			if (this._map.hasLayer(removedLayers[i])) {
  				this._map.removeLayer(removedLayers[i]);
  			}
  		}
  		for (i = 0; i < addedLayers.length; i++) {
  			if (!this._map.hasLayer(addedLayers[i])) {
  				this._map.addLayer(addedLayers[i]);
  			}
  		}

  		this._handlingClick = false;

  		this._refocusOnMap();
  	},

  	_checkDisabledLayers: function () {
  		var inputs = this._layerControlInputs,
  		    input,
  		    layer,
  		    zoom = this._map.getZoom();

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;
  			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
  			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

  		}
  	},

  	_expandIfNotCollapsed: function () {
  		if (this._map && !this.options.collapsed) {
  			this.expand();
  		}
  		return this;
  	}

  });


  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
  	return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
  	// @section
  	// @aka Control.Zoom options
  	options: {
  		position: 'topleft',

  		// @option zoomInText: String = '<span aria-hidden="true">+</span>'
  		// The text set on the 'zoom in' button.
  		zoomInText: '<span aria-hidden="true">+</span>',

  		// @option zoomInTitle: String = 'Zoom in'
  		// The title set on the 'zoom in' button.
  		zoomInTitle: 'Zoom in',

  		// @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
  		// The text set on the 'zoom out' button.
  		zoomOutText: '<span aria-hidden="true">&#x2212;</span>',

  		// @option zoomOutTitle: String = 'Zoom out'
  		// The title set on the 'zoom out' button.
  		zoomOutTitle: 'Zoom out'
  	},

  	onAdd: function (map) {
  		var zoomName = 'leaflet-control-zoom',
  		    container = create$1('div', zoomName + ' leaflet-bar'),
  		    options = this.options;

  		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
  		        zoomName + '-in',  container, this._zoomIn);
  		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
  		        zoomName + '-out', container, this._zoomOut);

  		this._updateDisabled();
  		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
  	},

  	disable: function () {
  		this._disabled = true;
  		this._updateDisabled();
  		return this;
  	},

  	enable: function () {
  		this._disabled = false;
  		this._updateDisabled();
  		return this;
  	},

  	_zoomIn: function (e) {
  		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
  			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_zoomOut: function (e) {
  		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
  			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_createButton: function (html, title, className, container, fn) {
  		var link = create$1('a', className, container);
  		link.innerHTML = html;
  		link.href = '#';
  		link.title = title;

  		/*
  		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
  		 */
  		link.setAttribute('role', 'button');
  		link.setAttribute('aria-label', title);

  		disableClickPropagation(link);
  		on(link, 'click', stop);
  		on(link, 'click', fn, this);
  		on(link, 'click', this._refocusOnMap, this);

  		return link;
  	},

  	_updateDisabled: function () {
  		var map = this._map,
  		    className = 'leaflet-disabled';

  		removeClass(this._zoomInButton, className);
  		removeClass(this._zoomOutButton, className);
  		this._zoomInButton.setAttribute('aria-disabled', 'false');
  		this._zoomOutButton.setAttribute('aria-disabled', 'false');

  		if (this._disabled || map._zoom === map.getMinZoom()) {
  			addClass(this._zoomOutButton, className);
  			this._zoomOutButton.setAttribute('aria-disabled', 'true');
  		}
  		if (this._disabled || map._zoom === map.getMaxZoom()) {
  			addClass(this._zoomInButton, className);
  			this._zoomInButton.setAttribute('aria-disabled', 'true');
  		}
  	}
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
  	zoomControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.zoomControl) {
  		// @section Controls
  		// @property zoomControl: Control.Zoom
  		// The default zoom control (only available if the
  		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
  		this.zoomControl = new Zoom();
  		this.addControl(this.zoomControl);
  	}
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
  	return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
  	// @section
  	// @aka Control.Scale options
  	options: {
  		position: 'bottomleft',

  		// @option maxWidth: Number = 100
  		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
  		maxWidth: 100,

  		// @option metric: Boolean = True
  		// Whether to show the metric scale line (m/km).
  		metric: true,

  		// @option imperial: Boolean = True
  		// Whether to show the imperial scale line (mi/ft).
  		imperial: true

  		// @option updateWhenIdle: Boolean = false
  		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
  	},

  	onAdd: function (map) {
  		var className = 'leaflet-control-scale',
  		    container = create$1('div', className),
  		    options = this.options;

  		this._addScales(options, className + '-line', container);

  		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  		map.whenReady(this._update, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  	},

  	_addScales: function (options, className, container) {
  		if (options.metric) {
  			this._mScale = create$1('div', className, container);
  		}
  		if (options.imperial) {
  			this._iScale = create$1('div', className, container);
  		}
  	},

  	_update: function () {
  		var map = this._map,
  		    y = map.getSize().y / 2;

  		var maxMeters = map.distance(
  			map.containerPointToLatLng([0, y]),
  			map.containerPointToLatLng([this.options.maxWidth, y]));

  		this._updateScales(maxMeters);
  	},

  	_updateScales: function (maxMeters) {
  		if (this.options.metric && maxMeters) {
  			this._updateMetric(maxMeters);
  		}
  		if (this.options.imperial && maxMeters) {
  			this._updateImperial(maxMeters);
  		}
  	},

  	_updateMetric: function (maxMeters) {
  		var meters = this._getRoundNum(maxMeters),
  		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

  		this._updateScale(this._mScale, label, meters / maxMeters);
  	},

  	_updateImperial: function (maxMeters) {
  		var maxFeet = maxMeters * 3.2808399,
  		    maxMiles, miles, feet;

  		if (maxFeet > 5280) {
  			maxMiles = maxFeet / 5280;
  			miles = this._getRoundNum(maxMiles);
  			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

  		} else {
  			feet = this._getRoundNum(maxFeet);
  			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
  		}
  	},

  	_updateScale: function (scale, text, ratio) {
  		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
  		scale.innerHTML = text;
  	},

  	_getRoundNum: function (num) {
  		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
  		    d = num / pow10;

  		d = d >= 10 ? 10 :
  		    d >= 5 ? 5 :
  		    d >= 3 ? 3 :
  		    d >= 2 ? 2 : 1;

  		return pow10 * d;
  	}
  });


  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
  	return new Scale(options);
  };

  var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';


  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
  	// @section
  	// @aka Control.Attribution options
  	options: {
  		position: 'bottomright',

  		// @option prefix: String|false = 'Leaflet'
  		// The HTML text shown before the attributions. Pass `false` to disable.
  		prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'
  	},

  	initialize: function (options) {
  		setOptions(this, options);

  		this._attributions = {};
  	},

  	onAdd: function (map) {
  		map.attributionControl = this;
  		this._container = create$1('div', 'leaflet-control-attribution');
  		disableClickPropagation(this._container);

  		// TODO ugly, refactor
  		for (var i in map._layers) {
  			if (map._layers[i].getAttribution) {
  				this.addAttribution(map._layers[i].getAttribution());
  			}
  		}

  		this._update();

  		map.on('layeradd', this._addAttribution, this);

  		return this._container;
  	},

  	onRemove: function (map) {
  		map.off('layeradd', this._addAttribution, this);
  	},

  	_addAttribution: function (ev) {
  		if (ev.layer.getAttribution) {
  			this.addAttribution(ev.layer.getAttribution());
  			ev.layer.once('remove', function () {
  				this.removeAttribution(ev.layer.getAttribution());
  			}, this);
  		}
  	},

  	// @method setPrefix(prefix: String|false): this
  	// The HTML text shown before the attributions. Pass `false` to disable.
  	setPrefix: function (prefix) {
  		this.options.prefix = prefix;
  		this._update();
  		return this;
  	},

  	// @method addAttribution(text: String): this
  	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
  	addAttribution: function (text) {
  		if (!text) { return this; }

  		if (!this._attributions[text]) {
  			this._attributions[text] = 0;
  		}
  		this._attributions[text]++;

  		this._update();

  		return this;
  	},

  	// @method removeAttribution(text: String): this
  	// Removes an attribution text.
  	removeAttribution: function (text) {
  		if (!text) { return this; }

  		if (this._attributions[text]) {
  			this._attributions[text]--;
  			this._update();
  		}

  		return this;
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		var attribs = [];

  		for (var i in this._attributions) {
  			if (this._attributions[i]) {
  				attribs.push(i);
  			}
  		}

  		var prefixAndAttribs = [];

  		if (this.options.prefix) {
  			prefixAndAttribs.push(this.options.prefix);
  		}
  		if (attribs.length) {
  			prefixAndAttribs.push(attribs.join(', '));
  		}

  		this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
  	}
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
  	attributionControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.attributionControl) {
  		new Attribution().addTo(this);
  	}
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
  	return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;

  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
  	initialize: function (map) {
  		this._map = map;
  	},

  	// @method enable(): this
  	// Enables the handler
  	enable: function () {
  		if (this._enabled) { return this; }

  		this._enabled = true;
  		this.addHooks();
  		return this;
  	},

  	// @method disable(): this
  	// Disables the handler
  	disable: function () {
  		if (!this._enabled) { return this; }

  		this._enabled = false;
  		this.removeHooks();
  		return this;
  	},

  	// @method enabled(): Boolean
  	// Returns `true` if the handler is enabled
  	enabled: function () {
  		return !!this._enabled;
  	}

  	// @section Extension methods
  	// Classes inheriting from `Handler` must implement the two following methods:
  	// @method addHooks()
  	// Called when the handler is enabled, should add event hooks.
  	// @method removeHooks()
  	// Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
  	map.addHandler(name, this);
  	return this;
  };

  var Mixin = {Events: Events};

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';

  var Draggable = Evented.extend({

  	options: {
  		// @section
  		// @aka Draggable options
  		// @option clickTolerance: Number = 3
  		// The max number of pixels a user can shift the mouse pointer during a click
  		// for it to be considered a valid click (as opposed to a mouse drag).
  		clickTolerance: 3
  	},

  	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
  	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
  	initialize: function (element, dragStartTarget, preventOutline, options) {
  		setOptions(this, options);

  		this._element = element;
  		this._dragStartTarget = dragStartTarget || element;
  		this._preventOutline = preventOutline;
  	},

  	// @method enable()
  	// Enables the dragging ability
  	enable: function () {
  		if (this._enabled) { return; }

  		on(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = true;
  	},

  	// @method disable()
  	// Disables the dragging ability
  	disable: function () {
  		if (!this._enabled) { return; }

  		// If we're currently dragging this draggable,
  		// disabling it counts as first ending the drag.
  		if (Draggable._dragging === this) {
  			this.finishDrag(true);
  		}

  		off(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = false;
  		this._moved = false;
  	},

  	_onDown: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		this._moved = false;

  		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

  		if (e.touches && e.touches.length !== 1) {
  			// Finish dragging to avoid conflict with touchZoom
  			if (Draggable._dragging === this) {
  				this.finishDrag();
  			}
  			return;
  		}

  		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
  		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

  		if (this._preventOutline) {
  			preventOutline(this._element);
  		}

  		disableImageDrag();
  		disableTextSelection();

  		if (this._moving) { return; }

  		// @event down: Event
  		// Fired when a drag is about to start.
  		this.fire('down');

  		var first = e.touches ? e.touches[0] : e,
  		    sizedParent = getSizedParentNode(this._element);

  		this._startPoint = new Point(first.clientX, first.clientY);
  		this._startPos = getPosition(this._element);

  		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
  		this._parentScale = getScale(sizedParent);

  		var mouseevent = e.type === 'mousedown';
  		on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);
  		on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);
  	},

  	_onMove: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		if (e.touches && e.touches.length > 1) {
  			this._moved = true;
  			return;
  		}

  		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
  		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

  		if (!offset.x && !offset.y) { return; }
  		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

  		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
  		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
  		// and we can use the cached value for the scale.
  		offset.x /= this._parentScale.x;
  		offset.y /= this._parentScale.y;

  		preventDefault(e);

  		if (!this._moved) {
  			// @event dragstart: Event
  			// Fired when a drag starts
  			this.fire('dragstart');

  			this._moved = true;

  			addClass(document.body, 'leaflet-dragging');

  			this._lastTarget = e.target || e.srcElement;
  			// IE and Edge do not give the <use> element, so fetch it
  			// if necessary
  			if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
  				this._lastTarget = this._lastTarget.correspondingUseElement;
  			}
  			addClass(this._lastTarget, 'leaflet-drag-target');
  		}

  		this._newPos = this._startPos.add(offset);
  		this._moving = true;

  		this._lastEvent = e;
  		this._updatePosition();
  	},

  	_updatePosition: function () {
  		var e = {originalEvent: this._lastEvent};

  		// @event predrag: Event
  		// Fired continuously during dragging *before* each corresponding
  		// update of the element's position.
  		this.fire('predrag', e);
  		setPosition(this._element, this._newPos);

  		// @event drag: Event
  		// Fired continuously during dragging.
  		this.fire('drag', e);
  	},

  	_onUp: function () {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }
  		this.finishDrag();
  	},

  	finishDrag: function (noInertia) {
  		removeClass(document.body, 'leaflet-dragging');

  		if (this._lastTarget) {
  			removeClass(this._lastTarget, 'leaflet-drag-target');
  			this._lastTarget = null;
  		}

  		off(document, 'mousemove touchmove', this._onMove, this);
  		off(document, 'mouseup touchend touchcancel', this._onUp, this);

  		enableImageDrag();
  		enableTextSelection();

  		if (this._moved && this._moving) {

  			// @event dragend: DragEndEvent
  			// Fired when the drag ends.
  			this.fire('dragend', {
  				noInertia: noInertia,
  				distance: this._newPos.distanceTo(this._startPos)
  			});
  		}

  		this._moving = false;
  		Draggable._dragging = false;
  	}

  });

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
  function simplify(points, tolerance) {
  	if (!tolerance || !points.length) {
  		return points.slice();
  	}

  	var sqTolerance = tolerance * tolerance;

  	    // stage 1: vertex reduction
  	    points = _reducePoints(points, sqTolerance);

  	    // stage 2: Douglas-Peucker simplification
  	    points = _simplifyDP(points, sqTolerance);

  	return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
  	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
  	return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {

  	var len = points.length,
  	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
  	    markers = new ArrayConstructor(len);

  	    markers[0] = markers[len - 1] = 1;

  	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

  	var i,
  	    newPoints = [];

  	for (i = 0; i < len; i++) {
  		if (markers[i]) {
  			newPoints.push(points[i]);
  		}
  	}

  	return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {

  	var maxSqDist = 0,
  	index, i, sqDist;

  	for (i = first + 1; i <= last - 1; i++) {
  		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

  		if (sqDist > maxSqDist) {
  			index = i;
  			maxSqDist = sqDist;
  		}
  	}

  	if (maxSqDist > sqTolerance) {
  		markers[index] = 1;

  		_simplifyDPStep(points, markers, sqTolerance, first, index);
  		_simplifyDPStep(points, markers, sqTolerance, index, last);
  	}
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
  	var reducedPoints = [points[0]];

  	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
  		if (_sqDist(points[i], points[prev]) > sqTolerance) {
  			reducedPoints.push(points[i]);
  			prev = i;
  		}
  	}
  	if (prev < len - 1) {
  		reducedPoints.push(points[len - 1]);
  	}
  	return reducedPoints;
  }

  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
  	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
  	    codeB = _getBitCode(b, bounds),

  	    codeOut, p, newCode;

  	    // save 2nd code to avoid calculating it on the next segment
  	    _lastCode = codeB;

  	while (true) {
  		// if a,b is inside the clip window (trivial accept)
  		if (!(codeA | codeB)) {
  			return [a, b];
  		}

  		// if a,b is outside the clip window (trivial reject)
  		if (codeA & codeB) {
  			return false;
  		}

  		// other cases
  		codeOut = codeA || codeB;
  		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
  		newCode = _getBitCode(p, bounds);

  		if (codeOut === codeA) {
  			a = p;
  			codeA = newCode;
  		} else {
  			b = p;
  			codeB = newCode;
  		}
  	}
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
  	var dx = b.x - a.x,
  	    dy = b.y - a.y,
  	    min = bounds.min,
  	    max = bounds.max,
  	    x, y;

  	if (code & 8) { // top
  		x = a.x + dx * (max.y - a.y) / dy;
  		y = max.y;

  	} else if (code & 4) { // bottom
  		x = a.x + dx * (min.y - a.y) / dy;
  		y = min.y;

  	} else if (code & 2) { // right
  		x = max.x;
  		y = a.y + dy * (max.x - a.x) / dx;

  	} else if (code & 1) { // left
  		x = min.x;
  		y = a.y + dy * (min.x - a.x) / dx;
  	}

  	return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
  	var code = 0;

  	if (p.x < bounds.min.x) { // left
  		code |= 1;
  	} else if (p.x > bounds.max.x) { // right
  		code |= 2;
  	}

  	if (p.y < bounds.min.y) { // bottom
  		code |= 4;
  	} else if (p.y > bounds.max.y) { // top
  		code |= 8;
  	}

  	return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
  	var dx = p2.x - p1.x,
  	    dy = p2.y - p1.y;
  	return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
  	var x = p1.x,
  	    y = p1.y,
  	    dx = p2.x - x,
  	    dy = p2.y - y,
  	    dot = dx * dx + dy * dy,
  	    t;

  	if (dot > 0) {
  		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

  		if (t > 1) {
  			x = p2.x;
  			y = p2.y;
  		} else if (t > 0) {
  			x += dx * t;
  			y += dy * t;
  		}
  	}

  	dx = p.x - x;
  	dy = p.y - y;

  	return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }


  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
  	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
  }

  function _flat(latlngs) {
  	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
  	return isFlat(latlngs);
  }

  var LineUtil = {
    __proto__: null,
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat
  };

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
  	var clippedPoints,
  	    edges = [1, 4, 2, 8],
  	    i, j, k,
  	    a, b,
  	    len, edge, p;

  	for (i = 0, len = points.length; i < len; i++) {
  		points[i]._code = _getBitCode(points[i], bounds);
  	}

  	// for each edge (left, bottom, right, top)
  	for (k = 0; k < 4; k++) {
  		edge = edges[k];
  		clippedPoints = [];

  		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
  			a = points[i];
  			b = points[j];

  			// if a is inside the clip window
  			if (!(a._code & edge)) {
  				// if b is outside the clip window (a->b goes out of screen)
  				if (b._code & edge) {
  					p = _getEdgeIntersection(b, a, edge, bounds, round);
  					p._code = _getBitCode(p, bounds);
  					clippedPoints.push(p);
  				}
  				clippedPoints.push(a);

  			// else if b is inside the clip window (a->b enters the screen)
  			} else if (!(b._code & edge)) {
  				p = _getEdgeIntersection(b, a, edge, bounds, round);
  				p._code = _getBitCode(p, bounds);
  				clippedPoints.push(p);
  			}
  		}
  		points = clippedPoints;
  	}

  	return points;
  }

  var PolyUtil = {
    __proto__: null,
    clipPolygon: clipPolygon
  };

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection — the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
  	project: function (latlng) {
  		return new Point(latlng.lng, latlng.lat);
  	},

  	unproject: function (point) {
  		return new LatLng(point.y, point.x);
  	},

  	bounds: new Bounds([-180, -90], [180, 90])
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
  	R: 6378137,
  	R_MINOR: 6356752.314245179,

  	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    r = this.R,
  		    y = latlng.lat * d,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    con = e * Math.sin(y);

  		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
  		y = -r * Math.log(Math.max(ts, 1E-10));

  		return new Point(latlng.lng * d * r, y);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI,
  		    r = this.R,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    ts = Math.exp(-point.y / r),
  		    phi = Math.PI / 2 - 2 * Math.atan(ts);

  		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
  			con = e * Math.sin(phi);
  			con = Math.pow((1 - con) / (1 + con), e / 2);
  			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
  			phi += dphi;
  		}

  		return new LatLng(phi * d, point.x * d / r);
  	}
  };

  /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */

  var index = {
    __proto__: null,
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
  	code: 'EPSG:3395',
  	projection: Mercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * Mercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
  	code: 'EPSG:4326',
  	projection: LonLat,
  	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
  	projection: LonLat,
  	transformation: toTransformation(1, 0, -1, 0),

  	scale: function (zoom) {
  		return Math.pow(2, zoom);
  	},

  	zoom: function (scale) {
  		return Math.log(scale) / Math.LN2;
  	},

  	distance: function (latlng1, latlng2) {
  		var dx = latlng2.lng - latlng1.lng,
  		    dy = latlng2.lat - latlng1.lat;

  		return Math.sqrt(dx * dx + dy * dy);
  	},

  	infinite: true
  });

  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */


  var Layer = Evented.extend({

  	// Classes extending `L.Layer` will inherit the following options:
  	options: {
  		// @option pane: String = 'overlayPane'
  		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
  		pane: 'overlayPane',

  		// @option attribution: String = null
  		// String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
  		attribution: null,

  		bubblingMouseEvents: true
  	},

  	/* @section
  	 * Classes extending `L.Layer` will inherit the following methods:
  	 *
  	 * @method addTo(map: Map|LayerGroup): this
  	 * Adds the layer to the given map or layer group.
  	 */
  	addTo: function (map) {
  		map.addLayer(this);
  		return this;
  	},

  	// @method remove: this
  	// Removes the layer from the map it is currently active on.
  	remove: function () {
  		return this.removeFrom(this._map || this._mapToAdd);
  	},

  	// @method removeFrom(map: Map): this
  	// Removes the layer from the given map
  	//
  	// @alternative
  	// @method removeFrom(group: LayerGroup): this
  	// Removes the layer from the given `LayerGroup`
  	removeFrom: function (obj) {
  		if (obj) {
  			obj.removeLayer(this);
  		}
  		return this;
  	},

  	// @method getPane(name? : String): HTMLElement
  	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
  	getPane: function (name) {
  		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
  	},

  	addInteractiveTarget: function (targetEl) {
  		this._map._targets[stamp(targetEl)] = this;
  		return this;
  	},

  	removeInteractiveTarget: function (targetEl) {
  		delete this._map._targets[stamp(targetEl)];
  		return this;
  	},

  	// @method getAttribution: String
  	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
  	getAttribution: function () {
  		return this.options.attribution;
  	},

  	_layerAdd: function (e) {
  		var map = e.target;

  		// check in case layer gets added and then removed before the map is ready
  		if (!map.hasLayer(this)) { return; }

  		this._map = map;
  		this._zoomAnimated = map._zoomAnimated;

  		if (this.getEvents) {
  			var events = this.getEvents();
  			map.on(events, this);
  			this.once('remove', function () {
  				map.off(events, this);
  			}, this);
  		}

  		this.onAdd(map);

  		this.fire('add');
  		map.fire('layeradd', {layer: this});
  	}
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */


  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the map
  	addLayer: function (layer) {
  		if (!layer._layerAdd) {
  			throw new Error('The provided object is not a Layer.');
  		}

  		var id = stamp(layer);
  		if (this._layers[id]) { return this; }
  		this._layers[id] = layer;

  		layer._mapToAdd = this;

  		if (layer.beforeAdd) {
  			layer.beforeAdd(this);
  		}

  		this.whenReady(layer._layerAdd, layer);

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the map.
  	removeLayer: function (layer) {
  		var id = stamp(layer);

  		if (!this._layers[id]) { return this; }

  		if (this._loaded) {
  			layer.onRemove(this);
  		}

  		delete this._layers[id];

  		if (this._loaded) {
  			this.fire('layerremove', {layer: layer});
  			layer.fire('remove');
  		}

  		layer._map = layer._mapToAdd = null;

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the map
  	hasLayer: function (layer) {
  		return stamp(layer) in this._layers;
  	},

  	/* @method eachLayer(fn: Function, context?: Object): this
  	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
  	 * ```
  	 * map.eachLayer(function(layer){
  	 *     layer.bindPopup('Hello');
  	 * });
  	 * ```
  	 */
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	_addLayers: function (layers) {
  		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

  		for (var i = 0, len = layers.length; i < len; i++) {
  			this.addLayer(layers[i]);
  		}
  	},

  	_addZoomLimit: function (layer) {
  		if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
  			this._zoomBoundLayers[stamp(layer)] = layer;
  			this._updateZoomLevels();
  		}
  	},

  	_removeZoomLimit: function (layer) {
  		var id = stamp(layer);

  		if (this._zoomBoundLayers[id]) {
  			delete this._zoomBoundLayers[id];
  			this._updateZoomLevels();
  		}
  	},

  	_updateZoomLevels: function () {
  		var minZoom = Infinity,
  		    maxZoom = -Infinity,
  		    oldZoomSpan = this._getZoomSpan();

  		for (var i in this._zoomBoundLayers) {
  			var options = this._zoomBoundLayers[i].options;

  			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
  			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
  		}

  		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
  		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

  		// @section Map state change events
  		// @event zoomlevelschange: Event
  		// Fired when the number of zoomlevels on the map is changed due
  		// to adding or removing a layer.
  		if (oldZoomSpan !== this._getZoomSpan()) {
  			this.fire('zoomlevelschange');
  		}

  		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
  			this.setZoom(this._layersMaxZoom);
  		}
  		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
  			this.setZoom(this._layersMinZoom);
  		}
  	}
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({

  	initialize: function (layers, options) {
  		setOptions(this, options);

  		this._layers = {};

  		var i, len;

  		if (layers) {
  			for (i = 0, len = layers.length; i < len; i++) {
  				this.addLayer(layers[i]);
  			}
  		}
  	},

  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the group.
  	addLayer: function (layer) {
  		var id = this.getLayerId(layer);

  		this._layers[id] = layer;

  		if (this._map) {
  			this._map.addLayer(layer);
  		}

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the group.
  	// @alternative
  	// @method removeLayer(id: Number): this
  	// Removes the layer with the given internal ID from the group.
  	removeLayer: function (layer) {
  		var id = layer in this._layers ? layer : this.getLayerId(layer);

  		if (this._map && this._layers[id]) {
  			this._map.removeLayer(this._layers[id]);
  		}

  		delete this._layers[id];

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the group.
  	// @alternative
  	// @method hasLayer(id: Number): Boolean
  	// Returns `true` if the given internal ID is currently added to the group.
  	hasLayer: function (layer) {
  		var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
  		return layerId in this._layers;
  	},

  	// @method clearLayers(): this
  	// Removes all the layers from the group.
  	clearLayers: function () {
  		return this.eachLayer(this.removeLayer, this);
  	},

  	// @method invoke(methodName: String, …): this
  	// Calls `methodName` on every layer contained in this group, passing any
  	// additional parameters. Has no effect if the layers contained do not
  	// implement `methodName`.
  	invoke: function (methodName) {
  		var args = Array.prototype.slice.call(arguments, 1),
  		    i, layer;

  		for (i in this._layers) {
  			layer = this._layers[i];

  			if (layer[methodName]) {
  				layer[methodName].apply(layer, args);
  			}
  		}

  		return this;
  	},

  	onAdd: function (map) {
  		this.eachLayer(map.addLayer, map);
  	},

  	onRemove: function (map) {
  		this.eachLayer(map.removeLayer, map);
  	},

  	// @method eachLayer(fn: Function, context?: Object): this
  	// Iterates over the layers of the group, optionally specifying context of the iterator function.
  	// ```js
  	// group.eachLayer(function (layer) {
  	// 	layer.bindPopup('Hello');
  	// });
  	// ```
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	// @method getLayer(id: Number): Layer
  	// Returns the layer with the given internal ID.
  	getLayer: function (id) {
  		return this._layers[id];
  	},

  	// @method getLayers(): Layer[]
  	// Returns an array of all the layers added to the group.
  	getLayers: function () {
  		var layers = [];
  		this.eachLayer(layers.push, layers);
  		return layers;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
  	setZIndex: function (zIndex) {
  		return this.invoke('setZIndex', zIndex);
  	},

  	// @method getLayerId(layer: Layer): Number
  	// Returns the internal ID for a layer
  	getLayerId: function (layer) {
  		return stamp(layer);
  	}
  });


  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
  	return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({

  	addLayer: function (layer) {
  		if (this.hasLayer(layer)) {
  			return this;
  		}

  		layer.addEventParent(this);

  		LayerGroup.prototype.addLayer.call(this, layer);

  		// @event layeradd: LayerEvent
  		// Fired when a layer is added to this `FeatureGroup`
  		return this.fire('layeradd', {layer: layer});
  	},

  	removeLayer: function (layer) {
  		if (!this.hasLayer(layer)) {
  			return this;
  		}
  		if (layer in this._layers) {
  			layer = this._layers[layer];
  		}

  		layer.removeEventParent(this);

  		LayerGroup.prototype.removeLayer.call(this, layer);

  		// @event layerremove: LayerEvent
  		// Fired when a layer is removed from this `FeatureGroup`
  		return this.fire('layerremove', {layer: layer});
  	},

  	// @method setStyle(style: Path options): this
  	// Sets the given path options to each layer of the group that has a `setStyle` method.
  	setStyle: function (style) {
  		return this.invoke('setStyle', style);
  	},

  	// @method bringToFront(): this
  	// Brings the layer group to the top of all other layers
  	bringToFront: function () {
  		return this.invoke('bringToFront');
  	},

  	// @method bringToBack(): this
  	// Brings the layer group to the back of all other layers
  	bringToBack: function () {
  		return this.invoke('bringToBack');
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
  	getBounds: function () {
  		var bounds = new LatLngBounds();

  		for (var id in this._layers) {
  			var layer = this._layers[id];
  			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
  		}
  		return bounds;
  	}
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
  	return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({

  	/* @section
  	 * @aka Icon options
  	 *
  	 * @option iconUrl: String = null
  	 * **(required)** The URL to the icon image (absolute or relative to your script path).
  	 *
  	 * @option iconRetinaUrl: String = null
  	 * The URL to a retina sized version of the icon image (absolute or relative to your
  	 * script path). Used for Retina screen devices.
  	 *
  	 * @option iconSize: Point = null
  	 * Size of the icon image in pixels.
  	 *
  	 * @option iconAnchor: Point = null
  	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  	 * will be aligned so that this point is at the marker's geographical location. Centered
  	 * by default if size is specified, also can be set in CSS with negative margins.
  	 *
  	 * @option popupAnchor: Point = [0, 0]
  	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
  	 *
  	 * @option tooltipAnchor: Point = [0, 0]
  	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  	 *
  	 * @option shadowUrl: String = null
  	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
  	 *
  	 * @option shadowRetinaUrl: String = null
  	 *
  	 * @option shadowSize: Point = null
  	 * Size of the shadow image in pixels.
  	 *
  	 * @option shadowAnchor: Point = null
  	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  	 * as iconAnchor if not specified).
  	 *
  	 * @option className: String = ''
  	 * A custom class name to assign to both icon and shadow images. Empty by default.
  	 */

  	options: {
  		popupAnchor: [0, 0],
  		tooltipAnchor: [0, 0],

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
  	// Called internally when the icon has to be shown, returns a `<img>` HTML element
  	// styled according to the options.
  	createIcon: function (oldIcon) {
  		return this._createIcon('icon', oldIcon);
  	},

  	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
  	// As `createIcon`, but for the shadow beneath it.
  	createShadow: function (oldIcon) {
  		return this._createIcon('shadow', oldIcon);
  	},

  	_createIcon: function (name, oldIcon) {
  		var src = this._getIconUrl(name);

  		if (!src) {
  			if (name === 'icon') {
  				throw new Error('iconUrl not set in Icon options (see the docs).');
  			}
  			return null;
  		}

  		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
  		this._setIconStyles(img, name);

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		return img;
  	},

  	_setIconStyles: function (img, name) {
  		var options = this.options;
  		var sizeOption = options[name + 'Size'];

  		if (typeof sizeOption === 'number') {
  			sizeOption = [sizeOption, sizeOption];
  		}

  		var size = toPoint(sizeOption),
  		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
  		            size && size.divideBy(2, true));

  		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

  		if (anchor) {
  			img.style.marginLeft = (-anchor.x) + 'px';
  			img.style.marginTop  = (-anchor.y) + 'px';
  		}

  		if (size) {
  			img.style.width  = size.x + 'px';
  			img.style.height = size.y + 'px';
  		}
  	},

  	_createImg: function (src, el) {
  		el = el || document.createElement('img');
  		el.src = src;
  		return el;
  	},

  	_getIconUrl: function (name) {
  		return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
  	}
  });


  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
  	return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({

  	options: {
  		iconUrl:       'marker-icon.png',
  		iconRetinaUrl: 'marker-icon-2x.png',
  		shadowUrl:     'marker-shadow.png',
  		iconSize:    [25, 41],
  		iconAnchor:  [12, 41],
  		popupAnchor: [1, -34],
  		tooltipAnchor: [16, -28],
  		shadowSize:  [41, 41]
  	},

  	_getIconUrl: function (name) {
  		if (typeof IconDefault.imagePath !== 'string') {	// Deprecated, backwards-compatibility only
  			IconDefault.imagePath = this._detectIconPath();
  		}

  		// @option imagePath: String
  		// `Icon.Default` will try to auto-detect the location of the
  		// blue icon images. If you are placing these images in a non-standard
  		// way, set this option to point to the right path.
  		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  	},

  	_stripUrl: function (path) {	// separate function to use in tests
  		var strip = function (str, re, idx) {
  			var match = re.exec(str);
  			return match && match[idx];
  		};
  		path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
  		return path && strip(path, /^(.*)marker-icon\.png$/, 1);
  	},

  	_detectIconPath: function () {
  		var el = create$1('div',  'leaflet-default-icon-path', document.body);
  		var path = getStyle(el, 'background-image') ||
  		           getStyle(el, 'backgroundImage');	// IE8

  		document.body.removeChild(el);
  		path = this._stripUrl(path);
  		if (path) { return path; }
  		var link = document.querySelector('link[href$="leaflet.css"]');
  		if (!link) { return ''; }
  		return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);
  	}
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */


  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
  	initialize: function (marker) {
  		this._marker = marker;
  	},

  	addHooks: function () {
  		var icon = this._marker._icon;

  		if (!this._draggable) {
  			this._draggable = new Draggable(icon, icon, true);
  		}

  		this._draggable.on({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).enable();

  		addClass(icon, 'leaflet-marker-draggable');
  	},

  	removeHooks: function () {
  		this._draggable.off({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).disable();

  		if (this._marker._icon) {
  			removeClass(this._marker._icon, 'leaflet-marker-draggable');
  		}
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	_adjustPan: function (e) {
  		var marker = this._marker,
  		    map = marker._map,
  		    speed = this._marker.options.autoPanSpeed,
  		    padding = this._marker.options.autoPanPadding,
  		    iconPos = getPosition(marker._icon),
  		    bounds = map.getPixelBounds(),
  		    origin = map.getPixelOrigin();

  		var panBounds = toBounds(
  			bounds.min._subtract(origin).add(padding),
  			bounds.max._subtract(origin).subtract(padding)
  		);

  		if (!panBounds.contains(iconPos)) {
  			// Compute incremental movement
  			var movement = toPoint(
  				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
  				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

  				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
  				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
  			).multiplyBy(speed);

  			map.panBy(movement, {animate: false});

  			this._draggable._newPos._add(movement);
  			this._draggable._startPos._add(movement);

  			setPosition(marker._icon, this._draggable._newPos);
  			this._onDrag(e);

  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDragStart: function () {
  		// @section Dragging events
  		// @event dragstart: Event
  		// Fired when the user starts dragging the marker.

  		// @event movestart: Event
  		// Fired when the marker starts moving (because of dragging).

  		this._oldLatLng = this._marker.getLatLng();

  		// When using ES6 imports it could not be set when `Popup` was not imported as well
  		this._marker.closePopup && this._marker.closePopup();

  		this._marker
  			.fire('movestart')
  			.fire('dragstart');
  	},

  	_onPreDrag: function (e) {
  		if (this._marker.options.autoPan) {
  			cancelAnimFrame(this._panRequest);
  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDrag: function (e) {
  		var marker = this._marker,
  		    shadow = marker._shadow,
  		    iconPos = getPosition(marker._icon),
  		    latlng = marker._map.layerPointToLatLng(iconPos);

  		// update shadow position
  		if (shadow) {
  			setPosition(shadow, iconPos);
  		}

  		marker._latlng = latlng;
  		e.latlng = latlng;
  		e.oldLatLng = this._oldLatLng;

  		// @event drag: Event
  		// Fired repeatedly while the user drags the marker.
  		marker
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_onDragEnd: function (e) {
  		// @event dragend: DragEndEvent
  		// Fired when the user stops dragging the marker.

  		 cancelAnimFrame(this._panRequest);

  		// @event moveend: Event
  		// Fired when the marker stops moving (because of dragging).
  		delete this._oldLatLng;
  		this._marker
  		    .fire('moveend')
  		    .fire('dragend', e);
  	}
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({

  	// @section
  	// @aka Marker options
  	options: {
  		// @option icon: Icon = *
  		// Icon instance to use for rendering the marker.
  		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
  		// If not specified, a common instance of `L.Icon.Default` is used.
  		icon: new IconDefault(),

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option keyboard: Boolean = true
  		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
  		keyboard: true,

  		// @option title: String = ''
  		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		title: '',

  		// @option alt: String = 'Marker'
  		// Text for the `alt` attribute of the icon image.
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		alt: 'Marker',

  		// @option zIndexOffset: Number = 0
  		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
  		zIndexOffset: 0,

  		// @option opacity: Number = 1.0
  		// The opacity of the marker.
  		opacity: 1,

  		// @option riseOnHover: Boolean = false
  		// If `true`, the marker will get on top of others when you hover the mouse over it.
  		riseOnHover: false,

  		// @option riseOffset: Number = 250
  		// The z-index offset used for the `riseOnHover` feature.
  		riseOffset: 250,

  		// @option pane: String = 'markerPane'
  		// `Map pane` where the markers icon will be added.
  		pane: 'markerPane',

  		// @option shadowPane: String = 'shadowPane'
  		// `Map pane` where the markers shadow will be added.
  		shadowPane: 'shadowPane',

  		// @option bubblingMouseEvents: Boolean = false
  		// When `true`, a mouse event on this marker will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: false,

  		// @option autoPanOnFocus: Boolean = true
  		// When `true`, the map will pan whenever the marker is focused (via
  		// e.g. pressing `tab` on the keyboard) to ensure the marker is
  		// visible within the map's bounds
  		autoPanOnFocus: true,

  		// @section Draggable marker options
  		// @option draggable: Boolean = false
  		// Whether the marker is draggable with mouse/touch or not.
  		draggable: false,

  		// @option autoPan: Boolean = false
  		// Whether to pan the map when dragging this marker near its edge or not.
  		autoPan: false,

  		// @option autoPanPadding: Point = Point(50, 50)
  		// Distance (in pixels to the left/right and to the top/bottom) of the
  		// map edge to start panning the map.
  		autoPanPadding: [50, 50],

  		// @option autoPanSpeed: Number = 10
  		// Number of pixels the map should pan by.
  		autoPanSpeed: 10
  	},

  	/* @section
  	 *
  	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  	 */

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

  		if (this._zoomAnimated) {
  			map.on('zoomanim', this._animateZoom, this);
  		}

  		this._initIcon();
  		this.update();
  	},

  	onRemove: function (map) {
  		if (this.dragging && this.dragging.enabled()) {
  			this.options.draggable = true;
  			this.dragging.removeHooks();
  		}
  		delete this.dragging;

  		if (this._zoomAnimated) {
  			map.off('zoomanim', this._animateZoom, this);
  		}

  		this._removeIcon();
  		this._removeShadow();
  	},

  	getEvents: function () {
  		return {
  			zoom: this.update,
  			viewreset: this.update
  		};
  	},

  	// @method getLatLng: LatLng
  	// Returns the current geographical position of the marker.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Changes the marker position to the given point.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.update();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method setZIndexOffset(offset: Number): this
  	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
  	setZIndexOffset: function (offset) {
  		this.options.zIndexOffset = offset;
  		return this.update();
  	},

  	// @method getIcon: Icon
  	// Returns the current icon used by the marker
  	getIcon: function () {
  		return this.options.icon;
  	},

  	// @method setIcon(icon: Icon): this
  	// Changes the marker icon.
  	setIcon: function (icon) {

  		this.options.icon = icon;

  		if (this._map) {
  			this._initIcon();
  			this.update();
  		}

  		if (this._popup) {
  			this.bindPopup(this._popup, this._popup.options);
  		}

  		return this;
  	},

  	getElement: function () {
  		return this._icon;
  	},

  	update: function () {

  		if (this._icon && this._map) {
  			var pos = this._map.latLngToLayerPoint(this._latlng).round();
  			this._setPos(pos);
  		}

  		return this;
  	},

  	_initIcon: function () {
  		var options = this.options,
  		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		var icon = options.icon.createIcon(this._icon),
  		    addIcon = false;

  		// if we're not reusing the icon, remove the old one and init new one
  		if (icon !== this._icon) {
  			if (this._icon) {
  				this._removeIcon();
  			}
  			addIcon = true;

  			if (options.title) {
  				icon.title = options.title;
  			}

  			if (icon.tagName === 'IMG') {
  				icon.alt = options.alt || '';
  			}
  		}

  		addClass(icon, classToAdd);

  		if (options.keyboard) {
  			icon.tabIndex = '0';
  			icon.setAttribute('role', 'button');
  		}

  		this._icon = icon;

  		if (options.riseOnHover) {
  			this.on({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			on(icon, 'focus', this._panOnFocus, this);
  		}

  		var newShadow = options.icon.createShadow(this._shadow),
  		    addShadow = false;

  		if (newShadow !== this._shadow) {
  			this._removeShadow();
  			addShadow = true;
  		}

  		if (newShadow) {
  			addClass(newShadow, classToAdd);
  			newShadow.alt = '';
  		}
  		this._shadow = newShadow;


  		if (options.opacity < 1) {
  			this._updateOpacity();
  		}


  		if (addIcon) {
  			this.getPane().appendChild(this._icon);
  		}
  		this._initInteraction();
  		if (newShadow && addShadow) {
  			this.getPane(options.shadowPane).appendChild(this._shadow);
  		}
  	},

  	_removeIcon: function () {
  		if (this.options.riseOnHover) {
  			this.off({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			off(this._icon, 'focus', this._panOnFocus, this);
  		}

  		remove(this._icon);
  		this.removeInteractiveTarget(this._icon);

  		this._icon = null;
  	},

  	_removeShadow: function () {
  		if (this._shadow) {
  			remove(this._shadow);
  		}
  		this._shadow = null;
  	},

  	_setPos: function (pos) {

  		if (this._icon) {
  			setPosition(this._icon, pos);
  		}

  		if (this._shadow) {
  			setPosition(this._shadow, pos);
  		}

  		this._zIndex = pos.y + this.options.zIndexOffset;

  		this._resetZIndex();
  	},

  	_updateZIndex: function (offset) {
  		if (this._icon) {
  			this._icon.style.zIndex = this._zIndex + offset;
  		}
  	},

  	_animateZoom: function (opt) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

  		this._setPos(pos);
  	},

  	_initInteraction: function () {

  		if (!this.options.interactive) { return; }

  		addClass(this._icon, 'leaflet-interactive');

  		this.addInteractiveTarget(this._icon);

  		if (MarkerDrag) {
  			var draggable = this.options.draggable;
  			if (this.dragging) {
  				draggable = this.dragging.enabled();
  				this.dragging.disable();
  			}

  			this.dragging = new MarkerDrag(this);

  			if (draggable) {
  				this.dragging.enable();
  			}
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the opacity of the marker.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		if (this._map) {
  			this._updateOpacity();
  		}

  		return this;
  	},

  	_updateOpacity: function () {
  		var opacity = this.options.opacity;

  		if (this._icon) {
  			setOpacity(this._icon, opacity);
  		}

  		if (this._shadow) {
  			setOpacity(this._shadow, opacity);
  		}
  	},

  	_bringToFront: function () {
  		this._updateZIndex(this.options.riseOffset);
  	},

  	_resetZIndex: function () {
  		this._updateZIndex(0);
  	},

  	_panOnFocus: function () {
  		var map = this._map;
  		if (!map) { return; }

  		var iconOpts = this.options.icon.options;
  		var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
  		var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);

  		map.panInside(this._latlng, {
  			paddingTopLeft: anchor,
  			paddingBottomRight: size.subtract(anchor)
  		});
  	},

  	_getPopupAnchor: function () {
  		return this.options.icon.options.popupAnchor;
  	},

  	_getTooltipAnchor: function () {
  		return this.options.icon.options.tooltipAnchor;
  	}
  });


  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
  	return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({

  	// @section
  	// @aka Path options
  	options: {
  		// @option stroke: Boolean = true
  		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
  		stroke: true,

  		// @option color: String = '#3388ff'
  		// Stroke color
  		color: '#3388ff',

  		// @option weight: Number = 3
  		// Stroke width in pixels
  		weight: 3,

  		// @option opacity: Number = 1.0
  		// Stroke opacity
  		opacity: 1,

  		// @option lineCap: String= 'round'
  		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
  		lineCap: 'round',

  		// @option lineJoin: String = 'round'
  		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
  		lineJoin: 'round',

  		// @option dashArray: String = null
  		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashArray: null,

  		// @option dashOffset: String = null
  		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashOffset: null,

  		// @option fill: Boolean = depends
  		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
  		fill: false,

  		// @option fillColor: String = *
  		// Fill color. Defaults to the value of the [`color`](#path-color) option
  		fillColor: null,

  		// @option fillOpacity: Number = 0.2
  		// Fill opacity.
  		fillOpacity: 0.2,

  		// @option fillRule: String = 'evenodd'
  		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
  		fillRule: 'evenodd',

  		// className: '',

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option bubblingMouseEvents: Boolean = true
  		// When `true`, a mouse event on this path will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: true
  	},

  	beforeAdd: function (map) {
  		// Renderer is set here because we need to call renderer.getEvents
  		// before this.getEvents.
  		this._renderer = map.getRenderer(this);
  	},

  	onAdd: function () {
  		this._renderer._initPath(this);
  		this._reset();
  		this._renderer._addPath(this);
  	},

  	onRemove: function () {
  		this._renderer._removePath(this);
  	},

  	// @method redraw(): this
  	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
  	redraw: function () {
  		if (this._map) {
  			this._renderer._updatePath(this);
  		}
  		return this;
  	},

  	// @method setStyle(style: Path options): this
  	// Changes the appearance of a Path based on the options in the `Path options` object.
  	setStyle: function (style) {
  		setOptions(this, style);
  		if (this._renderer) {
  			this._renderer._updateStyle(this);
  			if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
  				this._updateBounds();
  			}
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all path layers.
  	bringToFront: function () {
  		if (this._renderer) {
  			this._renderer._bringToFront(this);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all path layers.
  	bringToBack: function () {
  		if (this._renderer) {
  			this._renderer._bringToBack(this);
  		}
  		return this;
  	},

  	getElement: function () {
  		return this._path;
  	},

  	_reset: function () {
  		// defined in child classes
  		this._project();
  		this._update();
  	},

  	_clickTolerance: function () {
  		// used when doing hit detection for Canvas layers
  		return (this.options.stroke ? this.options.weight / 2 : 0) +
  		  (this._renderer.options.tolerance || 0);
  	}
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({

  	// @section
  	// @aka CircleMarker options
  	options: {
  		fill: true,

  		// @option radius: Number = 10
  		// Radius of the circle marker, in pixels
  		radius: 10
  	},

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  		this._radius = this.options.radius;
  	},

  	// @method setLatLng(latLng: LatLng): this
  	// Sets the position of a circle marker to a new location.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.redraw();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method getLatLng(): LatLng
  	// Returns the current geographical position of the circle marker
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle marker. Units are in pixels.
  	setRadius: function (radius) {
  		this.options.radius = this._radius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of the circle
  	getRadius: function () {
  		return this._radius;
  	},

  	setStyle : function (options) {
  		var radius = options && options.radius || this._radius;
  		Path.prototype.setStyle.call(this, options);
  		this.setRadius(radius);
  		return this;
  	},

  	_project: function () {
  		this._point = this._map.latLngToLayerPoint(this._latlng);
  		this._updateBounds();
  	},

  	_updateBounds: function () {
  		var r = this._radius,
  		    r2 = this._radiusY || r,
  		    w = this._clickTolerance(),
  		    p = [r + w, r2 + w];
  		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
  	},

  	_update: function () {
  		if (this._map) {
  			this._updatePath();
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updateCircle(this);
  	},

  	_empty: function () {
  		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
  	}
  });


  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
  	return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({

  	initialize: function (latlng, options, legacyOptions) {
  		if (typeof options === 'number') {
  			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
  			options = extend({}, legacyOptions, {radius: options});
  		}
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);

  		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

  		// @section
  		// @aka Circle options
  		// @option radius: Number; Radius of the circle, in meters.
  		this._mRadius = this.options.radius;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle. Units are in meters.
  	setRadius: function (radius) {
  		this._mRadius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of a circle. Units are in meters.
  	getRadius: function () {
  		return this._mRadius;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		var half = [this._radius, this._radiusY || this._radius];

  		return new LatLngBounds(
  			this._map.layerPointToLatLng(this._point.subtract(half)),
  			this._map.layerPointToLatLng(this._point.add(half)));
  	},

  	setStyle: Path.prototype.setStyle,

  	_project: function () {

  		var lng = this._latlng.lng,
  		    lat = this._latlng.lat,
  		    map = this._map,
  		    crs = map.options.crs;

  		if (crs.distance === Earth.distance) {
  			var d = Math.PI / 180,
  			    latR = (this._mRadius / Earth.R) / d,
  			    top = map.project([lat + latR, lng]),
  			    bottom = map.project([lat - latR, lng]),
  			    p = top.add(bottom).divideBy(2),
  			    lat2 = map.unproject(p).lat,
  			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
  			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

  			if (isNaN(lngR) || lngR === 0) {
  				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
  			}

  			this._point = p.subtract(map.getPixelOrigin());
  			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
  			this._radiusY = p.y - top.y;

  		} else {
  			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

  			this._point = map.latLngToLayerPoint(this._latlng);
  			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
  		}

  		this._updateBounds();
  	}
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
  	return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({

  	// @section
  	// @aka Polyline options
  	options: {
  		// @option smoothFactor: Number = 1.0
  		// How much to simplify the polyline on each zoom level. More means
  		// better performance and smoother look, and less means more accurate representation.
  		smoothFactor: 1.0,

  		// @option noClip: Boolean = false
  		// Disable polyline clipping.
  		noClip: false
  	},

  	initialize: function (latlngs, options) {
  		setOptions(this, options);
  		this._setLatLngs(latlngs);
  	},

  	// @method getLatLngs(): LatLng[]
  	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
  	getLatLngs: function () {
  		return this._latlngs;
  	},

  	// @method setLatLngs(latlngs: LatLng[]): this
  	// Replaces all the points in the polyline with the given array of geographical points.
  	setLatLngs: function (latlngs) {
  		this._setLatLngs(latlngs);
  		return this.redraw();
  	},

  	// @method isEmpty(): Boolean
  	// Returns `true` if the Polyline has no LatLngs.
  	isEmpty: function () {
  		return !this._latlngs.length;
  	},

  	// @method closestLayerPoint(p: Point): Point
  	// Returns the point closest to `p` on the Polyline.
  	closestLayerPoint: function (p) {
  		var minDistance = Infinity,
  		    minPoint = null,
  		    closest = _sqClosestPointOnSegment,
  		    p1, p2;

  		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
  			var points = this._parts[j];

  			for (var i = 1, len = points.length; i < len; i++) {
  				p1 = points[i - 1];
  				p2 = points[i];

  				var sqDist = closest(p, p1, p2, true);

  				if (sqDist < minDistance) {
  					minDistance = sqDist;
  					minPoint = closest(p, p1, p2);
  				}
  			}
  		}
  		if (minPoint) {
  			minPoint.distance = Math.sqrt(minDistance);
  		}
  		return minPoint;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}

  		var i, halfDist, segDist, dist, p1, p2, ratio,
  		    points = this._rings[0],
  		    len = points.length;

  		if (!len) { return null; }

  		// polyline centroid algorithm; only uses the first ring if there are multiple

  		for (i = 0, halfDist = 0; i < len - 1; i++) {
  			halfDist += points[i].distanceTo(points[i + 1]) / 2;
  		}

  		// The line is so small in the current view that all points are on the same pixel.
  		if (halfDist === 0) {
  			return this._map.layerPointToLatLng(points[0]);
  		}

  		for (i = 0, dist = 0; i < len - 1; i++) {
  			p1 = points[i];
  			p2 = points[i + 1];
  			segDist = p1.distanceTo(p2);
  			dist += segDist;

  			if (dist > halfDist) {
  				ratio = (dist - halfDist) / segDist;
  				return this._map.layerPointToLatLng([
  					p2.x - ratio * (p2.x - p1.x),
  					p2.y - ratio * (p2.y - p1.y)
  				]);
  			}
  		}
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
  	// Adds a given point to the polyline. By default, adds to the first ring of
  	// the polyline in case of a multi-polyline, but can be overridden by passing
  	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
  	addLatLng: function (latlng, latlngs) {
  		latlngs = latlngs || this._defaultShape();
  		latlng = toLatLng(latlng);
  		latlngs.push(latlng);
  		this._bounds.extend(latlng);
  		return this.redraw();
  	},

  	_setLatLngs: function (latlngs) {
  		this._bounds = new LatLngBounds();
  		this._latlngs = this._convertLatLngs(latlngs);
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
  	},

  	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
  	_convertLatLngs: function (latlngs) {
  		var result = [],
  		    flat = isFlat(latlngs);

  		for (var i = 0, len = latlngs.length; i < len; i++) {
  			if (flat) {
  				result[i] = toLatLng(latlngs[i]);
  				this._bounds.extend(result[i]);
  			} else {
  				result[i] = this._convertLatLngs(latlngs[i]);
  			}
  		}

  		return result;
  	},

  	_project: function () {
  		var pxBounds = new Bounds();
  		this._rings = [];
  		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

  		if (this._bounds.isValid() && pxBounds.isValid()) {
  			this._rawPxBounds = pxBounds;
  			this._updateBounds();
  		}
  	},

  	_updateBounds: function () {
  		var w = this._clickTolerance(),
  		    p = new Point(w, w);

  		if (!this._rawPxBounds) {
  			return;
  		}

  		this._pxBounds = new Bounds([
  			this._rawPxBounds.min.subtract(p),
  			this._rawPxBounds.max.add(p)
  		]);
  	},

  	// recursively turns latlngs into a set of rings with projected coordinates
  	_projectLatlngs: function (latlngs, result, projectedBounds) {
  		var flat = latlngs[0] instanceof LatLng,
  		    len = latlngs.length,
  		    i, ring;

  		if (flat) {
  			ring = [];
  			for (i = 0; i < len; i++) {
  				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
  				projectedBounds.extend(ring[i]);
  			}
  			result.push(ring);
  		} else {
  			for (i = 0; i < len; i++) {
  				this._projectLatlngs(latlngs[i], result, projectedBounds);
  			}
  		}
  	},

  	// clip polyline by renderer bounds so that we have less to render for performance
  	_clipPoints: function () {
  		var bounds = this._renderer._bounds;

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		var parts = this._parts,
  		    i, j, k, len, len2, segment, points;

  		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
  			points = this._rings[i];

  			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
  				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

  				if (!segment) { continue; }

  				parts[k] = parts[k] || [];
  				parts[k].push(segment[0]);

  				// if segment goes out of screen, or it's the last one, it's the end of the line part
  				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
  					parts[k].push(segment[1]);
  					k++;
  				}
  			}
  		}
  	},

  	// simplify each clipped part of the polyline for performance
  	_simplifyPoints: function () {
  		var parts = this._parts,
  		    tolerance = this.options.smoothFactor;

  		for (var i = 0, len = parts.length; i < len; i++) {
  			parts[i] = simplify(parts[i], tolerance);
  		}
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		this._clipPoints();
  		this._simplifyPoints();
  		this._updatePath();
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p, closed) {
  		var i, j, k, len, len2, part,
  		    w = this._clickTolerance();

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// hit detection for polylines
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				if (!closed && (j === 0)) { continue; }

  				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
  					return true;
  				}
  			}
  		}
  		return false;
  	}
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
  	return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({

  	options: {
  		fill: true
  	},

  	isEmpty: function () {
  		return !this._latlngs.length || !this._latlngs[0].length;
  	},

  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}

  		var i, j, p1, p2, f, area, x, y, center,
  		    points = this._rings[0],
  		    len = points.length;

  		if (!len) { return null; }

  		// polygon centroid algorithm; only uses the first ring if there are multiple

  		area = x = y = 0;

  		for (i = 0, j = len - 1; i < len; j = i++) {
  			p1 = points[i];
  			p2 = points[j];

  			f = p1.y * p2.x - p2.y * p1.x;
  			x += (p1.x + p2.x) * f;
  			y += (p1.y + p2.y) * f;
  			area += f * 3;
  		}

  		if (area === 0) {
  			// Polygon is so small that all points are on same pixel.
  			center = points[0];
  		} else {
  			center = [x / area, y / area];
  		}
  		return this._map.layerPointToLatLng(center);
  	},

  	_convertLatLngs: function (latlngs) {
  		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
  		    len = result.length;

  		// remove last point if it equals first one
  		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
  			result.pop();
  		}
  		return result;
  	},

  	_setLatLngs: function (latlngs) {
  		Polyline.prototype._setLatLngs.call(this, latlngs);
  		if (isFlat(this._latlngs)) {
  			this._latlngs = [this._latlngs];
  		}
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
  	},

  	_clipPoints: function () {
  		// polygons need a different clipping algorithm so we redefine that

  		var bounds = this._renderer._bounds,
  		    w = this.options.weight,
  		    p = new Point(w, w);

  		// increase clip padding by stroke width to avoid stroke on clip edges
  		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
  			clipped = clipPolygon(this._rings[i], bounds, true);
  			if (clipped.length) {
  				this._parts.push(clipped);
  			}
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this, true);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		var inside = false,
  		    part, p1, p2, i, j, k, len, len2;

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// ray casting algorithm for detecting if point is in polygon
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				p1 = part[j];
  				p2 = part[k];

  				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
  					inside = !inside;
  				}
  			}
  		}

  		// also check if it's on polygon stroke
  		return inside || Polyline.prototype._containsPoint.call(this, p, true);
  	}

  });


  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
  	return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({

  	/* @section
  	 * @aka GeoJSON options
  	 *
  	 * @option pointToLayer: Function = *
  	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  	 * The default is to spawn a default `Marker`:
  	 * ```js
  	 * function(geoJsonPoint, latlng) {
  	 * 	return L.marker(latlng);
  	 * }
  	 * ```
  	 *
  	 * @option style: Function = *
  	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  	 * called internally when data is added.
  	 * The default value is to not override any defaults:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return {}
  	 * }
  	 * ```
  	 *
  	 * @option onEachFeature: Function = *
  	 * A `Function` that will be called once for each created `Feature`, after it has
  	 * been created and styled. Useful for attaching events and popups to features.
  	 * The default is to do nothing with the newly created layers:
  	 * ```js
  	 * function (feature, layer) {}
  	 * ```
  	 *
  	 * @option filter: Function = *
  	 * A `Function` that will be used to decide whether to include a feature or not.
  	 * The default is to include all features:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return true;
  	 * }
  	 * ```
  	 * Note: dynamically changing the `filter` option will have effect only on newly
  	 * added data. It will _not_ re-evaluate already included features.
  	 *
  	 * @option coordsToLatLng: Function = *
  	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  	 * The default is the `coordsToLatLng` static method.
  	 *
  	 * @option markersInheritOptions: Boolean = false
  	 * Whether default Markers for "Point" type Features inherit from group options.
  	 */

  	initialize: function (geojson, options) {
  		setOptions(this, options);

  		this._layers = {};

  		if (geojson) {
  			this.addData(geojson);
  		}
  	},

  	// @method addData( <GeoJSON> data ): this
  	// Adds a GeoJSON object to the layer.
  	addData: function (geojson) {
  		var features = isArray(geojson) ? geojson : geojson.features,
  		    i, len, feature;

  		if (features) {
  			for (i = 0, len = features.length; i < len; i++) {
  				// only add this if geometry or geometries are set and not null
  				feature = features[i];
  				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
  					this.addData(feature);
  				}
  			}
  			return this;
  		}

  		var options = this.options;

  		if (options.filter && !options.filter(geojson)) { return this; }

  		var layer = geometryToLayer(geojson, options);
  		if (!layer) {
  			return this;
  		}
  		layer.feature = asFeature(geojson);

  		layer.defaultOptions = layer.options;
  		this.resetStyle(layer);

  		if (options.onEachFeature) {
  			options.onEachFeature(geojson, layer);
  		}

  		return this.addLayer(layer);
  	},

  	// @method resetStyle( <Path> layer? ): this
  	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
  	// If `layer` is omitted, the style of all features in the current layer is reset.
  	resetStyle: function (layer) {
  		if (layer === undefined) {
  			return this.eachLayer(this.resetStyle, this);
  		}
  		// reset any custom styles
  		layer.options = extend({}, layer.defaultOptions);
  		this._setLayerStyle(layer, this.options.style);
  		return this;
  	},

  	// @method setStyle( <Function> style ): this
  	// Changes styles of GeoJSON vector layers with the given style function.
  	setStyle: function (style) {
  		return this.eachLayer(function (layer) {
  			this._setLayerStyle(layer, style);
  		}, this);
  	},

  	_setLayerStyle: function (layer, style) {
  		if (layer.setStyle) {
  			if (typeof style === 'function') {
  				style = style(layer.feature);
  			}
  			layer.setStyle(style);
  		}
  	}
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {

  	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
  	    coords = geometry ? geometry.coordinates : null,
  	    layers = [],
  	    pointToLayer = options && options.pointToLayer,
  	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
  	    latlng, latlngs, i, len;

  	if (!coords && !geometry) {
  		return null;
  	}

  	switch (geometry.type) {
  	case 'Point':
  		latlng = _coordsToLatLng(coords);
  		return _pointToLayer(pointToLayer, geojson, latlng, options);

  	case 'MultiPoint':
  		for (i = 0, len = coords.length; i < len; i++) {
  			latlng = _coordsToLatLng(coords[i]);
  			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
  		}
  		return new FeatureGroup(layers);

  	case 'LineString':
  	case 'MultiLineString':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
  		return new Polyline(latlngs, options);

  	case 'Polygon':
  	case 'MultiPolygon':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
  		return new Polygon(latlngs, options);

  	case 'GeometryCollection':
  		for (i = 0, len = geometry.geometries.length; i < len; i++) {
  			var layer = geometryToLayer({
  				geometry: geometry.geometries[i],
  				type: 'Feature',
  				properties: geojson.properties
  			}, options);

  			if (layer) {
  				layers.push(layer);
  			}
  		}
  		return new FeatureGroup(layers);

  	default:
  		throw new Error('Invalid GeoJSON object.');
  	}
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
  	return pointToLayerFn ?
  		pointToLayerFn(geojson, latlng) :
  		new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
  	return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
  	var latlngs = [];

  	for (var i = 0, len = coords.length, latlng; i < len; i++) {
  		latlng = levelsDeep ?
  			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
  			(_coordsToLatLng || coordsToLatLng)(coords[i]);

  		latlngs.push(latlng);
  	}

  	return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngToCoords(latlng, precision) {
  	latlng = toLatLng(latlng);
  	return latlng.alt !== undefined ?
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
  	var coords = [];

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		coords.push(levelsDeep ?
  			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
  			latLngToCoords(latlngs[i], precision));
  	}

  	if (!levelsDeep && closed) {
  		coords.push(coords[0]);
  	}

  	return coords;
  }

  function getFeature(layer, newGeometry) {
  	return layer.feature ?
  		extend({}, layer.feature, {geometry: newGeometry}) :
  		asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
  	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
  		return geojson;
  	}

  	return {
  		type: 'Feature',
  		properties: {},
  		geometry: geojson
  	};
  }

  var PointToGeoJSON = {
  	toGeoJSON: function (precision) {
  		return getFeature(this, {
  			type: 'Point',
  			coordinates: latLngToCoords(this.getLatLng(), precision)
  		});
  	}
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);


  // @namespace Polyline
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
  	toGeoJSON: function (precision) {
  		var multi = !isFlat(this._latlngs);

  		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'LineString',
  			coordinates: coords
  		});
  	}
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
  	toGeoJSON: function (precision) {
  		var holes = !isFlat(this._latlngs),
  		    multi = holes && !isFlat(this._latlngs[0]);

  		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

  		if (!holes) {
  			coords = [coords];
  		}

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'Polygon',
  			coordinates: coords
  		});
  	}
  });


  // @namespace LayerGroup
  LayerGroup.include({
  	toMultiPoint: function (precision) {
  		var coords = [];

  		this.eachLayer(function (layer) {
  			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
  		});

  		return getFeature(this, {
  			type: 'MultiPoint',
  			coordinates: coords
  		});
  	},

  	// @method toGeoJSON(precision?: Number|false): Object
  	// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  	// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
  	toGeoJSON: function (precision) {

  		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

  		if (type === 'MultiPoint') {
  			return this.toMultiPoint(precision);
  		}

  		var isGeometryCollection = type === 'GeometryCollection',
  		    jsons = [];

  		this.eachLayer(function (layer) {
  			if (layer.toGeoJSON) {
  				var json = layer.toGeoJSON(precision);
  				if (isGeometryCollection) {
  					jsons.push(json.geometry);
  				} else {
  					var feature = asFeature(json);
  					// Squash nested feature collections
  					if (feature.type === 'FeatureCollection') {
  						jsons.push.apply(jsons, feature.features);
  					} else {
  						jsons.push(feature);
  					}
  				}
  			}
  		});

  		if (isGeometryCollection) {
  			return getFeature(this, {
  				geometries: jsons,
  				type: 'GeometryCollection'
  			});
  		}

  		return {
  			type: 'FeatureCollection',
  			features: jsons
  		};
  	}
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
  	return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({

  	// @section
  	// @aka ImageOverlay options
  	options: {
  		// @option opacity: Number = 1.0
  		// The opacity of the image overlay.
  		opacity: 1,

  		// @option alt: String = ''
  		// Text for the `alt` attribute of the image (useful for accessibility).
  		alt: '',

  		// @option interactive: Boolean = false
  		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
  		interactive: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the image.
  		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option errorOverlayUrl: String = ''
  		// URL to the overlay image to show in place of the overlay that failed to load.
  		errorOverlayUrl: '',

  		// @option zIndex: Number = 1
  		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
  		zIndex: 1,

  		// @option className: String = ''
  		// A custom class name to assign to the image. Empty by default.
  		className: ''
  	},

  	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
  		this._url = url;
  		this._bounds = toLatLngBounds(bounds);

  		setOptions(this, options);
  	},

  	onAdd: function () {
  		if (!this._image) {
  			this._initImage();

  			if (this.options.opacity < 1) {
  				this._updateOpacity();
  			}
  		}

  		if (this.options.interactive) {
  			addClass(this._image, 'leaflet-interactive');
  			this.addInteractiveTarget(this._image);
  		}

  		this.getPane().appendChild(this._image);
  		this._reset();
  	},

  	onRemove: function () {
  		remove(this._image);
  		if (this.options.interactive) {
  			this.removeInteractiveTarget(this._image);
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Sets the opacity of the overlay.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._image) {
  			this._updateOpacity();
  		}
  		return this;
  	},

  	setStyle: function (styleOpts) {
  		if (styleOpts.opacity) {
  			this.setOpacity(styleOpts.opacity);
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all overlays.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._image);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all overlays.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._image);
  		}
  		return this;
  	},

  	// @method setUrl(url: String): this
  	// Changes the URL of the image.
  	setUrl: function (url) {
  		this._url = url;

  		if (this._image) {
  			this._image.src = url;
  		}
  		return this;
  	},

  	// @method setBounds(bounds: LatLngBounds): this
  	// Update the bounds that this ImageOverlay covers
  	setBounds: function (bounds) {
  		this._bounds = toLatLngBounds(bounds);

  		if (this._map) {
  			this._reset();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._reset,
  			viewreset: this._reset
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @method setZIndex(value: Number): this
  	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
  	setZIndex: function (value) {
  		this.options.zIndex = value;
  		this._updateZIndex();
  		return this;
  	},

  	// @method getBounds(): LatLngBounds
  	// Get the bounds that this ImageOverlay covers
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method getElement(): HTMLElement
  	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
  	// used by this overlay.
  	getElement: function () {
  		return this._image;
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'IMG';
  		var img = this._image = wasElementSupplied ? this._url : create$1('img');

  		addClass(img, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(img, this.options.className); }

  		img.onselectstart = falseFn;
  		img.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the ImageOverlay layer has loaded its image
  		img.onload = bind(this.fire, this, 'load');
  		img.onerror = bind(this._overlayOnError, this, 'error');

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		if (this.options.zIndex) {
  			this._updateZIndex();
  		}

  		if (wasElementSupplied) {
  			this._url = img.src;
  			return;
  		}

  		img.src = this._url;
  		img.alt = this.options.alt;
  	},

  	_animateZoom: function (e) {
  		var scale = this._map.getZoomScale(e.zoom),
  		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

  		setTransform(this._image, offset, scale);
  	},

  	_reset: function () {
  		var image = this._image,
  		    bounds = new Bounds(
  		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
  		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
  		    size = bounds.getSize();

  		setPosition(image, bounds.min);

  		image.style.width  = size.x + 'px';
  		image.style.height = size.y + 'px';
  	},

  	_updateOpacity: function () {
  		setOpacity(this._image, this.options.opacity);
  	},

  	_updateZIndex: function () {
  		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._image.style.zIndex = this.options.zIndex;
  		}
  	},

  	_overlayOnError: function () {
  		// @event error: Event
  		// Fired when the ImageOverlay layer fails to load its image
  		this.fire('error');

  		var errorUrl = this.options.errorOverlayUrl;
  		if (errorUrl && this._url !== errorUrl) {
  			this._url = errorUrl;
  			this._image.src = errorUrl;
  		}
  	},

  	// @method getCenter(): LatLng
  	// Returns the center of the ImageOverlay.
  	getCenter: function () {
  		return this._bounds.getCenter();
  	}
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
  	return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({

  	// @section
  	// @aka VideoOverlay options
  	options: {
  		// @option autoplay: Boolean = true
  		// Whether the video starts playing automatically when loaded.
  		// On some browsers autoplay will only work with `muted: true`
  		autoplay: true,

  		// @option loop: Boolean = true
  		// Whether the video will loop back to the beginning when played.
  		loop: true,

  		// @option keepAspectRatio: Boolean = true
  		// Whether the video will save aspect ratio after the projection.
  		// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
  		keepAspectRatio: true,

  		// @option muted: Boolean = false
  		// Whether the video starts on mute when loaded.
  		muted: false,

  		// @option playsInline: Boolean = true
  		// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
  		playsInline: true
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'VIDEO';
  		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

  		addClass(vid, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(vid, this.options.className); }

  		vid.onselectstart = falseFn;
  		vid.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the video has finished loading the first frame
  		vid.onloadeddata = bind(this.fire, this, 'load');

  		if (wasElementSupplied) {
  			var sourceElements = vid.getElementsByTagName('source');
  			var sources = [];
  			for (var j = 0; j < sourceElements.length; j++) {
  				sources.push(sourceElements[j].src);
  			}

  			this._url = (sourceElements.length > 0) ? sources : [vid.src];
  			return;
  		}

  		if (!isArray(this._url)) { this._url = [this._url]; }

  		if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
  			vid.style['objectFit'] = 'fill';
  		}
  		vid.autoplay = !!this.options.autoplay;
  		vid.loop = !!this.options.loop;
  		vid.muted = !!this.options.muted;
  		vid.playsInline = !!this.options.playsInline;
  		for (var i = 0; i < this._url.length; i++) {
  			var source = create$1('source');
  			source.src = this._url[i];
  			vid.appendChild(source);
  		}
  	}

  	// @method getElement(): HTMLVideoElement
  	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
  	// used by this overlay.
  });


  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
  	return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
  	_initImage: function () {
  		var el = this._image = this._url;

  		addClass(el, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(el, this.options.className); }

  		el.onselectstart = falseFn;
  		el.onmousemove = falseFn;
  	}

  	// @method getElement(): SVGElement
  	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
  	// used by this overlay.
  });


  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
  	return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({

  	// @section
  	// @aka DivOverlay options
  	options: {
  		// @option interactive: Boolean = false
  		// If true, the popup/tooltip will listen to the mouse events.
  		interactive: false,

  		// @option offset: Point = Point(0, 0)
  		// The offset of the overlay position.
  		offset: [0, 0],

  		// @option className: String = ''
  		// A custom CSS class name to assign to the overlay.
  		className: '',

  		// @option pane: String = undefined
  		// `Map pane` where the overlay will be added.
  		pane: undefined
  	},

  	initialize: function (options, source) {
  		setOptions(this, options);

  		this._source = source;
  	},

  	// @method openOn(map: Map): this
  	// Adds the overlay to the map.
  	// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api
  		if (!map.hasLayer(this)) {
  			map.addLayer(this);
  		}
  		return this;
  	},

  	// @method close(): this
  	// Closes the overlay.
  	// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
  	// and `layer.closePopup()`/`.closeTooltip()`.
  	close: function () {
  		if (this._map) {
  			this._map.removeLayer(this);
  		}
  		return this;
  	},

  	// @method toggle(layer?: Layer): this
  	// Opens or closes the overlay bound to layer depending on its current state.
  	// Argument may be omitted only for overlay bound to layer.
  	// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
  	toggle: function (layer) {
  		if (this._map) {
  			this.close();
  		} else {
  			if (arguments.length) {
  				this._source = layer;
  			} else {
  				layer = this._source;
  			}
  			this._prepareOpen();

  			// open the overlay on the map
  			this.openOn(layer._map);
  		}
  		return this;
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = map._zoomAnimated;

  		if (!this._container) {
  			this._initLayout();
  		}

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  		}

  		clearTimeout(this._removeTimeout);
  		this.getPane().appendChild(this._container);
  		this.update();

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 1);
  		}

  		this.bringToFront();

  		if (this.options.interactive) {
  			addClass(this._container, 'leaflet-interactive');
  			this.addInteractiveTarget(this._container);
  		}
  	},

  	onRemove: function (map) {
  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
  		} else {
  			remove(this._container);
  		}

  		if (this.options.interactive) {
  			removeClass(this._container, 'leaflet-interactive');
  			this.removeInteractiveTarget(this._container);
  		}
  	},

  	// @namespace DivOverlay
  	// @method getLatLng: LatLng
  	// Returns the geographical point of the overlay.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Sets the geographical point where the overlay will open.
  	setLatLng: function (latlng) {
  		this._latlng = toLatLng(latlng);
  		if (this._map) {
  			this._updatePosition();
  			this._adjustPan();
  		}
  		return this;
  	},

  	// @method getContent: String|HTMLElement
  	// Returns the content of the overlay.
  	getContent: function () {
  		return this._content;
  	},

  	// @method setContent(htmlContent: String|HTMLElement|Function): this
  	// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
  	// The function should return a `String` or `HTMLElement` to be used in the overlay.
  	setContent: function (content) {
  		this._content = content;
  		this.update();
  		return this;
  	},

  	// @method getElement: String|HTMLElement
  	// Returns the HTML container of the overlay.
  	getElement: function () {
  		return this._container;
  	},

  	// @method update: null
  	// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
  	update: function () {
  		if (!this._map) { return; }

  		this._container.style.visibility = 'hidden';

  		this._updateContent();
  		this._updateLayout();
  		this._updatePosition();

  		this._container.style.visibility = '';

  		this._adjustPan();
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._updatePosition,
  			viewreset: this._updatePosition
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}
  		return events;
  	},

  	// @method isOpen: Boolean
  	// Returns `true` when the overlay is visible on the map.
  	isOpen: function () {
  		return !!this._map && this._map.hasLayer(this);
  	},

  	// @method bringToFront: this
  	// Brings this overlay in front of other overlays (in the same map pane).
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings this overlay to the back of other overlays (in the same map pane).
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  		}
  		return this;
  	},

  	// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
  	_prepareOpen: function (latlng) {
  		var source = this._source;
  		if (!source._map) { return false; }

  		if (source instanceof FeatureGroup) {
  			source = null;
  			var layers = this._source._layers;
  			for (var id in layers) {
  				if (layers[id]._map) {
  					source = layers[id];
  					break;
  				}
  			}
  			if (!source) { return false; } // Unable to get source layer.

  			// set overlay source to this layer
  			this._source = source;
  		}

  		if (!latlng) {
  			if (source.getCenter) {
  				latlng = source.getCenter();
  			} else if (source.getLatLng) {
  				latlng = source.getLatLng();
  			} else if (source.getBounds) {
  				latlng = source.getBounds().getCenter();
  			} else {
  				throw new Error('Unable to get source layer LatLng.');
  			}
  		}
  		this.setLatLng(latlng);

  		if (this._map) {
  			// update the overlay (content, layout, etc...)
  			this.update();
  		}

  		return true;
  	},

  	_updateContent: function () {
  		if (!this._content) { return; }

  		var node = this._contentNode;
  		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

  		if (typeof content === 'string') {
  			node.innerHTML = content;
  		} else {
  			while (node.hasChildNodes()) {
  				node.removeChild(node.firstChild);
  			}
  			node.appendChild(content);
  		}

  		// @namespace DivOverlay
  		// @section DivOverlay events
  		// @event contentupdate: Event
  		// Fired when the content of the overlay is updated
  		this.fire('contentupdate');
  	},

  	_updatePosition: function () {
  		if (!this._map) { return; }

  		var pos = this._map.latLngToLayerPoint(this._latlng),
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (this._zoomAnimated) {
  			setPosition(this._container, pos.add(anchor));
  		} else {
  			offset = offset.add(pos).add(anchor);
  		}

  		var bottom = this._containerBottom = -offset.y,
  		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

  		// bottom position the overlay in case the height of the overlay changes (images loading etc)
  		this._container.style.bottom = bottom + 'px';
  		this._container.style.left = left + 'px';
  	},

  	_getAnchor: function () {
  		return [0, 0];
  	}

  });

  Map.include({
  	_initOverlay: function (OverlayClass, content, latlng, options) {
  		var overlay = content;
  		if (!(overlay instanceof OverlayClass)) {
  			overlay = new OverlayClass(options).setContent(content);
  		}
  		if (latlng) {
  			overlay.setLatLng(latlng);
  		}
  		return overlay;
  	}
  });


  Layer.include({
  	_initOverlay: function (OverlayClass, old, content, options) {
  		var overlay = content;
  		if (overlay instanceof OverlayClass) {
  			setOptions(overlay, options);
  			overlay._source = this;
  		} else {
  			overlay = (old && !options) ? old : new OverlayClass(options, this);
  			overlay.setContent(content);
  		}
  		return overlay;
  	}
  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   * Here's a more complicated way to open a popup on a map:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */


  // @namespace Popup
  var Popup = DivOverlay.extend({

  	// @section
  	// @aka Popup options
  	options: {
  		// @option pane: String = 'popupPane'
  		// `Map pane` where the popup will be added.
  		pane: 'popupPane',

  		// @option offset: Point = Point(0, 7)
  		// The offset of the popup position.
  		offset: [0, 7],

  		// @option maxWidth: Number = 300
  		// Max width of the popup, in pixels.
  		maxWidth: 300,

  		// @option minWidth: Number = 50
  		// Min width of the popup, in pixels.
  		minWidth: 50,

  		// @option maxHeight: Number = null
  		// If set, creates a scrollable container of the given height
  		// inside a popup if its content exceeds it.
  		maxHeight: null,

  		// @option autoPan: Boolean = true
  		// Set it to `false` if you don't want the map to do panning animation
  		// to fit the opened popup.
  		autoPan: true,

  		// @option autoPanPaddingTopLeft: Point = null
  		// The margin between the popup and the top left corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingTopLeft: null,

  		// @option autoPanPaddingBottomRight: Point = null
  		// The margin between the popup and the bottom right corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingBottomRight: null,

  		// @option autoPanPadding: Point = Point(5, 5)
  		// Equivalent of setting both top left and bottom right autopan padding to the same value.
  		autoPanPadding: [5, 5],

  		// @option keepInView: Boolean = false
  		// Set it to `true` if you want to prevent users from panning the popup
  		// off of the screen while it is open.
  		keepInView: false,

  		// @option closeButton: Boolean = true
  		// Controls the presence of a close button in the popup.
  		closeButton: true,

  		// @option autoClose: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the popup closing when another popup is opened.
  		autoClose: true,

  		// @option closeOnEscapeKey: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the ESC key for closing of the popup.
  		closeOnEscapeKey: true,

  		// @option closeOnClick: Boolean = *
  		// Set it if you want to override the default behavior of the popup closing when user clicks
  		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

  		// @option className: String = ''
  		// A custom CSS class name to assign to the popup.
  		className: ''
  	},

  	// @namespace Popup
  	// @method openOn(map: Map): this
  	// Alternative to `map.openPopup(popup)`.
  	// Adds the popup to the map and closes the previous one.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api

  		if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
  			map.removeLayer(map._popup);
  		}
  		map._popup = this;

  		return DivOverlay.prototype.openOn.call(this, map);
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupopen: PopupEvent
  		// Fired when a popup is opened in the map
  		map.fire('popupopen', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupopen: PopupEvent
  			// Fired when a popup bound to this layer is opened
  			this._source.fire('popupopen', {popup: this}, true);
  			// For non-path layers, we toggle the popup when clicking
  			// again the layer, so prevent the map to reopen it.
  			if (!(this._source instanceof Path)) {
  				this._source.on('preclick', stopPropagation);
  			}
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupclose: PopupEvent
  		// Fired when a popup in the map is closed
  		map.fire('popupclose', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupclose: PopupEvent
  			// Fired when a popup bound to this layer is closed
  			this._source.fire('popupclose', {popup: this}, true);
  			if (!(this._source instanceof Path)) {
  				this._source.off('preclick', stopPropagation);
  			}
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
  			events.preclick = this.close;
  		}

  		if (this.options.keepInView) {
  			events.moveend = this._adjustPan;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-popup',
  		    container = this._container = create$1('div',
  			prefix + ' ' + (this.options.className || '') +
  			' leaflet-zoom-animated');

  		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
  		this._contentNode = create$1('div', prefix + '-content', wrapper);

  		disableClickPropagation(container);
  		disableScrollPropagation(this._contentNode);
  		on(container, 'contextmenu', stopPropagation);

  		this._tipContainer = create$1('div', prefix + '-tip-container', container);
  		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

  		if (this.options.closeButton) {
  			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
  			closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399
  			closeButton.setAttribute('aria-label', 'Close popup');
  			closeButton.href = '#close';
  			closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';

  			on(closeButton, 'click', this.close, this);
  		}
  	},

  	_updateLayout: function () {
  		var container = this._contentNode,
  		    style = container.style;

  		style.width = '';
  		style.whiteSpace = 'nowrap';

  		var width = container.offsetWidth;
  		width = Math.min(width, this.options.maxWidth);
  		width = Math.max(width, this.options.minWidth);

  		style.width = (width + 1) + 'px';
  		style.whiteSpace = '';

  		style.height = '';

  		var height = container.offsetHeight,
  		    maxHeight = this.options.maxHeight,
  		    scrolledClass = 'leaflet-popup-scrolled';

  		if (maxHeight && height > maxHeight) {
  			style.height = maxHeight + 'px';
  			addClass(container, scrolledClass);
  		} else {
  			removeClass(container, scrolledClass);
  		}

  		this._containerWidth = this._container.offsetWidth;
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
  		    anchor = this._getAnchor();
  		setPosition(this._container, pos.add(anchor));
  	},

  	_adjustPan: function (e) {
  		if (!this.options.autoPan) { return; }
  		if (this._map._panAnim) { this._map._panAnim.stop(); }

  		var map = this._map,
  		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
  		    containerHeight = this._container.offsetHeight + marginBottom,
  		    containerWidth = this._containerWidth,
  		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

  		layerPos._add(getPosition(this._container));

  		var containerPos = map.layerPointToContainerPoint(layerPos),
  		    padding = toPoint(this.options.autoPanPadding),
  		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
  		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
  		    size = map.getSize(),
  		    dx = 0,
  		    dy = 0;

  		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
  			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
  		}
  		if (containerPos.x - dx - paddingTL.x < 0) { // left
  			dx = containerPos.x - paddingTL.x;
  		}
  		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
  			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
  		}
  		if (containerPos.y - dy - paddingTL.y < 0) { // top
  			dy = containerPos.y - paddingTL.y;
  		}

  		// @namespace Map
  		// @section Popup events
  		// @event autopanstart: Event
  		// Fired when the map starts autopanning when opening a popup.
  		if (dx || dy) {
  			map
  			    .fire('autopanstart')
  			    .panBy([dx, dy], {animate: e && e.type === 'moveend'});
  		}
  	},

  	_getAnchor: function () {
  		// Where should we anchor the popup on the source layer?
  		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
  	}

  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  var popup = function (options, source) {
  	return new Popup(options, source);
  };


  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
  	closePopupOnClick: true
  });


  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
  	// @method openPopup(popup: Popup): this
  	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
  	// @alternative
  	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
  	// Creates a popup with the specified content and options and opens it in the given point on a map.
  	openPopup: function (popup, latlng, options) {
  		this._initOverlay(Popup, popup, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closePopup(popup?: Popup): this
  	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
  	closePopup: function (popup) {
  		popup = arguments.length ? popup : this._popup;
  		if (popup) {
  			popup.close();
  		}
  		return this;
  	}
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({

  	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
  	// Binds a popup to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindPopup: function (content, options) {
  		this._popup = this._initOverlay(Popup, this._popup, content, options);
  		if (!this._popupHandlersAdded) {
  			this.on({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = true;
  		}

  		return this;
  	},

  	// @method unbindPopup(): this
  	// Removes the popup previously bound with `bindPopup`.
  	unbindPopup: function () {
  		if (this._popup) {
  			this.off({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = false;
  			this._popup = null;
  		}
  		return this;
  	},

  	// @method openPopup(latlng?: LatLng): this
  	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
  	openPopup: function (latlng) {
  		if (this._popup && this._popup._prepareOpen(latlng)) {
  			// open the popup on the map
  			this._popup.openOn(this._map);
  		}
  		return this;
  	},

  	// @method closePopup(): this
  	// Closes the popup bound to this layer if it is open.
  	closePopup: function () {
  		if (this._popup) {
  			this._popup.close();
  		}
  		return this;
  	},

  	// @method togglePopup(): this
  	// Opens or closes the popup bound to this layer depending on its current state.
  	togglePopup: function () {
  		if (this._popup) {
  			this._popup.toggle(this);
  		}
  		return this;
  	},

  	// @method isPopupOpen(): boolean
  	// Returns `true` if the popup bound to this layer is currently open.
  	isPopupOpen: function () {
  		return (this._popup ? this._popup.isOpen() : false);
  	},

  	// @method setPopupContent(content: String|HTMLElement|Popup): this
  	// Sets the content of the popup bound to this layer.
  	setPopupContent: function (content) {
  		if (this._popup) {
  			this._popup.setContent(content);
  		}
  		return this;
  	},

  	// @method getPopup(): Popup
  	// Returns the popup bound to this layer.
  	getPopup: function () {
  		return this._popup;
  	},

  	_openPopup: function (e) {
  		if (!this._popup || !this._map) {
  			return;
  		}
  		// prevent map click
  		stop(e);

  		var target = e.layer || e.target;
  		if (this._popup._source === target && !(target instanceof Path)) {
  			// treat it like a marker and figure out
  			// if we should toggle it open/closed
  			if (this._map.hasLayer(this._popup)) {
  				this.closePopup();
  			} else {
  				this.openPopup(e.latlng);
  			}
  			return;
  		}
  		this._popup._source = target;
  		this.openPopup(e.latlng);
  	},

  	_movePopup: function (e) {
  		this._popup.setLatLng(e.latlng);
  	},

  	_onKeyPress: function (e) {
  		if (e.originalEvent.keyCode === 13) {
  			this._openPopup(e);
  		}
  	}
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */


  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({

  	// @section
  	// @aka Tooltip options
  	options: {
  		// @option pane: String = 'tooltipPane'
  		// `Map pane` where the tooltip will be added.
  		pane: 'tooltipPane',

  		// @option offset: Point = Point(0, 0)
  		// Optional offset of the tooltip position.
  		offset: [0, 0],

  		// @option direction: String = 'auto'
  		// Direction where to open the tooltip. Possible values are: `right`, `left`,
  		// `top`, `bottom`, `center`, `auto`.
  		// `auto` will dynamically switch between `right` and `left` according to the tooltip
  		// position on the map.
  		direction: 'auto',

  		// @option permanent: Boolean = false
  		// Whether to open the tooltip permanently or only on mouseover.
  		permanent: false,

  		// @option sticky: Boolean = false
  		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
  		sticky: false,

  		// @option opacity: Number = 0.9
  		// Tooltip container opacity.
  		opacity: 0.9
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);
  		this.setOpacity(this.options.opacity);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipopen: TooltipEvent
  		// Fired when a tooltip is opened in the map.
  		map.fire('tooltipopen', {tooltip: this});

  		if (this._source) {
  			this.addEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipopen: TooltipEvent
  			// Fired when a tooltip bound to this layer is opened.
  			this._source.fire('tooltipopen', {tooltip: this}, true);
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipclose: TooltipEvent
  		// Fired when a tooltip in the map is closed.
  		map.fire('tooltipclose', {tooltip: this});

  		if (this._source) {
  			this.removeEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipclose: TooltipEvent
  			// Fired when a tooltip bound to this layer is closed.
  			this._source.fire('tooltipclose', {tooltip: this}, true);
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (!this.options.permanent) {
  			events.preclick = this.close;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-tooltip',
  		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		this._contentNode = this._container = create$1('div', className);
  	},

  	_updateLayout: function () {},

  	_adjustPan: function () {},

  	_setPosition: function (pos) {
  		var subX, subY,
  		    map = this._map,
  		    container = this._container,
  		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
  		    tooltipPoint = map.layerPointToContainerPoint(pos),
  		    direction = this.options.direction,
  		    tooltipWidth = container.offsetWidth,
  		    tooltipHeight = container.offsetHeight,
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (direction === 'top') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight;
  		} else if (direction === 'bottom') {
  			subX = tooltipWidth / 2;
  			subY = 0;
  		} else if (direction === 'center') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'right') {
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'left') {
  			subX = tooltipWidth;
  			subY = tooltipHeight / 2;
  		} else if (tooltipPoint.x < centerPoint.x) {
  			direction = 'right';
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else {
  			direction = 'left';
  			subX = tooltipWidth + (offset.x + anchor.x) * 2;
  			subY = tooltipHeight / 2;
  		}

  		pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);

  		removeClass(container, 'leaflet-tooltip-right');
  		removeClass(container, 'leaflet-tooltip-left');
  		removeClass(container, 'leaflet-tooltip-top');
  		removeClass(container, 'leaflet-tooltip-bottom');
  		addClass(container, 'leaflet-tooltip-' + direction);
  		setPosition(container, pos);
  	},

  	_updatePosition: function () {
  		var pos = this._map.latLngToLayerPoint(this._latlng);
  		this._setPosition(pos);
  	},

  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._container) {
  			setOpacity(this._container, opacity);
  		}
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
  		this._setPosition(pos);
  	},

  	_getAnchor: function () {
  		// Where should we anchor the tooltip on the source layer?
  		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
  	}

  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  var tooltip = function (options, source) {
  	return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({

  	// @method openTooltip(tooltip: Tooltip): this
  	// Opens the specified tooltip.
  	// @alternative
  	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
  	// Creates a tooltip with the specified content and options and open it.
  	openTooltip: function (tooltip, latlng, options) {
  		this._initOverlay(Tooltip, tooltip, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closeTooltip(tooltip: Tooltip): this
  	// Closes the tooltip given as parameter.
  	closeTooltip: function (tooltip) {
  		tooltip.close();
  		return this;
  	}

  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({

  	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
  	// Binds a tooltip to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindTooltip: function (content, options) {

  		if (this._tooltip && this.isTooltipOpen()) {
  			this.unbindTooltip();
  		}

  		this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
  		this._initTooltipInteractions();

  		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
  			this.openTooltip();
  		}

  		return this;
  	},

  	// @method unbindTooltip(): this
  	// Removes the tooltip previously bound with `bindTooltip`.
  	unbindTooltip: function () {
  		if (this._tooltip) {
  			this._initTooltipInteractions(true);
  			this.closeTooltip();
  			this._tooltip = null;
  		}
  		return this;
  	},

  	_initTooltipInteractions: function (remove) {
  		if (!remove && this._tooltipHandlersAdded) { return; }
  		var onOff = remove ? 'off' : 'on',
  		    events = {
  			remove: this.closeTooltip,
  			move: this._moveTooltip
  		    };
  		if (!this._tooltip.options.permanent) {
  			events.mouseover = this._openTooltip;
  			events.mouseout = this.closeTooltip;
  			events.click = this._openTooltip;
  		} else {
  			events.add = this._openTooltip;
  		}
  		if (this._tooltip.options.sticky) {
  			events.mousemove = this._moveTooltip;
  		}
  		this[onOff](events);
  		this._tooltipHandlersAdded = !remove;
  	},

  	// @method openTooltip(latlng?: LatLng): this
  	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
  	openTooltip: function (latlng) {
  		if (this._tooltip && this._tooltip._prepareOpen(latlng)) {
  			// open the tooltip on the map
  			this._tooltip.openOn(this._map);
  		}
  		return this;
  	},

  	// @method closeTooltip(): this
  	// Closes the tooltip bound to this layer if it is open.
  	closeTooltip: function () {
  		if (this._tooltip) {
  			return this._tooltip.close();
  		}
  	},

  	// @method toggleTooltip(): this
  	// Opens or closes the tooltip bound to this layer depending on its current state.
  	toggleTooltip: function () {
  		if (this._tooltip) {
  			this._tooltip.toggle(this);
  		}
  		return this;
  	},

  	// @method isTooltipOpen(): boolean
  	// Returns `true` if the tooltip bound to this layer is currently open.
  	isTooltipOpen: function () {
  		return this._tooltip.isOpen();
  	},

  	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
  	// Sets the content of the tooltip bound to this layer.
  	setTooltipContent: function (content) {
  		if (this._tooltip) {
  			this._tooltip.setContent(content);
  		}
  		return this;
  	},

  	// @method getTooltip(): Tooltip
  	// Returns the tooltip bound to this layer.
  	getTooltip: function () {
  		return this._tooltip;
  	},

  	_openTooltip: function (e) {
  		if (!this._tooltip || !this._map || (this._map.dragging && this._map.dragging.moving())) {
  			return;
  		}
  		this._tooltip._source = e.layer || e.target;

  		this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
  	},

  	_moveTooltip: function (e) {
  		var latlng = e.latlng, containerPoint, layerPoint;
  		if (this._tooltip.options.sticky && e.originalEvent) {
  			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
  			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
  			latlng = this._map.layerPointToLatLng(layerPoint);
  		}
  		this._tooltip.setLatLng(latlng);
  	}
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
  	options: {
  		// @section
  		// @aka DivIcon options
  		iconSize: [12, 12], // also can be set through CSS

  		// iconAnchor: (Point),
  		// popupAnchor: (Point),

  		// @option html: String|HTMLElement = ''
  		// Custom HTML code to put inside the div element, empty by default. Alternatively,
  		// an instance of `HTMLElement`.
  		html: false,

  		// @option bgPos: Point = [0, 0]
  		// Optional relative position of the background, in pixels
  		bgPos: null,

  		className: 'leaflet-div-icon'
  	},

  	createIcon: function (oldIcon) {
  		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
  		    options = this.options;

  		if (options.html instanceof Element) {
  			empty(div);
  			div.appendChild(options.html);
  		} else {
  			div.innerHTML = options.html !== false ? options.html : '';
  		}

  		if (options.bgPos) {
  			var bgPos = toPoint(options.bgPos);
  			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
  		}
  		this._setIconStyles(div, 'icon');

  		return div;
  	},

  	createShadow: function () {
  		return null;
  	}
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
  	return new DivIcon(options);
  }

  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */


  var GridLayer = Layer.extend({

  	// @section
  	// @aka GridLayer options
  	options: {
  		// @option tileSize: Number|Point = 256
  		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
  		tileSize: 256,

  		// @option opacity: Number = 1.0
  		// Opacity of the tiles. Can be used in the `createTile()` function.
  		opacity: 1,

  		// @option updateWhenIdle: Boolean = (depends)
  		// Load new tiles only when panning ends.
  		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
  		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
  		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
  		updateWhenIdle: Browser.mobile,

  		// @option updateWhenZooming: Boolean = true
  		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
  		updateWhenZooming: true,

  		// @option updateInterval: Number = 200
  		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
  		updateInterval: 200,

  		// @option zIndex: Number = 1
  		// The explicit zIndex of the tile layer.
  		zIndex: 1,

  		// @option bounds: LatLngBounds = undefined
  		// If set, tiles will only be loaded inside the set `LatLngBounds`.
  		bounds: null,

  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = undefined
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: undefined,

  		// @option maxNativeZoom: Number = undefined
  		// Maximum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
  		// from `maxNativeZoom` level and auto-scaled.
  		maxNativeZoom: undefined,

  		// @option minNativeZoom: Number = undefined
  		// Minimum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
  		// from `minNativeZoom` level and auto-scaled.
  		minNativeZoom: undefined,

  		// @option noWrap: Boolean = false
  		// Whether the layer is wrapped around the antimeridian. If `true`, the
  		// GridLayer will only be displayed once at low zoom levels. Has no
  		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
  		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
  		// tiles outside the CRS limits.
  		noWrap: false,

  		// @option pane: String = 'tilePane'
  		// `Map pane` where the grid layer will be added.
  		pane: 'tilePane',

  		// @option className: String = ''
  		// A custom class name to assign to the tile layer. Empty by default.
  		className: '',

  		// @option keepBuffer: Number = 2
  		// When panning the map, keep this many rows and columns of tiles before unloading them.
  		keepBuffer: 2
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	onAdd: function () {
  		this._initContainer();

  		this._levels = {};
  		this._tiles = {};

  		this._resetView(); // implicit _update() call
  	},

  	beforeAdd: function (map) {
  		map._addZoomLimit(this);
  	},

  	onRemove: function (map) {
  		this._removeAllTiles();
  		remove(this._container);
  		map._removeZoomLimit(this);
  		this._container = null;
  		this._tileZoom = undefined;
  	},

  	// @method bringToFront: this
  	// Brings the tile layer to the top of all tile layers.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  			this._setAutoZIndex(Math.max);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings the tile layer to the bottom of all tile layers.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  			this._setAutoZIndex(Math.min);
  		}
  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the tiles for this layer.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		this._updateOpacity();
  		return this;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
  	setZIndex: function (zIndex) {
  		this.options.zIndex = zIndex;
  		this._updateZIndex();

  		return this;
  	},

  	// @method isLoading: Boolean
  	// Returns `true` if any tile in the grid layer has not finished loading.
  	isLoading: function () {
  		return this._loading;
  	},

  	// @method redraw: this
  	// Causes the layer to clear all the tiles and request them again.
  	redraw: function () {
  		if (this._map) {
  			this._removeAllTiles();
  			var tileZoom = this._clampZoom(this._map.getZoom());
  			if (tileZoom !== this._tileZoom) {
  				this._tileZoom = tileZoom;
  				this._updateLevels();
  			}
  			this._update();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			viewprereset: this._invalidateAll,
  			viewreset: this._resetView,
  			zoom: this._resetView,
  			moveend: this._onMoveEnd
  		};

  		if (!this.options.updateWhenIdle) {
  			// update tiles on move, but not more often than once per given interval
  			if (!this._onMove) {
  				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
  			}

  			events.move = this._onMove;
  		}

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @section Extension methods
  	// Layers extending `GridLayer` shall reimplement the following method.
  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, must be overridden by classes extending `GridLayer`.
  	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  	// is specified, it must be called when the tile has finished loading and drawing.
  	createTile: function () {
  		return document.createElement('div');
  	},

  	// @section
  	// @method getTileSize: Point
  	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
  	getTileSize: function () {
  		var s = this.options.tileSize;
  		return s instanceof Point ? s : new Point(s, s);
  	},

  	_updateZIndex: function () {
  		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._container.style.zIndex = this.options.zIndex;
  		}
  	},

  	_setAutoZIndex: function (compare) {
  		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

  		var layers = this.getPane().children,
  		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

  		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

  			zIndex = layers[i].style.zIndex;

  			if (layers[i] !== this._container && zIndex) {
  				edgeZIndex = compare(edgeZIndex, +zIndex);
  			}
  		}

  		if (isFinite(edgeZIndex)) {
  			this.options.zIndex = edgeZIndex + compare(-1, 1);
  			this._updateZIndex();
  		}
  	},

  	_updateOpacity: function () {
  		if (!this._map) { return; }

  		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
  		if (Browser.ielt9) { return; }

  		setOpacity(this._container, this.options.opacity);

  		var now = +new Date(),
  		    nextFrame = false,
  		    willPrune = false;

  		for (var key in this._tiles) {
  			var tile = this._tiles[key];
  			if (!tile.current || !tile.loaded) { continue; }

  			var fade = Math.min(1, (now - tile.loaded) / 200);

  			setOpacity(tile.el, fade);
  			if (fade < 1) {
  				nextFrame = true;
  			} else {
  				if (tile.active) {
  					willPrune = true;
  				} else {
  					this._onOpaqueTile(tile);
  				}
  				tile.active = true;
  			}
  		}

  		if (willPrune && !this._noPrune) { this._pruneTiles(); }

  		if (nextFrame) {
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		}
  	},

  	_onOpaqueTile: falseFn,

  	_initContainer: function () {
  		if (this._container) { return; }

  		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
  		this._updateZIndex();

  		if (this.options.opacity < 1) {
  			this._updateOpacity();
  		}

  		this.getPane().appendChild(this._container);
  	},

  	_updateLevels: function () {

  		var zoom = this._tileZoom,
  		    maxZoom = this.options.maxZoom;

  		if (zoom === undefined) { return undefined; }

  		for (var z in this._levels) {
  			z = Number(z);
  			if (this._levels[z].el.children.length || z === zoom) {
  				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
  				this._onUpdateLevel(z);
  			} else {
  				remove(this._levels[z].el);
  				this._removeTilesAtZoom(z);
  				this._onRemoveLevel(z);
  				delete this._levels[z];
  			}
  		}

  		var level = this._levels[zoom],
  		    map = this._map;

  		if (!level) {
  			level = this._levels[zoom] = {};

  			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
  			level.el.style.zIndex = maxZoom;

  			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
  			level.zoom = zoom;

  			this._setZoomTransform(level, map.getCenter(), map.getZoom());

  			// force the browser to consider the newly added element for transition
  			falseFn(level.el.offsetWidth);

  			this._onCreateLevel(level);
  		}

  		this._level = level;

  		return level;
  	},

  	_onUpdateLevel: falseFn,

  	_onRemoveLevel: falseFn,

  	_onCreateLevel: falseFn,

  	_pruneTiles: function () {
  		if (!this._map) {
  			return;
  		}

  		var key, tile;

  		var zoom = this._map.getZoom();
  		if (zoom > this.options.maxZoom ||
  			zoom < this.options.minZoom) {
  			this._removeAllTiles();
  			return;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			tile.retain = tile.current;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			if (tile.current && !tile.active) {
  				var coords = tile.coords;
  				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
  					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
  				}
  			}
  		}

  		for (key in this._tiles) {
  			if (!this._tiles[key].retain) {
  				this._removeTile(key);
  			}
  		}
  	},

  	_removeTilesAtZoom: function (zoom) {
  		for (var key in this._tiles) {
  			if (this._tiles[key].coords.z !== zoom) {
  				continue;
  			}
  			this._removeTile(key);
  		}
  	},

  	_removeAllTiles: function () {
  		for (var key in this._tiles) {
  			this._removeTile(key);
  		}
  	},

  	_invalidateAll: function () {
  		for (var z in this._levels) {
  			remove(this._levels[z].el);
  			this._onRemoveLevel(Number(z));
  			delete this._levels[z];
  		}
  		this._removeAllTiles();

  		this._tileZoom = undefined;
  	},

  	_retainParent: function (x, y, z, minZoom) {
  		var x2 = Math.floor(x / 2),
  		    y2 = Math.floor(y / 2),
  		    z2 = z - 1,
  		    coords2 = new Point(+x2, +y2);
  		coords2.z = +z2;

  		var key = this._tileCoordsToKey(coords2),
  		    tile = this._tiles[key];

  		if (tile && tile.active) {
  			tile.retain = true;
  			return true;

  		} else if (tile && tile.loaded) {
  			tile.retain = true;
  		}

  		if (z2 > minZoom) {
  			return this._retainParent(x2, y2, z2, minZoom);
  		}

  		return false;
  	},

  	_retainChildren: function (x, y, z, maxZoom) {

  		for (var i = 2 * x; i < 2 * x + 2; i++) {
  			for (var j = 2 * y; j < 2 * y + 2; j++) {

  				var coords = new Point(i, j);
  				coords.z = z + 1;

  				var key = this._tileCoordsToKey(coords),
  				    tile = this._tiles[key];

  				if (tile && tile.active) {
  					tile.retain = true;
  					continue;

  				} else if (tile && tile.loaded) {
  					tile.retain = true;
  				}

  				if (z + 1 < maxZoom) {
  					this._retainChildren(i, j, z + 1, maxZoom);
  				}
  			}
  		}
  	},

  	_resetView: function (e) {
  		var animating = e && (e.pinch || e.flyTo);
  		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  	},

  	_animateZoom: function (e) {
  		this._setView(e.center, e.zoom, true, e.noUpdate);
  	},

  	_clampZoom: function (zoom) {
  		var options = this.options;

  		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
  			return options.minNativeZoom;
  		}

  		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
  			return options.maxNativeZoom;
  		}

  		return zoom;
  	},

  	_setView: function (center, zoom, noPrune, noUpdate) {
  		var tileZoom = Math.round(zoom);
  		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
  		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
  			tileZoom = undefined;
  		} else {
  			tileZoom = this._clampZoom(tileZoom);
  		}

  		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

  		if (!noUpdate || tileZoomChanged) {

  			this._tileZoom = tileZoom;

  			if (this._abortLoading) {
  				this._abortLoading();
  			}

  			this._updateLevels();
  			this._resetGrid();

  			if (tileZoom !== undefined) {
  				this._update(center);
  			}

  			if (!noPrune) {
  				this._pruneTiles();
  			}

  			// Flag to prevent _updateOpacity from pruning tiles during
  			// a zoom anim or a pinch gesture
  			this._noPrune = !!noPrune;
  		}

  		this._setZoomTransforms(center, zoom);
  	},

  	_setZoomTransforms: function (center, zoom) {
  		for (var i in this._levels) {
  			this._setZoomTransform(this._levels[i], center, zoom);
  		}
  	},

  	_setZoomTransform: function (level, center, zoom) {
  		var scale = this._map.getZoomScale(zoom, level.zoom),
  		    translate = level.origin.multiplyBy(scale)
  		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

  		if (Browser.any3d) {
  			setTransform(level.el, translate, scale);
  		} else {
  			setPosition(level.el, translate);
  		}
  	},

  	_resetGrid: function () {
  		var map = this._map,
  		    crs = map.options.crs,
  		    tileSize = this._tileSize = this.getTileSize(),
  		    tileZoom = this._tileZoom;

  		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
  		if (bounds) {
  			this._globalTileRange = this._pxBoundsToTileRange(bounds);
  		}

  		this._wrapX = crs.wrapLng && !this.options.noWrap && [
  			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
  			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
  		];
  		this._wrapY = crs.wrapLat && !this.options.noWrap && [
  			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
  			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
  		];
  	},

  	_onMoveEnd: function () {
  		if (!this._map || this._map._animatingZoom) { return; }

  		this._update();
  	},

  	_getTiledPixelBounds: function (center) {
  		var map = this._map,
  		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
  		    scale = map.getZoomScale(mapZoom, this._tileZoom),
  		    pixelCenter = map.project(center, this._tileZoom).floor(),
  		    halfSize = map.getSize().divideBy(scale * 2);

  		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  	},

  	// Private method to load tiles in the grid's active zoom level according to map bounds
  	_update: function (center) {
  		var map = this._map;
  		if (!map) { return; }
  		var zoom = this._clampZoom(map.getZoom());

  		if (center === undefined) { center = map.getCenter(); }
  		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

  		var pixelBounds = this._getTiledPixelBounds(center),
  		    tileRange = this._pxBoundsToTileRange(pixelBounds),
  		    tileCenter = tileRange.getCenter(),
  		    queue = [],
  		    margin = this.options.keepBuffer,
  		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
  		                              tileRange.getTopRight().add([margin, -margin]));

  		// Sanity check: panic if the tile range contains Infinity somewhere.
  		if (!(isFinite(tileRange.min.x) &&
  		      isFinite(tileRange.min.y) &&
  		      isFinite(tileRange.max.x) &&
  		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

  		for (var key in this._tiles) {
  			var c = this._tiles[key].coords;
  			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
  				this._tiles[key].current = false;
  			}
  		}

  		// _update just loads more tiles. If the tile zoom level differs too much
  		// from the map's, let _setView reset levels and prune old tiles.
  		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

  		// create a queue of coordinates to load tiles from
  		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
  			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
  				var coords = new Point(i, j);
  				coords.z = this._tileZoom;

  				if (!this._isValidTile(coords)) { continue; }

  				var tile = this._tiles[this._tileCoordsToKey(coords)];
  				if (tile) {
  					tile.current = true;
  				} else {
  					queue.push(coords);
  				}
  			}
  		}

  		// sort tile queue to load tiles in order of their distance to center
  		queue.sort(function (a, b) {
  			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
  		});

  		if (queue.length !== 0) {
  			// if it's the first batch of tiles to load
  			if (!this._loading) {
  				this._loading = true;
  				// @event loading: Event
  				// Fired when the grid layer starts loading tiles.
  				this.fire('loading');
  			}

  			// create DOM fragment to append tiles in one batch
  			var fragment = document.createDocumentFragment();

  			for (i = 0; i < queue.length; i++) {
  				this._addTile(queue[i], fragment);
  			}

  			this._level.el.appendChild(fragment);
  		}
  	},

  	_isValidTile: function (coords) {
  		var crs = this._map.options.crs;

  		if (!crs.infinite) {
  			// don't load tile if it's out of bounds and not wrapped
  			var bounds = this._globalTileRange;
  			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
  			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
  		}

  		if (!this.options.bounds) { return true; }

  		// don't load tile if it doesn't intersect the bounds in options
  		var tileBounds = this._tileCoordsToBounds(coords);
  		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
  	},

  	_keyToBounds: function (key) {
  		return this._tileCoordsToBounds(this._keyToTileCoords(key));
  	},

  	_tileCoordsToNwSe: function (coords) {
  		var map = this._map,
  		    tileSize = this.getTileSize(),
  		    nwPoint = coords.scaleBy(tileSize),
  		    sePoint = nwPoint.add(tileSize),
  		    nw = map.unproject(nwPoint, coords.z),
  		    se = map.unproject(sePoint, coords.z);
  		return [nw, se];
  	},

  	// converts tile coordinates to its geographical bounds
  	_tileCoordsToBounds: function (coords) {
  		var bp = this._tileCoordsToNwSe(coords),
  		    bounds = new LatLngBounds(bp[0], bp[1]);

  		if (!this.options.noWrap) {
  			bounds = this._map.wrapLatLngBounds(bounds);
  		}
  		return bounds;
  	},
  	// converts tile coordinates to key for the tile cache
  	_tileCoordsToKey: function (coords) {
  		return coords.x + ':' + coords.y + ':' + coords.z;
  	},

  	// converts tile cache key to coordinates
  	_keyToTileCoords: function (key) {
  		var k = key.split(':'),
  		    coords = new Point(+k[0], +k[1]);
  		coords.z = +k[2];
  		return coords;
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		remove(tile.el);

  		delete this._tiles[key];

  		// @event tileunload: TileEvent
  		// Fired when a tile is removed (e.g. when a tile goes off the screen).
  		this.fire('tileunload', {
  			tile: tile.el,
  			coords: this._keyToTileCoords(key)
  		});
  	},

  	_initTile: function (tile) {
  		addClass(tile, 'leaflet-tile');

  		var tileSize = this.getTileSize();
  		tile.style.width = tileSize.x + 'px';
  		tile.style.height = tileSize.y + 'px';

  		tile.onselectstart = falseFn;
  		tile.onmousemove = falseFn;

  		// update opacity on tiles in IE7-8 because of filter inheritance problems
  		if (Browser.ielt9 && this.options.opacity < 1) {
  			setOpacity(tile, this.options.opacity);
  		}
  	},

  	_addTile: function (coords, container) {
  		var tilePos = this._getTilePos(coords),
  		    key = this._tileCoordsToKey(coords);

  		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

  		this._initTile(tile);

  		// if createTile is defined with a second argument ("done" callback),
  		// we know that tile is async and will be ready later; otherwise
  		if (this.createTile.length < 2) {
  			// mark tile as ready, but delay one frame for opacity animation to happen
  			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
  		}

  		setPosition(tile, tilePos);

  		// save tile in cache
  		this._tiles[key] = {
  			el: tile,
  			coords: coords,
  			current: true
  		};

  		container.appendChild(tile);
  		// @event tileloadstart: TileEvent
  		// Fired when a tile is requested and starts loading.
  		this.fire('tileloadstart', {
  			tile: tile,
  			coords: coords
  		});
  	},

  	_tileReady: function (coords, err, tile) {
  		if (err) {
  			// @event tileerror: TileErrorEvent
  			// Fired when there is an error loading a tile.
  			this.fire('tileerror', {
  				error: err,
  				tile: tile,
  				coords: coords
  			});
  		}

  		var key = this._tileCoordsToKey(coords);

  		tile = this._tiles[key];
  		if (!tile) { return; }

  		tile.loaded = +new Date();
  		if (this._map._fadeAnimated) {
  			setOpacity(tile.el, 0);
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		} else {
  			tile.active = true;
  			this._pruneTiles();
  		}

  		if (!err) {
  			addClass(tile.el, 'leaflet-tile-loaded');

  			// @event tileload: TileEvent
  			// Fired when a tile loads.
  			this.fire('tileload', {
  				tile: tile.el,
  				coords: coords
  			});
  		}

  		if (this._noTilesToLoad()) {
  			this._loading = false;
  			// @event load: Event
  			// Fired when the grid layer loaded all visible tiles.
  			this.fire('load');

  			if (Browser.ielt9 || !this._map._fadeAnimated) {
  				requestAnimFrame(this._pruneTiles, this);
  			} else {
  				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
  				// to trigger a pruning.
  				setTimeout(bind(this._pruneTiles, this), 250);
  			}
  		}
  	},

  	_getTilePos: function (coords) {
  		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
  	},

  	_wrapCoords: function (coords) {
  		var newCoords = new Point(
  			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
  			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
  		newCoords.z = coords.z;
  		return newCoords;
  	},

  	_pxBoundsToTileRange: function (bounds) {
  		var tileSize = this.getTileSize();
  		return new Bounds(
  			bounds.min.unscaleBy(tileSize).floor(),
  			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  	},

  	_noTilesToLoad: function () {
  		for (var key in this._tiles) {
  			if (!this._tiles[key].loaded) { return false; }
  		}
  		return true;
  	}
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
  	return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({

  	// @section
  	// @aka TileLayer options
  	options: {
  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = 18
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: 18,

  		// @option subdomains: String|String[] = 'abc'
  		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
  		subdomains: 'abc',

  		// @option errorTileUrl: String = ''
  		// URL to the tile image to show in place of the tile that failed to load.
  		errorTileUrl: '',

  		// @option zoomOffset: Number = 0
  		// The zoom number used in tile URLs will be offset with this value.
  		zoomOffset: 0,

  		// @option tms: Boolean = false
  		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
  		tms: false,

  		// @option zoomReverse: Boolean = false
  		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
  		zoomReverse: false,

  		// @option detectRetina: Boolean = false
  		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
  		detectRetina: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option referrerPolicy: Boolean|String = false
  		// Whether the referrerPolicy attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
  		// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
  		// (e.g. to validate an API token).
  		// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
  		referrerPolicy: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		options = setOptions(this, options);

  		// detecting retina displays, adjusting tileSize and zoom levels
  		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

  			options.tileSize = Math.floor(options.tileSize / 2);

  			if (!options.zoomReverse) {
  				options.zoomOffset++;
  				options.maxZoom--;
  			} else {
  				options.zoomOffset--;
  				options.minZoom++;
  			}

  			options.minZoom = Math.max(0, options.minZoom);
  		}

  		if (typeof options.subdomains === 'string') {
  			options.subdomains = options.subdomains.split('');
  		}

  		this.on('tileunload', this._onTileRemove);
  	},

  	// @method setUrl(url: String, noRedraw?: Boolean): this
  	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
  	// If the URL does not change, the layer will not be redrawn unless
  	// the noRedraw parameter is set to false.
  	setUrl: function (url, noRedraw) {
  		if (this._url === url && noRedraw === undefined) {
  			noRedraw = true;
  		}

  		this._url = url;

  		if (!noRedraw) {
  			this.redraw();
  		}
  		return this;
  	},

  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
  	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
  	// callback is called when the tile has been loaded.
  	createTile: function (coords, done) {
  		var tile = document.createElement('img');

  		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
  		on(tile, 'error', bind(this._tileOnError, this, done, tile));

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		// for this new option we follow the documented behavior
  		// more closely by only setting the property when string
  		if (typeof this.options.referrerPolicy === 'string') {
  			tile.referrerPolicy = this.options.referrerPolicy;
  		}

  		/*
  		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
  		 https://www.w3.org/TR/WCAG20-TECHS/H67
  		*/
  		tile.alt = '';

  		/*
  		 Set role="presentation" to force screen readers to ignore this
  		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  		*/
  		tile.setAttribute('role', 'presentation');

  		tile.src = this.getTileUrl(coords);

  		return tile;
  	},

  	// @section Extension methods
  	// @uninheritable
  	// Layers extending `TileLayer` might reimplement the following method.
  	// @method getTileUrl(coords: Object): String
  	// Called only internally, returns the URL for a tile given its coordinates.
  	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
  	getTileUrl: function (coords) {
  		var data = {
  			r: Browser.retina ? '@2x' : '',
  			s: this._getSubdomain(coords),
  			x: coords.x,
  			y: coords.y,
  			z: this._getZoomForUrl()
  		};
  		if (this._map && !this._map.options.crs.infinite) {
  			var invertedY = this._globalTileRange.max.y - coords.y;
  			if (this.options.tms) {
  				data['y'] = invertedY;
  			}
  			data['-y'] = invertedY;
  		}

  		return template(this._url, extend(data, this.options));
  	},

  	_tileOnLoad: function (done, tile) {
  		// For https://github.com/Leaflet/Leaflet/issues/3332
  		if (Browser.ielt9) {
  			setTimeout(bind(done, this, null, tile), 0);
  		} else {
  			done(null, tile);
  		}
  	},

  	_tileOnError: function (done, tile, e) {
  		var errorUrl = this.options.errorTileUrl;
  		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
  			tile.src = errorUrl;
  		}
  		done(e, tile);
  	},

  	_onTileRemove: function (e) {
  		e.tile.onload = null;
  	},

  	_getZoomForUrl: function () {
  		var zoom = this._tileZoom,
  		maxZoom = this.options.maxZoom,
  		zoomReverse = this.options.zoomReverse,
  		zoomOffset = this.options.zoomOffset;

  		if (zoomReverse) {
  			zoom = maxZoom - zoom;
  		}

  		return zoom + zoomOffset;
  	},

  	_getSubdomain: function (tilePoint) {
  		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
  		return this.options.subdomains[index];
  	},

  	// stops loading all tiles in the background layer
  	_abortLoading: function () {
  		var i, tile;
  		for (i in this._tiles) {
  			if (this._tiles[i].coords.z !== this._tileZoom) {
  				tile = this._tiles[i].el;

  				tile.onload = falseFn;
  				tile.onerror = falseFn;

  				if (!tile.complete) {
  					tile.src = emptyImageUrl;
  					var coords = this._tiles[i].coords;
  					remove(tile);
  					delete this._tiles[i];
  					// @event tileabort: TileEvent
  					// Fired when a tile was loading but is now not wanted.
  					this.fire('tileabort', {
  						tile: tile,
  						coords: coords
  					});
  				}
  			}
  		}
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		// Cancels any pending http requests associated with the tile
  		tile.el.setAttribute('src', emptyImageUrl);

  		return GridLayer.prototype._removeTile.call(this, key);
  	},

  	_tileReady: function (coords, err, tile) {
  		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
  			return;
  		}

  		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
  	}
  });


  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
  	return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data © 2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({

  	// @section
  	// @aka TileLayer.WMS options
  	// If any custom options not documented here are used, they will be sent to the
  	// WMS server as extra parameters in each request URL. This can be useful for
  	// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
  	defaultWmsParams: {
  		service: 'WMS',
  		request: 'GetMap',

  		// @option layers: String = ''
  		// **(required)** Comma-separated list of WMS layers to show.
  		layers: '',

  		// @option styles: String = ''
  		// Comma-separated list of WMS styles.
  		styles: '',

  		// @option format: String = 'image/jpeg'
  		// WMS image format (use `'image/png'` for layers with transparency).
  		format: 'image/jpeg',

  		// @option transparent: Boolean = false
  		// If `true`, the WMS service will return images with transparency.
  		transparent: false,

  		// @option version: String = '1.1.1'
  		// Version of the WMS service to use
  		version: '1.1.1'
  	},

  	options: {
  		// @option crs: CRS = null
  		// Coordinate Reference System to use for the WMS requests, defaults to
  		// map CRS. Don't change this if you're not sure what it means.
  		crs: null,

  		// @option uppercase: Boolean = false
  		// If `true`, WMS request parameter keys will be uppercase.
  		uppercase: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		var wmsParams = extend({}, this.defaultWmsParams);

  		// all keys that are not TileLayer options go to WMS params
  		for (var i in options) {
  			if (!(i in this.options)) {
  				wmsParams[i] = options[i];
  			}
  		}

  		options = setOptions(this, options);

  		var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
  		var tileSize = this.getTileSize();
  		wmsParams.width = tileSize.x * realRetina;
  		wmsParams.height = tileSize.y * realRetina;

  		this.wmsParams = wmsParams;
  	},

  	onAdd: function (map) {

  		this._crs = this.options.crs || map.options.crs;
  		this._wmsVersion = parseFloat(this.wmsParams.version);

  		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
  		this.wmsParams[projectionKey] = this._crs.code;

  		TileLayer.prototype.onAdd.call(this, map);
  	},

  	getTileUrl: function (coords) {

  		var tileBounds = this._tileCoordsToNwSe(coords),
  		    crs = this._crs,
  		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
  		    min = bounds.min,
  		    max = bounds.max,
  		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
  		    [min.y, min.x, max.y, max.x] :
  		    [min.x, min.y, max.x, max.y]).join(','),
  		    url = TileLayer.prototype.getTileUrl.call(this, coords);
  		return url +
  			getParamString(this.wmsParams, url, this.options.uppercase) +
  			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
  	},

  	// @method setParams(params: Object, noRedraw?: Boolean): this
  	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
  	setParams: function (params, noRedraw) {

  		extend(this.wmsParams, params);

  		if (!noRedraw) {
  			this.redraw();
  		}

  		return this;
  	}
  });


  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
  	return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({

  	// @section
  	// @aka Renderer options
  	options: {
  		// @option padding: Number = 0.1
  		// How much to extend the clip area around the map view (relative to its size)
  		// e.g. 0.1 would be 10% of map view in each direction
  		padding: 0.1
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  		stamp(this);
  		this._layers = this._layers || {};
  	},

  	onAdd: function () {
  		if (!this._container) {
  			this._initContainer(); // defined by renderer implementations

  			if (this._zoomAnimated) {
  				addClass(this._container, 'leaflet-zoom-animated');
  			}
  		}

  		this.getPane().appendChild(this._container);
  		this._update();
  		this.on('update', this._updatePaths, this);
  	},

  	onRemove: function () {
  		this.off('update', this._updatePaths, this);
  		this._destroyContainer();
  	},

  	getEvents: function () {
  		var events = {
  			viewreset: this._reset,
  			zoom: this._onZoom,
  			moveend: this._update,
  			zoomend: this._onZoomEnd
  		};
  		if (this._zoomAnimated) {
  			events.zoomanim = this._onAnimZoom;
  		}
  		return events;
  	},

  	_onAnimZoom: function (ev) {
  		this._updateTransform(ev.center, ev.zoom);
  	},

  	_onZoom: function () {
  		this._updateTransform(this._map.getCenter(), this._map.getZoom());
  	},

  	_updateTransform: function (center, zoom) {
  		var scale = this._map.getZoomScale(zoom, this._zoom),
  		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
  		    currentCenterPoint = this._map.project(this._center, zoom),

  		    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)
  				  .subtract(this._map._getNewPixelOrigin(center, zoom));

  		if (Browser.any3d) {
  			setTransform(this._container, topLeftOffset, scale);
  		} else {
  			setPosition(this._container, topLeftOffset);
  		}
  	},

  	_reset: function () {
  		this._update();
  		this._updateTransform(this._center, this._zoom);

  		for (var id in this._layers) {
  			this._layers[id]._reset();
  		}
  	},

  	_onZoomEnd: function () {
  		for (var id in this._layers) {
  			this._layers[id]._project();
  		}
  	},

  	_updatePaths: function () {
  		for (var id in this._layers) {
  			this._layers[id]._update();
  		}
  	},

  	_update: function () {
  		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
  		// Subclasses are responsible of firing the 'update' event.
  		var p = this.options.padding,
  		    size = this._map.getSize(),
  		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

  		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

  		this._center = this._map.getCenter();
  		this._zoom = this._map.getZoom();
  	}
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({

  	// @section
  	// @aka Canvas options
  	options: {
  		// @option tolerance: Number = 0
  		// How much to extend the click tolerance around a path/object on the map.
  		tolerance: 0
  	},

  	getEvents: function () {
  		var events = Renderer.prototype.getEvents.call(this);
  		events.viewprereset = this._onViewPreReset;
  		return events;
  	},

  	_onViewPreReset: function () {
  		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
  		this._postponeUpdatePaths = true;
  	},

  	onAdd: function () {
  		Renderer.prototype.onAdd.call(this);

  		// Redraw vectors since canvas is cleared upon removal,
  		// in case of removing the renderer itself from the map.
  		this._draw();
  	},

  	_initContainer: function () {
  		var container = this._container = document.createElement('canvas');

  		on(container, 'mousemove', this._onMouseMove, this);
  		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
  		on(container, 'mouseout', this._handleMouseOut, this);
  		container['_leaflet_disable_events'] = true;

  		this._ctx = container.getContext('2d');
  	},

  	_destroyContainer: function () {
  		cancelAnimFrame(this._redrawRequest);
  		delete this._ctx;
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  	},

  	_updatePaths: function () {
  		if (this._postponeUpdatePaths) { return; }

  		var layer;
  		this._redrawBounds = null;
  		for (var id in this._layers) {
  			layer = this._layers[id];
  			layer._update();
  		}
  		this._redraw();
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    container = this._container,
  		    size = b.getSize(),
  		    m = Browser.retina ? 2 : 1;

  		setPosition(container, b.min);

  		// set canvas size (also clearing it); use double size on retina
  		container.width = m * size.x;
  		container.height = m * size.y;
  		container.style.width = size.x + 'px';
  		container.style.height = size.y + 'px';

  		if (Browser.retina) {
  			this._ctx.scale(2, 2);
  		}

  		// translate so we use the same path coordinates after canvas element moves
  		this._ctx.translate(-b.min.x, -b.min.y);

  		// Tell paths to redraw themselves
  		this.fire('update');
  	},

  	_reset: function () {
  		Renderer.prototype._reset.call(this);

  		if (this._postponeUpdatePaths) {
  			this._postponeUpdatePaths = false;
  			this._updatePaths();
  		}
  	},

  	_initPath: function (layer) {
  		this._updateDashArray(layer);
  		this._layers[stamp(layer)] = layer;

  		var order = layer._order = {
  			layer: layer,
  			prev: this._drawLast,
  			next: null
  		};
  		if (this._drawLast) { this._drawLast.next = order; }
  		this._drawLast = order;
  		this._drawFirst = this._drawFirst || this._drawLast;
  	},

  	_addPath: function (layer) {
  		this._requestRedraw(layer);
  	},

  	_removePath: function (layer) {
  		var order = layer._order;
  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			this._drawLast = prev;
  		}
  		if (prev) {
  			prev.next = next;
  		} else {
  			this._drawFirst = next;
  		}

  		delete layer._order;

  		delete this._layers[stamp(layer)];

  		this._requestRedraw(layer);
  	},

  	_updatePath: function (layer) {
  		// Redraw the union of the layer's old pixel
  		// bounds and the new pixel bounds.
  		this._extendRedrawBounds(layer);
  		layer._project();
  		layer._update();
  		// The redraw will extend the redraw bounds
  		// with the new pixel bounds.
  		this._requestRedraw(layer);
  	},

  	_updateStyle: function (layer) {
  		this._updateDashArray(layer);
  		this._requestRedraw(layer);
  	},

  	_updateDashArray: function (layer) {
  		if (typeof layer.options.dashArray === 'string') {
  			var parts = layer.options.dashArray.split(/[, ]+/),
  			    dashArray = [],
  			    dashValue,
  			    i;
  			for (i = 0; i < parts.length; i++) {
  				dashValue = Number(parts[i]);
  				// Ignore dash array containing invalid lengths
  				if (isNaN(dashValue)) { return; }
  				dashArray.push(dashValue);
  			}
  			layer.options._dashArray = dashArray;
  		} else {
  			layer.options._dashArray = layer.options.dashArray;
  		}
  	},

  	_requestRedraw: function (layer) {
  		if (!this._map) { return; }

  		this._extendRedrawBounds(layer);
  		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
  	},

  	_extendRedrawBounds: function (layer) {
  		if (layer._pxBounds) {
  			var padding = (layer.options.weight || 0) + 1;
  			this._redrawBounds = this._redrawBounds || new Bounds();
  			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
  			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
  		}
  	},

  	_redraw: function () {
  		this._redrawRequest = null;

  		if (this._redrawBounds) {
  			this._redrawBounds.min._floor();
  			this._redrawBounds.max._ceil();
  		}

  		this._clear(); // clear layers in redraw bounds
  		this._draw(); // draw layers

  		this._redrawBounds = null;
  	},

  	_clear: function () {
  		var bounds = this._redrawBounds;
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
  		} else {
  			this._ctx.save();
  			this._ctx.setTransform(1, 0, 0, 1, 0, 0);
  			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
  			this._ctx.restore();
  		}
  	},

  	_draw: function () {
  		var layer, bounds = this._redrawBounds;
  		this._ctx.save();
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.beginPath();
  			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
  			this._ctx.clip();
  		}

  		this._drawing = true;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
  				layer._updatePath();
  			}
  		}

  		this._drawing = false;

  		this._ctx.restore();  // Restore state before clipping.
  	},

  	_updatePoly: function (layer, closed) {
  		if (!this._drawing) { return; }

  		var i, j, len2, p,
  		    parts = layer._parts,
  		    len = parts.length,
  		    ctx = this._ctx;

  		if (!len) { return; }

  		ctx.beginPath();

  		for (i = 0; i < len; i++) {
  			for (j = 0, len2 = parts[i].length; j < len2; j++) {
  				p = parts[i][j];
  				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
  			}
  			if (closed) {
  				ctx.closePath();
  			}
  		}

  		this._fillStroke(ctx, layer);

  		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
  	},

  	_updateCircle: function (layer) {

  		if (!this._drawing || layer._empty()) { return; }

  		var p = layer._point,
  		    ctx = this._ctx,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

  		if (s !== 1) {
  			ctx.save();
  			ctx.scale(1, s);
  		}

  		ctx.beginPath();
  		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

  		if (s !== 1) {
  			ctx.restore();
  		}

  		this._fillStroke(ctx, layer);
  	},

  	_fillStroke: function (ctx, layer) {
  		var options = layer.options;

  		if (options.fill) {
  			ctx.globalAlpha = options.fillOpacity;
  			ctx.fillStyle = options.fillColor || options.color;
  			ctx.fill(options.fillRule || 'evenodd');
  		}

  		if (options.stroke && options.weight !== 0) {
  			if (ctx.setLineDash) {
  				ctx.setLineDash(layer.options && layer.options._dashArray || []);
  			}
  			ctx.globalAlpha = options.opacity;
  			ctx.lineWidth = options.weight;
  			ctx.strokeStyle = options.color;
  			ctx.lineCap = options.lineCap;
  			ctx.lineJoin = options.lineJoin;
  			ctx.stroke();
  		}
  	},

  	// Canvas obviously doesn't have mouse events for individual drawn objects,
  	// so we emulate that by calculating what's under the mouse on mousemove/click manually

  	_onClick: function (e) {
  		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {
  					clickedLayer = layer;
  				}
  			}
  		}
  		this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
  	},

  	_onMouseMove: function (e) {
  		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

  		var point = this._map.mouseEventToLayerPoint(e);
  		this._handleMouseHover(e, point);
  	},


  	_handleMouseOut: function (e) {
  		var layer = this._hoveredLayer;
  		if (layer) {
  			// if we're leaving the layer, fire mouseout
  			removeClass(this._container, 'leaflet-interactive');
  			this._fireEvent([layer], e, 'mouseout');
  			this._hoveredLayer = null;
  			this._mouseHoverThrottled = false;
  		}
  	},

  	_handleMouseHover: function (e, point) {
  		if (this._mouseHoverThrottled) {
  			return;
  		}

  		var layer, candidateHoveredLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				candidateHoveredLayer = layer;
  			}
  		}

  		if (candidateHoveredLayer !== this._hoveredLayer) {
  			this._handleMouseOut(e);

  			if (candidateHoveredLayer) {
  				addClass(this._container, 'leaflet-interactive'); // change cursor
  				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
  				this._hoveredLayer = candidateHoveredLayer;
  			}
  		}

  		this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);

  		this._mouseHoverThrottled = true;
  		setTimeout(bind(function () {
  			this._mouseHoverThrottled = false;
  		}, this), 32);
  	},

  	_fireEvent: function (layers, e, type) {
  		this._map._fireDOMEvent(e, type || e.type, layers);
  	},

  	_bringToFront: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			// Already last
  			return;
  		}
  		if (prev) {
  			prev.next = next;
  		} else if (next) {
  			// Update first entry unless this is the
  			// single entry
  			this._drawFirst = next;
  		}

  		order.prev = this._drawLast;
  		this._drawLast.next = order;

  		order.next = null;
  		this._drawLast = order;

  		this._requestRedraw(layer);
  	},

  	_bringToBack: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (prev) {
  			prev.next = next;
  		} else {
  			// Already first
  			return;
  		}
  		if (next) {
  			next.prev = prev;
  		} else if (prev) {
  			// Update last entry unless this is the
  			// single entry
  			this._drawLast = prev;
  		}

  		order.prev = null;

  		order.next = this._drawFirst;
  		this._drawFirst.prev = order;
  		this._drawFirst = order;

  		this._requestRedraw(layer);
  	}
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas(options) {
  	return Browser.canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = (function () {
  	try {
  		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
  		return function (name) {
  			return document.createElement('<lvml:' + name + ' class="lvml">');
  		};
  	} catch (e) {
  		// Do not return fn from catch block so `e` can be garbage collected
  		// See https://github.com/Leaflet/Leaflet/pull/7279
  	}
  	return function (name) {
  		return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
  	};
  })();


  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {

  	_initContainer: function () {
  		this._container = create$1('div', 'leaflet-vml-container');
  	},

  	_update: function () {
  		if (this._map._animatingZoom) { return; }
  		Renderer.prototype._update.call(this);
  		this.fire('update');
  	},

  	_initPath: function (layer) {
  		var container = layer._container = vmlCreate('shape');

  		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

  		container.coordsize = '1 1';

  		layer._path = vmlCreate('path');
  		container.appendChild(layer._path);

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		var container = layer._container;
  		this._container.appendChild(container);

  		if (layer.options.interactive) {
  			layer.addInteractiveTarget(container);
  		}
  	},

  	_removePath: function (layer) {
  		var container = layer._container;
  		remove(container);
  		layer.removeInteractiveTarget(container);
  		delete this._layers[stamp(layer)];
  	},

  	_updateStyle: function (layer) {
  		var stroke = layer._stroke,
  		    fill = layer._fill,
  		    options = layer.options,
  		    container = layer._container;

  		container.stroked = !!options.stroke;
  		container.filled = !!options.fill;

  		if (options.stroke) {
  			if (!stroke) {
  				stroke = layer._stroke = vmlCreate('stroke');
  			}
  			container.appendChild(stroke);
  			stroke.weight = options.weight + 'px';
  			stroke.color = options.color;
  			stroke.opacity = options.opacity;

  			if (options.dashArray) {
  				stroke.dashStyle = isArray(options.dashArray) ?
  				    options.dashArray.join(' ') :
  				    options.dashArray.replace(/( *, *)/g, ' ');
  			} else {
  				stroke.dashStyle = '';
  			}
  			stroke.endcap = options.lineCap.replace('butt', 'flat');
  			stroke.joinstyle = options.lineJoin;

  		} else if (stroke) {
  			container.removeChild(stroke);
  			layer._stroke = null;
  		}

  		if (options.fill) {
  			if (!fill) {
  				fill = layer._fill = vmlCreate('fill');
  			}
  			container.appendChild(fill);
  			fill.color = options.fillColor || options.color;
  			fill.opacity = options.fillOpacity;

  		} else if (fill) {
  			container.removeChild(fill);
  			layer._fill = null;
  		}
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point.round(),
  		    r = Math.round(layer._radius),
  		    r2 = Math.round(layer._radiusY || r);

  		this._setPath(layer, layer._empty() ? 'M0 0' :
  			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
  	},

  	_setPath: function (layer, path) {
  		layer._path.v = path;
  	},

  	_bringToFront: function (layer) {
  		toFront(layer._container);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._container);
  	}
  };

  var create = Browser.vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({

  	_initContainer: function () {
  		this._container = create('svg');

  		// makes it possible to click through svg root; we'll reset it back in individual paths
  		this._container.setAttribute('pointer-events', 'none');

  		this._rootGroup = create('g');
  		this._container.appendChild(this._rootGroup);
  	},

  	_destroyContainer: function () {
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  		delete this._rootGroup;
  		delete this._svgSize;
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    size = b.getSize(),
  		    container = this._container;

  		// set size of svg-container if changed
  		if (!this._svgSize || !this._svgSize.equals(size)) {
  			this._svgSize = size;
  			container.setAttribute('width', size.x);
  			container.setAttribute('height', size.y);
  		}

  		// movement: update container viewBox so that we don't have to change coordinates of individual layers
  		setPosition(container, b.min);
  		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

  		this.fire('update');
  	},

  	// methods below are called by vector layers implementations

  	_initPath: function (layer) {
  		var path = layer._path = create('path');

  		// @namespace Path
  		// @option className: String = null
  		// Custom class name set on an element. Only for SVG renderer.
  		if (layer.options.className) {
  			addClass(path, layer.options.className);
  		}

  		if (layer.options.interactive) {
  			addClass(path, 'leaflet-interactive');
  		}

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		if (!this._rootGroup) { this._initContainer(); }
  		this._rootGroup.appendChild(layer._path);
  		layer.addInteractiveTarget(layer._path);
  	},

  	_removePath: function (layer) {
  		remove(layer._path);
  		layer.removeInteractiveTarget(layer._path);
  		delete this._layers[stamp(layer)];
  	},

  	_updatePath: function (layer) {
  		layer._project();
  		layer._update();
  	},

  	_updateStyle: function (layer) {
  		var path = layer._path,
  		    options = layer.options;

  		if (!path) { return; }

  		if (options.stroke) {
  			path.setAttribute('stroke', options.color);
  			path.setAttribute('stroke-opacity', options.opacity);
  			path.setAttribute('stroke-width', options.weight);
  			path.setAttribute('stroke-linecap', options.lineCap);
  			path.setAttribute('stroke-linejoin', options.lineJoin);

  			if (options.dashArray) {
  				path.setAttribute('stroke-dasharray', options.dashArray);
  			} else {
  				path.removeAttribute('stroke-dasharray');
  			}

  			if (options.dashOffset) {
  				path.setAttribute('stroke-dashoffset', options.dashOffset);
  			} else {
  				path.removeAttribute('stroke-dashoffset');
  			}
  		} else {
  			path.setAttribute('stroke', 'none');
  		}

  		if (options.fill) {
  			path.setAttribute('fill', options.fillColor || options.color);
  			path.setAttribute('fill-opacity', options.fillOpacity);
  			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
  		} else {
  			path.setAttribute('fill', 'none');
  		}
  	},

  	_updatePoly: function (layer, closed) {
  		this._setPath(layer, pointsToPath(layer._parts, closed));
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
  		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

  		// drawing a circle with two half-arcs
  		var d = layer._empty() ? 'M0 0' :
  			'M' + (p.x - r) + ',' + p.y +
  			arc + (r * 2) + ',0 ' +
  			arc + (-r * 2) + ',0 ';

  		this._setPath(layer, d);
  	},

  	_setPath: function (layer, path) {
  		layer._path.setAttribute('d', path);
  	},

  	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
  	_bringToFront: function (layer) {
  		toFront(layer._path);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._path);
  	}
  });

  if (Browser.vml) {
  	SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg(options) {
  	return Browser.svg || Browser.vml ? new SVG(options) : null;
  }

  Map.include({
  	// @namespace Map; @method getRenderer(layer: Path): Renderer
  	// Returns the instance of `Renderer` that should be used to render the given
  	// `Path`. It will ensure that the `renderer` options of the map and paths
  	// are respected, and that the renderers do exist on the map.
  	getRenderer: function (layer) {
  		// @namespace Path; @option renderer: Renderer
  		// Use this specific instance of `Renderer` for this path. Takes
  		// precedence over the map's [default renderer](#map-renderer).
  		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

  		if (!renderer) {
  			renderer = this._renderer = this._createRenderer();
  		}

  		if (!this.hasLayer(renderer)) {
  			this.addLayer(renderer);
  		}
  		return renderer;
  	},

  	_getPaneRenderer: function (name) {
  		if (name === 'overlayPane' || name === undefined) {
  			return false;
  		}

  		var renderer = this._paneRenderers[name];
  		if (renderer === undefined) {
  			renderer = this._createRenderer({pane: name});
  			this._paneRenderers[name] = renderer;
  		}
  		return renderer;
  	},

  	_createRenderer: function (options) {
  		// @namespace Map; @option preferCanvas: Boolean = false
  		// Whether `Path`s should be rendered on a `Canvas` renderer.
  		// By default, all `Path`s are rendered in a `SVG` renderer.
  		return (this.options.preferCanvas && canvas(options)) || svg(options);
  	}
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */


  var Rectangle = Polygon.extend({
  	initialize: function (latLngBounds, options) {
  		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  	},

  	// @method setBounds(latLngBounds: LatLngBounds): this
  	// Redraws the rectangle with the passed bounds.
  	setBounds: function (latLngBounds) {
  		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  	},

  	_boundsToLatLngs: function (latLngBounds) {
  		latLngBounds = toLatLngBounds(latLngBounds);
  		return [
  			latLngBounds.getSouthWest(),
  			latLngBounds.getNorthWest(),
  			latLngBounds.getNorthEast(),
  			latLngBounds.getSouthEast()
  		];
  	}
  });


  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
  	return new Rectangle(latLngBounds, options);
  }

  SVG.create = create;
  SVG.pointsToPath = pointsToPath;

  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option boxZoom: Boolean = true
  	// Whether the map can be zoomed to a rectangular area specified by
  	// dragging the mouse while pressing the shift key.
  	boxZoom: true
  });

  var BoxZoom = Handler.extend({
  	initialize: function (map) {
  		this._map = map;
  		this._container = map._container;
  		this._pane = map._panes.overlayPane;
  		this._resetStateTimeout = 0;
  		map.on('unload', this._destroy, this);
  	},

  	addHooks: function () {
  		on(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	removeHooks: function () {
  		off(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	moved: function () {
  		return this._moved;
  	},

  	_destroy: function () {
  		remove(this._pane);
  		delete this._pane;
  	},

  	_resetState: function () {
  		this._resetStateTimeout = 0;
  		this._moved = false;
  	},

  	_clearDeferredResetState: function () {
  		if (this._resetStateTimeout !== 0) {
  			clearTimeout(this._resetStateTimeout);
  			this._resetStateTimeout = 0;
  		}
  	},

  	_onMouseDown: function (e) {
  		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

  		// Clear the deferred resetState if it hasn't executed yet, otherwise it
  		// will interrupt the interaction and orphan a box element in the container.
  		this._clearDeferredResetState();
  		this._resetState();

  		disableTextSelection();
  		disableImageDrag();

  		this._startPoint = this._map.mouseEventToContainerPoint(e);

  		on(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseMove: function (e) {
  		if (!this._moved) {
  			this._moved = true;

  			this._box = create$1('div', 'leaflet-zoom-box', this._container);
  			addClass(this._container, 'leaflet-crosshair');

  			this._map.fire('boxzoomstart');
  		}

  		this._point = this._map.mouseEventToContainerPoint(e);

  		var bounds = new Bounds(this._point, this._startPoint),
  		    size = bounds.getSize();

  		setPosition(this._box, bounds.min);

  		this._box.style.width  = size.x + 'px';
  		this._box.style.height = size.y + 'px';
  	},

  	_finish: function () {
  		if (this._moved) {
  			remove(this._box);
  			removeClass(this._container, 'leaflet-crosshair');
  		}

  		enableTextSelection();
  		enableImageDrag();

  		off(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseUp: function (e) {
  		if ((e.which !== 1) && (e.button !== 1)) { return; }

  		this._finish();

  		if (!this._moved) { return; }
  		// Postpone to next JS tick so internal click event handling
  		// still see it as "moved".
  		this._clearDeferredResetState();
  		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

  		var bounds = new LatLngBounds(
  		        this._map.containerPointToLatLng(this._startPoint),
  		        this._map.containerPointToLatLng(this._point));

  		this._map
  			.fitBounds(bounds)
  			.fire('boxzoomend', {boxZoomBounds: bounds});
  	},

  	_onKeyDown: function (e) {
  		if (e.keyCode === 27) {
  			this._finish();
  			this._clearDeferredResetState();
  			this._resetState();
  		}
  	}
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
  	// @option doubleClickZoom: Boolean|String = true
  	// Whether the map can be zoomed in by double clicking on it and
  	// zoomed out by double clicking while holding shift. If passed
  	// `'center'`, double-click zoom will zoom to the center of the
  	//  view regardless of where the mouse was.
  	doubleClickZoom: true
  });

  var DoubleClickZoom = Handler.extend({
  	addHooks: function () {
  		this._map.on('dblclick', this._onDoubleClick, this);
  	},

  	removeHooks: function () {
  		this._map.off('dblclick', this._onDoubleClick, this);
  	},

  	_onDoubleClick: function (e) {
  		var map = this._map,
  		    oldZoom = map.getZoom(),
  		    delta = map.options.zoomDelta,
  		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

  		if (map.options.doubleClickZoom === 'center') {
  			map.setZoom(zoom);
  		} else {
  			map.setZoomAround(e.containerPoint, zoom);
  		}
  	}
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option dragging: Boolean = true
  	// Whether the map is draggable with mouse/touch or not.
  	dragging: true,

  	// @section Panning Inertia Options
  	// @option inertia: Boolean = *
  	// If enabled, panning of the map will have an inertia effect where
  	// the map builds momentum while dragging and continues moving in
  	// the same direction for some time. Feels especially nice on touch
  	// devices. Enabled by default.
  	inertia: true,

  	// @option inertiaDeceleration: Number = 3000
  	// The rate with which the inertial movement slows down, in pixels/second².
  	inertiaDeceleration: 3400, // px/s^2

  	// @option inertiaMaxSpeed: Number = Infinity
  	// Max speed of the inertial movement, in pixels/second.
  	inertiaMaxSpeed: Infinity, // px/s

  	// @option easeLinearity: Number = 0.2
  	easeLinearity: 0.2,

  	// TODO refactor, move to CRS
  	// @option worldCopyJump: Boolean = false
  	// With this option enabled, the map tracks when you pan to another "copy"
  	// of the world and seamlessly jumps to the original one so that all overlays
  	// like markers and vector layers are still visible.
  	worldCopyJump: false,

  	// @option maxBoundsViscosity: Number = 0.0
  	// If `maxBounds` is set, this option will control how solid the bounds
  	// are when dragging the map around. The default value of `0.0` allows the
  	// user to drag outside the bounds at normal speed, higher values will
  	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
  	// solid, preventing the user from dragging outside the bounds.
  	maxBoundsViscosity: 0.0
  });

  var Drag = Handler.extend({
  	addHooks: function () {
  		if (!this._draggable) {
  			var map = this._map;

  			this._draggable = new Draggable(map._mapPane, map._container);

  			this._draggable.on({
  				dragstart: this._onDragStart,
  				drag: this._onDrag,
  				dragend: this._onDragEnd
  			}, this);

  			this._draggable.on('predrag', this._onPreDragLimit, this);
  			if (map.options.worldCopyJump) {
  				this._draggable.on('predrag', this._onPreDragWrap, this);
  				map.on('zoomend', this._onZoomEnd, this);

  				map.whenReady(this._onZoomEnd, this);
  			}
  		}
  		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
  		this._draggable.enable();
  		this._positions = [];
  		this._times = [];
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-grab');
  		removeClass(this._map._container, 'leaflet-touch-drag');
  		this._draggable.disable();
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	moving: function () {
  		return this._draggable && this._draggable._moving;
  	},

  	_onDragStart: function () {
  		var map = this._map;

  		map._stop();
  		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
  			var bounds = toLatLngBounds(this._map.options.maxBounds);

  			this._offsetLimit = toBounds(
  				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
  				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
  					.add(this._map.getSize()));

  			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
  		} else {
  			this._offsetLimit = null;
  		}

  		map
  		    .fire('movestart')
  		    .fire('dragstart');

  		if (map.options.inertia) {
  			this._positions = [];
  			this._times = [];
  		}
  	},

  	_onDrag: function (e) {
  		if (this._map.options.inertia) {
  			var time = this._lastTime = +new Date(),
  			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

  			this._positions.push(pos);
  			this._times.push(time);

  			this._prunePositions(time);
  		}

  		this._map
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_prunePositions: function (time) {
  		while (this._positions.length > 1 && time - this._times[0] > 50) {
  			this._positions.shift();
  			this._times.shift();
  		}
  	},

  	_onZoomEnd: function () {
  		var pxCenter = this._map.getSize().divideBy(2),
  		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

  		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
  		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
  	},

  	_viscousLimit: function (value, threshold) {
  		return value - (value - threshold) * this._viscosity;
  	},

  	_onPreDragLimit: function () {
  		if (!this._viscosity || !this._offsetLimit) { return; }

  		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

  		var limit = this._offsetLimit;
  		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
  		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
  		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
  		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

  		this._draggable._newPos = this._draggable._startPos.add(offset);
  	},

  	_onPreDragWrap: function () {
  		// TODO refactor to be able to adjust map pane position after zoom
  		var worldWidth = this._worldWidth,
  		    halfWidth = Math.round(worldWidth / 2),
  		    dx = this._initialWorldOffset,
  		    x = this._draggable._newPos.x,
  		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
  		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
  		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

  		this._draggable._absPos = this._draggable._newPos.clone();
  		this._draggable._newPos.x = newX;
  	},

  	_onDragEnd: function (e) {
  		var map = this._map,
  		    options = map.options,

  		    noInertia = !options.inertia || e.noInertia || this._times.length < 2;

  		map.fire('dragend', e);

  		if (noInertia) {
  			map.fire('moveend');

  		} else {
  			this._prunePositions(+new Date());

  			var direction = this._lastPos.subtract(this._positions[0]),
  			    duration = (this._lastTime - this._times[0]) / 1000,
  			    ease = options.easeLinearity,

  			    speedVector = direction.multiplyBy(ease / duration),
  			    speed = speedVector.distanceTo([0, 0]),

  			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
  			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

  			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
  			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

  			if (!offset.x && !offset.y) {
  				map.fire('moveend');

  			} else {
  				offset = map._limitOffset(offset, map.options.maxBounds);

  				requestAnimFrame(function () {
  					map.panBy(offset, {
  						duration: decelerationDuration,
  						easeLinearity: ease,
  						noMoveStart: true,
  						animate: true
  					});
  				});
  			}
  		}
  	}
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook('addHandler', 'dragging', Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
  	// @option keyboard: Boolean = true
  	// Makes the map focusable and allows users to navigate the map with keyboard
  	// arrows and `+`/`-` keys.
  	keyboard: true,

  	// @option keyboardPanDelta: Number = 80
  	// Amount of pixels to pan when pressing an arrow key.
  	keyboardPanDelta: 80
  });

  var Keyboard = Handler.extend({

  	keyCodes: {
  		left:    [37],
  		right:   [39],
  		down:    [40],
  		up:      [38],
  		zoomIn:  [187, 107, 61, 171],
  		zoomOut: [189, 109, 54, 173]
  	},

  	initialize: function (map) {
  		this._map = map;

  		this._setPanDelta(map.options.keyboardPanDelta);
  		this._setZoomDelta(map.options.zoomDelta);
  	},

  	addHooks: function () {
  		var container = this._map._container;

  		// make the container focusable by tabbing
  		if (container.tabIndex <= 0) {
  			container.tabIndex = '0';
  		}

  		on(container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.on({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	removeHooks: function () {
  		this._removeHooks();

  		off(this._map._container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.off({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	_onMouseDown: function () {
  		if (this._focused) { return; }

  		var body = document.body,
  		    docEl = document.documentElement,
  		    top = body.scrollTop || docEl.scrollTop,
  		    left = body.scrollLeft || docEl.scrollLeft;

  		this._map._container.focus();

  		window.scrollTo(left, top);
  	},

  	_onFocus: function () {
  		this._focused = true;
  		this._map.fire('focus');
  	},

  	_onBlur: function () {
  		this._focused = false;
  		this._map.fire('blur');
  	},

  	_setPanDelta: function (panDelta) {
  		var keys = this._panKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.left.length; i < len; i++) {
  			keys[codes.left[i]] = [-1 * panDelta, 0];
  		}
  		for (i = 0, len = codes.right.length; i < len; i++) {
  			keys[codes.right[i]] = [panDelta, 0];
  		}
  		for (i = 0, len = codes.down.length; i < len; i++) {
  			keys[codes.down[i]] = [0, panDelta];
  		}
  		for (i = 0, len = codes.up.length; i < len; i++) {
  			keys[codes.up[i]] = [0, -1 * panDelta];
  		}
  	},

  	_setZoomDelta: function (zoomDelta) {
  		var keys = this._zoomKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
  			keys[codes.zoomIn[i]] = zoomDelta;
  		}
  		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
  			keys[codes.zoomOut[i]] = -zoomDelta;
  		}
  	},

  	_addHooks: function () {
  		on(document, 'keydown', this._onKeyDown, this);
  	},

  	_removeHooks: function () {
  		off(document, 'keydown', this._onKeyDown, this);
  	},

  	_onKeyDown: function (e) {
  		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

  		var key = e.keyCode,
  		    map = this._map,
  		    offset;

  		if (key in this._panKeys) {
  			if (!map._panAnim || !map._panAnim._inProgress) {
  				offset = this._panKeys[key];
  				if (e.shiftKey) {
  					offset = toPoint(offset).multiplyBy(3);
  				}

  				map.panBy(offset);

  				if (map.options.maxBounds) {
  					map.panInsideBounds(map.options.maxBounds);
  				}
  			}
  		} else if (key in this._zoomKeys) {
  			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

  		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
  			map.closePopup();

  		} else {
  			return;
  		}

  		stop(e);
  	}
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook('addHandler', 'keyboard', Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Mouse wheel options
  	// @option scrollWheelZoom: Boolean|String = true
  	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
  	// it will zoom to the center of the view regardless of where the mouse was.
  	scrollWheelZoom: true,

  	// @option wheelDebounceTime: Number = 40
  	// Limits the rate at which a wheel can fire (in milliseconds). By default
  	// user can't zoom via wheel more often than once per 40 ms.
  	wheelDebounceTime: 40,

  	// @option wheelPxPerZoomLevel: Number = 60
  	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
  	// mean a change of one full zoom level. Smaller values will make wheel-zooming
  	// faster (and vice versa).
  	wheelPxPerZoomLevel: 60
  });

  var ScrollWheelZoom = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'wheel', this._onWheelScroll, this);

  		this._delta = 0;
  	},

  	removeHooks: function () {
  		off(this._map._container, 'wheel', this._onWheelScroll, this);
  	},

  	_onWheelScroll: function (e) {
  		var delta = getWheelDelta(e);

  		var debounce = this._map.options.wheelDebounceTime;

  		this._delta += delta;
  		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

  		if (!this._startTime) {
  			this._startTime = +new Date();
  		}

  		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

  		clearTimeout(this._timer);
  		this._timer = setTimeout(bind(this._performZoom, this), left);

  		stop(e);
  	},

  	_performZoom: function () {
  		var map = this._map,
  		    zoom = map.getZoom(),
  		    snap = this._map.options.zoomSnap || 0;

  		map._stop(); // stop panning and fly animations if any

  		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
  		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
  		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
  		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
  		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

  		this._delta = 0;
  		this._startTime = null;

  		if (!delta) { return; }

  		if (map.options.scrollWheelZoom === 'center') {
  			map.setZoom(zoom + delta);
  		} else {
  			map.setZoomAround(this._lastMousePos, zoom + delta);
  		}
  	}
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

  /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */

  var tapHoldDelay = 600;

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option tapHold: Boolean
  	// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
  	tapHold: Browser.touchNative && Browser.safari && Browser.mobile,

  	// @option tapTolerance: Number = 15
  	// The max number of pixels a user can shift his finger during touch
  	// for it to be considered a valid tap.
  	tapTolerance: 15
  });

  var TapHold = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'touchstart', this._onDown, this);
  	},

  	removeHooks: function () {
  		off(this._map._container, 'touchstart', this._onDown, this);
  	},

  	_onDown: function (e) {
  		clearTimeout(this._holdTimeout);
  		if (e.touches.length !== 1) { return; }

  		var first = e.touches[0];
  		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

  		this._holdTimeout = setTimeout(bind(function () {
  			this._cancel();
  			if (!this._isTapValid()) { return; }

  			// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
  			on(document, 'touchend', preventDefault);
  			on(document, 'touchend touchcancel', this._cancelClickPrevent);
  			this._simulateEvent('contextmenu', first);
  		}, this), tapHoldDelay);

  		on(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		on(document, 'touchmove', this._onMove, this);
  	},

  	_cancelClickPrevent: function cancelClickPrevent() {
  		off(document, 'touchend', preventDefault);
  		off(document, 'touchend touchcancel', cancelClickPrevent);
  	},

  	_cancel: function () {
  		clearTimeout(this._holdTimeout);
  		off(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		off(document, 'touchmove', this._onMove, this);
  	},

  	_onMove: function (e) {
  		var first = e.touches[0];
  		this._newPos = new Point(first.clientX, first.clientY);
  	},

  	_isTapValid: function () {
  		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
  	},

  	_simulateEvent: function (type, e) {
  		var simulatedEvent = new MouseEvent(type, {
  			bubbles: true,
  			cancelable: true,
  			view: window,
  			// detail: 1,
  			screenX: e.screenX,
  			screenY: e.screenY,
  			clientX: e.clientX,
  			clientY: e.clientY,
  			// button: 2,
  			// buttons: 2
  		});

  		simulatedEvent._simulated = true;

  		e.target.dispatchEvent(simulatedEvent);
  	}
  });

  // @section Handlers
  // @property tapHold: Handler
  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
  Map.addInitHook('addHandler', 'tapHold', TapHold);

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option touchZoom: Boolean|String = *
  	// Whether the map can be zoomed by touch-dragging with two fingers. If
  	// passed `'center'`, it will zoom to the center of the view regardless of
  	// where the touch events (fingers) were. Enabled for touch-capable web
  	// browsers.
  	touchZoom: Browser.touch,

  	// @option bounceAtZoomLimits: Boolean = true
  	// Set it to false if you don't want the map to zoom beyond min/max zoom
  	// and then bounce back when pinch-zooming.
  	bounceAtZoomLimits: true
  });

  var TouchZoom = Handler.extend({
  	addHooks: function () {
  		addClass(this._map._container, 'leaflet-touch-zoom');
  		on(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-touch-zoom');
  		off(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	_onTouchStart: function (e) {
  		var map = this._map;
  		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

  		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

  		this._centerPoint = map.getSize()._divideBy(2);
  		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
  		if (map.options.touchZoom !== 'center') {
  			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
  		}

  		this._startDist = p1.distanceTo(p2);
  		this._startZoom = map.getZoom();

  		this._moved = false;
  		this._zooming = true;

  		map._stop();

  		on(document, 'touchmove', this._onTouchMove, this);
  		on(document, 'touchend touchcancel', this._onTouchEnd, this);

  		preventDefault(e);
  	},

  	_onTouchMove: function (e) {
  		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

  		var map = this._map,
  		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
  		    scale = p1.distanceTo(p2) / this._startDist;

  		this._zoom = map.getScaleZoom(scale, this._startZoom);

  		if (!map.options.bounceAtZoomLimits && (
  			(this._zoom < map.getMinZoom() && scale < 1) ||
  			(this._zoom > map.getMaxZoom() && scale > 1))) {
  			this._zoom = map._limitZoom(this._zoom);
  		}

  		if (map.options.touchZoom === 'center') {
  			this._center = this._startLatLng;
  			if (scale === 1) { return; }
  		} else {
  			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
  			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
  			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
  			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
  		}

  		if (!this._moved) {
  			map._moveStart(true, false);
  			this._moved = true;
  		}

  		cancelAnimFrame(this._animRequest);

  		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
  		this._animRequest = requestAnimFrame(moveFn, this, true);

  		preventDefault(e);
  	},

  	_onTouchEnd: function () {
  		if (!this._moved || !this._zooming) {
  			this._zooming = false;
  			return;
  		}

  		this._zooming = false;
  		cancelAnimFrame(this._animRequest);

  		off(document, 'touchmove', this._onTouchMove, this);
  		off(document, 'touchend touchcancel', this._onTouchEnd, this);

  		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
  		if (this._map.options.zoomAnimation) {
  			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
  		} else {
  			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
  		}
  	}
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.TapHold = TapHold;
  Map.TouchZoom = TouchZoom;

  exports.Bounds = Bounds;
  exports.Browser = Browser;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.Circle = Circle;
  exports.CircleMarker = CircleMarker;
  exports.Class = Class;
  exports.Control = Control;
  exports.DivIcon = DivIcon;
  exports.DivOverlay = DivOverlay;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.Draggable = Draggable;
  exports.Evented = Evented;
  exports.FeatureGroup = FeatureGroup;
  exports.GeoJSON = GeoJSON;
  exports.GridLayer = GridLayer;
  exports.Handler = Handler;
  exports.Icon = Icon;
  exports.ImageOverlay = ImageOverlay;
  exports.LatLng = LatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.LineUtil = LineUtil;
  exports.Map = Map;
  exports.Marker = Marker;
  exports.Mixin = Mixin;
  exports.Path = Path;
  exports.Point = Point;
  exports.PolyUtil = PolyUtil;
  exports.Polygon = Polygon;
  exports.Polyline = Polyline;
  exports.Popup = Popup;
  exports.PosAnimation = PosAnimation;
  exports.Projection = index;
  exports.Rectangle = Rectangle;
  exports.Renderer = Renderer;
  exports.SVG = SVG;
  exports.SVGOverlay = SVGOverlay;
  exports.TileLayer = TileLayer;
  exports.Tooltip = Tooltip;
  exports.Transformation = Transformation;
  exports.Util = Util;
  exports.VideoOverlay = VideoOverlay;
  exports.bind = bind;
  exports.bounds = toBounds;
  exports.canvas = canvas;
  exports.circle = circle;
  exports.circleMarker = circleMarker;
  exports.control = control;
  exports.divIcon = divIcon;
  exports.extend = extend;
  exports.featureGroup = featureGroup;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.gridLayer = gridLayer;
  exports.icon = icon;
  exports.imageOverlay = imageOverlay;
  exports.latLng = toLatLng;
  exports.latLngBounds = toLatLngBounds;
  exports.layerGroup = layerGroup;
  exports.map = createMap;
  exports.marker = marker;
  exports.point = toPoint;
  exports.polygon = polygon;
  exports.polyline = polyline;
  exports.popup = popup;
  exports.rectangle = rectangle;
  exports.setOptions = setOptions;
  exports.stamp = stamp;
  exports.svg = svg;
  exports.svgOverlay = svgOverlay;
  exports.tileLayer = tileLayer;
  exports.tooltip = tooltip;
  exports.transformation = toTransformation;
  exports.version = version;
  exports.videoOverlay = videoOverlay;

  var oldL = window.L;
  exports.noConflict = function() {
  	window.L = oldL;
  	return this;
  }
  // Always export us to window global (see #2364)
  window.L = exports;

}));
//# sourceMappingURL=leaflet-src.js.map


/***/ }),

/***/ "../common/addModeChangeHandler.ts":
/*!*****************************************!*\
  !*** ../common/addModeChangeHandler.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addModeChangeHandler": () => (/* binding */ addModeChangeHandler)
/* harmony export */ });
const addModeChangeHandler = (draw, currentSelected) => {
    ["select", "point", "linestring", "polygon", "freehand", "circle"].forEach((mode) => {
        document.getElementById(mode).addEventListener("click", () => {
            currentSelected.mode = mode;
            draw.changeMode(currentSelected.mode);
            if (currentSelected.button) {
                currentSelected.button.style.color = "565656";
            }
            currentSelected.button = document.getElementById(mode);
            currentSelected.button.style.color = "#27ccff";
        });
    });
};


/***/ }),

/***/ "../src/adapters/google-maps.adapter.ts":
/*!**********************************************!*\
  !*** ../src/adapters/google-maps.adapter.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawGoogleMapsAdapter": () => (/* binding */ TerraDrawGoogleMapsAdapter)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "../src/common.ts");
/* harmony import */ var _geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");


class TerraDrawGoogleMapsAdapter {
    constructor(config) {
        this._heldKeys = new Set();
        this._layers = false;
        this._lib = config.lib;
        this._map = config.map;
        this._coordinatePrecision =
            typeof config.coordinatePrecision === "number"
                ? config.coordinatePrecision
                : 9;
        this.getMapContainer = () => {
            return this._map.getDiv();
        };
        this.project = (lng, lat) => {
            const bounds = this._map.getBounds();
            if (bounds === undefined) {
                throw new Error("cannot get bounds");
            }
            const northWest = new this._lib.LatLng(bounds.getNorthEast().lat(), bounds.getSouthWest().lng());
            const projection = this._map.getProjection();
            if (projection === undefined) {
                throw new Error("cannot get projection");
            }
            const projectedNorthWest = projection.fromLatLngToPoint(northWest);
            if (projectedNorthWest === null) {
                throw new Error("cannot get projectedNorthWest");
            }
            const projected = projection.fromLatLngToPoint({ lng, lat });
            if (projected === null) {
                throw new Error("cannot get projected lng lat");
            }
            const zoom = this._map.getZoom();
            if (zoom === undefined) {
                throw new Error("cannot get zoom");
            }
            const scale = Math.pow(2, zoom);
            return {
                x: Math.floor((projected.x - projectedNorthWest.x) * scale),
                y: Math.floor((projected.y - projectedNorthWest.y) * scale),
            };
        };
        this.unproject = (x, y) => {
            const projection = this._map.getProjection();
            if (projection === undefined) {
                throw new Error("cannot get projection");
            }
            const bounds = this._map.getBounds();
            if (bounds === undefined) {
                throw new Error("cannot get bounds");
            }
            const topRight = projection.fromLatLngToPoint(bounds.getNorthEast());
            if (topRight === null) {
                throw new Error("cannot get topRight");
            }
            const bottomLeft = projection.fromLatLngToPoint(bounds.getSouthWest());
            if (bottomLeft === null) {
                throw new Error("cannot get bottomLeft");
            }
            const zoom = this._map.getZoom();
            if (zoom === undefined) {
                throw new Error("zoom get bounds");
            }
            const scale = Math.pow(2, zoom);
            const worldPoint = new google.maps.Point(x / scale + bottomLeft.x, y / scale + topRight.y);
            const lngLat = projection.fromPointToLatLng(worldPoint);
            if (lngLat === null) {
                throw new Error("zoom get bounds");
            }
            return { lng: lngLat.lng(), lat: lngLat.lat() };
        };
        this.setCursor = (cursor) => {
            if (cursor === this._cursor) {
                return;
            }
            if (this._cursorStyleSheet) {
                this._cursorStyleSheet.remove();
                this._cursorStyleSheet = undefined;
            }
            if (cursor !== "unset") {
                // TODO: We could cache these individually per cursor
                const div = this.getMapContainer();
                const style = document.createElement("style");
                style.type = "text/css";
                const selector = `#${div.id} [aria-label="Map"]`;
                style.innerHTML = `${selector} { cursor: ${cursor} !important; }`;
                document.getElementsByTagName("head")[0].appendChild(style);
                this._cursorStyleSheet = style;
            }
            this._cursor = cursor;
        };
    }
    // https://stackoverflow.com/a/27905268/1363484
    circlePath(cx, cy, r) {
        return ("M " +
            cx +
            " " +
            cy +
            " m -" +
            r +
            ", 0 a " +
            r +
            "," +
            r +
            " 0 1,0 " +
            r * 2 +
            ",0 a " +
            r +
            "," +
            r +
            " 0 1,0 -" +
            r * 2 +
            ",0");
    }
    register(callbacks) {
        this._onClickCallback = (event) => {
            if (!event.latLng) {
                return;
            }
            callbacks.onClick({
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latLng.lng(), this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latLng.lat(), this._coordinatePrecision),
                containerX: event.domEvent.clientX - this.getMapContainer().offsetLeft,
                containerY: event.domEvent.clientY - this.getMapContainer().offsetTop,
                button: event.domEvent.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            });
        };
        this._onClickListener = this._map.addListener("click", this._onClickCallback);
        this._onRightClickListener = this._map.addListener("rightclick", this._onClickCallback);
        this._onMouseMoveCallback = (event) => {
            if (!event.latLng) {
                return;
            }
            callbacks.onMouseMove({
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latLng.lng(), this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latLng.lat(), this._coordinatePrecision),
                containerX: event.domEvent.clientX - this.getMapContainer().offsetLeft,
                containerY: event.domEvent.clientY - this.getMapContainer().offsetTop,
                button: event.domEvent.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            });
        };
        this._onMouseMoveListener = this._map.addListener("mousemove", this._onMouseMoveCallback);
        this._onKeyUpListener = (event) => {
            callbacks.onKeyUp({
                key: event.key,
            });
        };
        this.getMapContainer().addEventListener("keyup", this._onKeyUpListener);
        let dragState = "not-dragging";
        this._onDragStartListener = (event) => {
            dragState = "pre-dragging";
        };
        const container = this.getMapContainer();
        container.addEventListener("mousedown", this._onDragStartListener);
        this._onDragListener = (event) => {
            const point = {
                x: event.clientX - container.offsetLeft,
                y: event.clientY - container.offsetTop,
            };
            const { lng, lat } = this.unproject(point.x, point.y);
            const drawEvent = {
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                containerX: event.clientX - container.offsetLeft,
                containerY: event.clientY - container.offsetTop,
                button: event.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            };
            if (dragState === "pre-dragging") {
                dragState = "dragging";
                callbacks.onDragStart(drawEvent, (enabled) => {
                    this._map.setOptions({ draggable: false });
                });
            }
            else if (dragState === "dragging") {
                callbacks.onDrag(drawEvent);
            }
        };
        container.addEventListener("mousemove", this._onDragListener);
        this._onDragEndListener = (event) => {
            if (dragState === "dragging") {
                const point = {
                    x: event.clientX - container.offsetLeft,
                    y: event.clientY - container.offsetTop,
                };
                const { lng, lat } = this.unproject(point.x, point.y);
                callbacks.onDragEnd({
                    lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                    lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                    containerX: event.clientX - container.offsetLeft,
                    containerY: event.clientY - container.offsetTop,
                    button: event.button === 0 ? "left" : "right",
                    heldKeys: [...this._heldKeys],
                }, (enabled) => {
                    this._map.setOptions({ draggable: enabled });
                });
            }
            dragState = "not-dragging";
        };
        container.addEventListener("mouseup", this._onDragEndListener);
    }
    unregister() {
        if (this._onClickListener) {
            this._onClickCallback = undefined;
            this._onClickListener.remove();
            this._onClickListener = undefined;
        }
        if (this._onRightClickListener) {
            this._onClickCallback = undefined;
            this._onRightClickListener.remove();
            this._onRightClickListener = undefined;
        }
        if (this._onMouseMoveListener) {
            this._onMouseMoveCallback = undefined;
            this._onMouseMoveListener.remove();
            this._onMouseMoveListener = undefined;
        }
        if (this._onKeyUpListener) {
            this.getMapContainer().removeEventListener("keyup", this._onKeyUpListener);
            this._onKeyUpListener = undefined;
        }
    }
    render(changes, styling) {
        if (this._layers) {
            changes.deletedIds.forEach((deletedId) => {
                const featureToDelete = this._map.data.getFeatureById(deletedId);
                featureToDelete && this._map.data.remove(featureToDelete);
            });
            changes.updated.forEach((updatedFeature) => {
                if (!updatedFeature || !updatedFeature.id) {
                    throw new Error("Feature is not valid");
                }
                const featureToUpdate = this._map.data.getFeatureById(updatedFeature.id);
                if (!featureToUpdate) {
                    throw new Error("Feature could not be found by Google Maps API");
                }
                // Remove all keys
                featureToUpdate.forEachProperty((property, name) => {
                    featureToUpdate.setProperty(name, undefined);
                });
                // Update all keys
                Object.keys(updatedFeature.properties).forEach((property) => {
                    featureToUpdate.setProperty(property, updatedFeature.properties[property]);
                });
                switch (updatedFeature.geometry.type) {
                    case "Point":
                        {
                            const coordinates = updatedFeature.geometry.coordinates;
                            featureToUpdate.setGeometry(new google.maps.Data.Point(new google.maps.LatLng(coordinates[1], coordinates[0])));
                        }
                        break;
                    case "LineString":
                        {
                            const coordinates = updatedFeature.geometry.coordinates;
                            const path = [];
                            for (let i = 0; i < coordinates.length; i++) {
                                const coordinate = coordinates[i];
                                const latLng = new google.maps.LatLng(coordinate[1], coordinate[0]);
                                path.push(latLng);
                            }
                            featureToUpdate.setGeometry(new google.maps.Data.LineString(path));
                        }
                        break;
                    case "Polygon":
                        {
                            const coordinates = updatedFeature.geometry.coordinates;
                            const paths = [];
                            for (let i = 0; i < coordinates.length; i++) {
                                const path = [];
                                for (let j = 0; j < coordinates[i].length; j++) {
                                    const latLng = new google.maps.LatLng(coordinates[i][j][1], coordinates[i][j][0]);
                                    path.push(latLng);
                                }
                                paths.push(path);
                            }
                            featureToUpdate.setGeometry(new google.maps.Data.Polygon(paths));
                        }
                        break;
                }
            });
            // Create new features
            changes.created.forEach((createdFeature) => {
                this._map.data.addGeoJson(createdFeature);
            });
        }
        else {
            // Clicking on data geometries triggers
            // swallows the map onclick event,
            // so we need to forward it to the click callback handler
            this._map.data.addListener("click", (event) => {
                this._onClickCallback && this._onClickCallback(event);
            });
            this._map.data.addListener("mousemove", (event) => {
                this._onMouseMoveCallback && this._onMouseMoveCallback(event);
            });
        }
        const featureCollection = {
            type: "FeatureCollection",
            features: [...changes.created],
        };
        this._map.data.addGeoJson(featureCollection);
        this._map.data.setStyle((feature) => {
            const mode = feature.getProperty("mode");
            const gmGeometry = feature.getGeometry();
            if (!gmGeometry) {
                throw new Error("Google Maps geometry not found");
            }
            const type = gmGeometry.getType();
            const selected = feature.getProperty(_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED);
            const selectionPoint = Boolean(feature.getProperty(_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTION_POINT));
            const midPoint = Boolean(feature.getProperty(_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT));
            switch (type) {
                case "Point":
                    const isSelection = selected || selectionPoint;
                    const isMidpoint = midPoint;
                    return {
                        clickable: false,
                        icon: {
                            path: this.circlePath(0, 0, isSelection
                                ? styling[mode].selectionPointWidth
                                : isMidpoint
                                    ? styling[mode].midPointWidth
                                    : styling[mode].pointWidth),
                            fillColor: isSelection
                                ? styling[mode].selectedColor
                                : isMidpoint
                                    ? styling[mode].midPointColor
                                    : styling[mode].pointColor,
                            fillOpacity: 1,
                            strokeColor: isSelection
                                ? styling[mode].selectedPointOutlineColor
                                : isMidpoint
                                    ? styling[mode].midPointOutlineColor
                                    : undefined,
                            strokeWeight: isSelection || isMidpoint ? 2 : 0,
                            rotation: 0,
                            scale: 1,
                        },
                    };
                case "LineString":
                    return {
                        strokeColor: selected
                            ? styling[mode].selectedColor
                            : styling[mode].lineStringColor,
                        strokeWeight: styling[mode].lineStringWidth,
                    };
                case "Polygon":
                    return {
                        strokeColor: selected
                            ? styling[mode].selectedColor
                            : styling[mode].polygonOutlineColor,
                        strokeWeight: styling[mode].polygonOutlineWidth,
                        fillOpacity: styling[mode].polygonFillOpacity,
                        fillColor: selected
                            ? styling[mode].selectedColor
                            : styling[mode].polygonFillColor,
                    };
            }
            throw Error("Unknown feature type");
        });
        this._layers = true;
    }
}


/***/ }),

/***/ "../src/adapters/leaflet.adapter.ts":
/*!******************************************!*\
  !*** ../src/adapters/leaflet.adapter.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawLeafletAdapter": () => (/* binding */ TerraDrawLeafletAdapter)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "../src/common.ts");
/* harmony import */ var _geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");


class TerraDrawLeafletAdapter {
    constructor(config) {
        this._heldKeys = new Set();
        this._midPointPane = "midPointPane";
        this._selectedPane = "selectedPane";
        this._lib = config.lib;
        this._map = config.map;
        this._coordinatePrecision =
            typeof config.coordinatePrecision === "number"
                ? config.coordinatePrecision
                : 9;
        this.getMapContainer = () => {
            return this._map.getContainer();
        };
        this.project = (lng, lat) => {
            const { x, y } = this._map.latLngToContainerPoint({ lng, lat });
            return { x, y };
        };
        this.unproject = (x, y) => {
            const { lng, lat } = this._map.containerPointToLatLng({
                x,
                y,
            });
            return { lng, lat };
        };
        this.setCursor = (cursor) => {
            if (cursor === "unset") {
                this.getMapContainer().style.removeProperty("cursor");
            }
            else {
                this.getMapContainer().style.cursor = cursor;
            }
        };
    }
    createPaneStyleSheet(pane, zIndex) {
        const style = document.createElement("style");
        style.type = "text/css";
        style.innerHTML = `.leaflet-${pane} {z-index: ${zIndex};}`;
        document.getElementsByTagName("head")[0].appendChild(style);
        this._map.createPane(pane);
        return style;
    }
    register(callbacks) {
        if (!this._selectionPaneZIndexStyleSheet) {
            this._selectionPaneZIndexStyleSheet = this.createPaneStyleSheet(this._selectedPane, 10);
        }
        if (!this._midPointPaneZIndexStyleSheet) {
            this._midPointPaneZIndexStyleSheet = this.createPaneStyleSheet(this._midPointPane, 20);
        }
        const container = this.getMapContainer();
        let dragState = "not-dragging";
        this._onClickListener = (event) => {
            if (dragState === "not-dragging" || dragState === "pre-dragging") {
                callbacks.onClick({
                    lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latlng.lng, this._coordinatePrecision),
                    lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latlng.lat, this._coordinatePrecision),
                    containerX: event.originalEvent.clientX - this.getMapContainer().offsetLeft,
                    containerY: event.originalEvent.clientY - this.getMapContainer().offsetTop,
                    button: event.originalEvent.button === 0 ? "left" : "right",
                    heldKeys: [...this._heldKeys],
                });
            }
        };
        // We can't use 'click' here because it triggers
        // after drag end in Leaflet for some reason
        this._map.on("mouseup", this._onClickListener);
        this._map.on("contextmenu", this._onClickListener);
        this._onMouseMoveListener = (event) => {
            event.originalEvent.preventDefault();
            callbacks.onMouseMove({
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latlng.lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.latlng.lat, this._coordinatePrecision),
                containerX: event.originalEvent.clientX - this.getMapContainer().offsetLeft,
                containerY: event.originalEvent.clientY - this.getMapContainer().offsetTop,
                button: event.originalEvent.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            });
        };
        this._map.on("mousemove", this._onMouseMoveListener);
        this._onDragStartListener = (event) => {
            dragState = "pre-dragging";
        };
        container.addEventListener("pointerdown", this._onDragStartListener);
        this._onDragListener = (event) => {
            const point = {
                x: event.clientX - container.offsetLeft,
                y: event.clientY - container.offsetTop,
            };
            const { lng, lat } = this._map.containerPointToLatLng(point);
            const drawEvent = {
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                containerX: event.clientX - container.offsetLeft,
                containerY: event.clientY - container.offsetTop,
                button: event.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            };
            if (dragState === "pre-dragging") {
                dragState = "dragging";
                callbacks.onDragStart(drawEvent, (enabled) => {
                    if (enabled) {
                        this._map.dragging.enable();
                    }
                    else {
                        this._map.dragging.disable();
                    }
                });
            }
            else if (dragState === "dragging") {
                callbacks.onDrag(drawEvent);
            }
        };
        container.addEventListener("pointermove", this._onDragListener);
        this._onDragEndListener = (event) => {
            event.preventDefault();
            if (dragState === "dragging") {
                const point = {
                    x: event.clientX - container.offsetLeft,
                    y: event.clientY - container.offsetTop,
                };
                const { lng, lat } = this._map.containerPointToLatLng(point);
                callbacks.onDragEnd({
                    lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                    lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                    containerX: event.clientX - container.offsetLeft,
                    containerY: event.clientY - container.offsetTop,
                    button: event.button === 0 ? "left" : "right",
                    heldKeys: [...this._heldKeys],
                }, (enabled) => {
                    if (enabled) {
                        this._map.dragging.enable();
                    }
                    else {
                        this._map.dragging.disable();
                    }
                });
                // We want to avoid triggering an click
                // event after dragging
                dragState = "after-dragging";
                this._map.dragging.enable();
                return;
            }
            dragState = "not-dragging";
            this._map.dragging.enable();
        };
        container.addEventListener("pointerup", this._onDragEndListener);
        // map has no keypress event, so we add one to the canvas itself
        this._onKeyUpListener = (event) => {
            event.preventDefault();
            this._heldKeys.delete(event.key);
            callbacks.onKeyUp({
                key: event.key,
            });
        };
        container.addEventListener("keyup", this._onKeyUpListener);
        this._onKeyDownListener = (event) => {
            event.preventDefault();
            this._heldKeys.add(event.key);
            callbacks.onKeyDown({
                key: event.key,
            });
        };
        container.addEventListener("keydown", this._onKeyDownListener);
    }
    unregister() {
        if (this._onClickListener) {
            this._map.off("contextmenu", this._onClickListener);
            this._map.off("click", this._onClickListener);
            this._onClickListener = undefined;
        }
        if (this._onMouseMoveListener) {
            this._map.off("click", this._onClickListener);
            this._onClickListener = undefined;
        }
        const selectedPane = this._map.getPane(this._selectedPane);
        if (selectedPane) {
            selectedPane.remove();
        }
    }
    render(changes, styling) {
        const features = [
            ...changes.created,
            ...changes.updated,
            ...changes.unchanged,
        ];
        if (this._layer) {
            this._map.removeLayer(this._layer);
        }
        const featureCollection = {
            type: "FeatureCollection",
            features,
        };
        const layer = this._lib.geoJSON(featureCollection, {
            // Style points - convert markers to circle markers
            pointToLayer: (feature, latlng) => {
                if (!feature.properties) {
                    throw new Error("Feature has no properties");
                }
                const mode = feature.properties.mode;
                const modeStyle = styling[mode];
                const isSelected = feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED] ||
                    feature.properties.selectionPoint;
                const isMidPoint = feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT];
                const styles = {
                    radius: isSelected
                        ? modeStyle.selectionPointWidth
                        : isMidPoint
                            ? modeStyle.midPointWidth
                            : modeStyle.pointWidth,
                    fillColor: isSelected
                        ? modeStyle.selectedColor
                        : isMidPoint
                            ? modeStyle.midPointColor
                            : modeStyle.pointColor,
                    stroke: isSelected || isMidPoint,
                    color: isSelected
                        ? modeStyle.selectedPointOutlineColor
                        : isMidPoint
                            ? modeStyle.midPointOutlineColor
                            : modeStyle.pointOutlineColor,
                    weight: isSelected || isMidPoint ? 2 : 0,
                    fillOpacity: 0.8,
                    pane: isSelected
                        ? this._selectedPane
                        : isMidPoint
                            ? this._midPointPane
                            : undefined,
                    interactive: false, // Removes mouse hover cursor styles
                };
                const marker = this._lib.circleMarker(latlng, styles);
                return marker;
            },
            // Style LineStrings and Polygons
            style: (feature) => {
                if (!feature || !feature.properties) {
                    return {};
                }
                const mode = feature.properties.mode;
                const modeStyle = styling[mode];
                if (feature.geometry.type === "LineString") {
                    return {
                        interactive: false,
                        color: feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED]
                            ? modeStyle.selectedColor
                            : modeStyle.lineStringColor,
                        weight: modeStyle.lineStringWidth,
                    };
                }
                else if (feature.geometry.type === "Polygon") {
                    return {
                        interactive: false,
                        fillOpacity: modeStyle.polygonFillOpacity,
                        fillColor: feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED]
                            ? modeStyle.selectedColor
                            : modeStyle.polygonFillColor,
                        weight: modeStyle.polygonOutlineWidth,
                        stroke: true,
                        color: feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED]
                            ? modeStyle.selectedColor
                            : modeStyle.polygonOutlineColor,
                    };
                }
                return {};
            },
        });
        this._map.addLayer(layer);
        this._layer = layer;
    }
}


/***/ }),

/***/ "../src/adapters/mapbox-gl.adapter.ts":
/*!********************************************!*\
  !*** ../src/adapters/mapbox-gl.adapter.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawMapboxGLAdapter": () => (/* binding */ TerraDrawMapboxGLAdapter)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ "../src/common.ts");
/* harmony import */ var _geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");


class TerraDrawMapboxGLAdapter {
    constructor(config) {
        this._heldKeys = new Set();
        this._rendered = {};
        this._map = config.map;
        this._coordinatePrecision =
            typeof config.coordinatePrecision === "number"
                ? config.coordinatePrecision
                : 9;
        this.project = (lng, lat) => {
            const { x, y } = this._map.project({ lng, lat });
            return { x, y };
        };
        this.unproject = (x, y) => {
            const { lng, lat } = this._map.unproject({ x, y });
            return { lng, lat };
        };
        this.setCursor = (style) => {
            this._map.getCanvas().style.cursor = style;
        };
        this.getMapContainer = () => {
            return this._map.getContainer();
        };
    }
    _addGeoJSONSource(id, features) {
        this._map.addSource(id, {
            type: "geojson",
            data: {
                type: "FeatureCollection",
                features: features,
            },
        });
    }
    _addFillLayer(id, mode, styling) {
        return this._map.addLayer({
            id,
            source: id,
            type: "fill",
            filter: [
                "all",
                ["match", ["geometry-type"], "Polygon", true, false],
                ["match", ["get", "mode"], mode, true, false],
            ],
            paint: {
                "fill-color": ["get", "polygonFillColor"],
                "fill-opacity": styling.polygonFillOpacity,
            },
        });
    }
    _addFillOutlineLayer(id, mode, styling, beneath) {
        const layer = this._map.addLayer({
            id: id + "outline",
            source: id,
            type: "line",
            filter: [
                "all",
                ["match", ["geometry-type"], "Polygon", true, false],
                ["match", ["get", "mode"], mode, true, false],
            ],
            paint: {
                "line-width": styling.polygonOutlineWidth,
                "line-color": ["get", "polygonOutlineColor"],
            },
        });
        if (beneath) {
            this._map.moveLayer(id, beneath);
        }
        return layer;
    }
    _addLineLayer(id, mode, styling, beneath) {
        const layer = this._map.addLayer({
            id,
            source: id,
            type: "line",
            filter: [
                "all",
                ["match", ["geometry-type"], "LineString", true, false],
                ["match", ["get", "mode"], mode, true, false],
            ],
            paint: {
                "line-width": styling.lineStringWidth,
                "line-color": ["get", "lineStringColor"],
            },
        });
        if (beneath) {
            this._map.moveLayer(id, beneath);
        }
        return layer;
    }
    _addPointLayer(id, mode, styling, beneath) {
        const layer = this._map.addLayer({
            id,
            source: id,
            type: "circle",
            filter: [
                "all",
                ["match", ["geometry-type"], "Point", true, false],
                ["match", ["get", "mode"], mode, true, false],
            ],
            paint: {
                "circle-stroke-color": ["get", "selectedPointOutlineColor"],
                "circle-stroke-width": 2,
                "circle-radius": ["get", "pointWidth"],
                "circle-color": ["get", "pointColor"],
            },
        });
        if (beneath) {
            this._map.moveLayer(id, beneath);
        }
        return layer;
    }
    _addLayer(id, mode, featureType, styling, beneath) {
        if (featureType === "Point") {
            this._addPointLayer(id, mode, styling, beneath);
        }
        if (featureType === "LineString") {
            this._addLineLayer(id, mode, styling, beneath);
        }
        if (featureType === "Polygon") {
            this._addFillLayer(id, mode, styling);
            this._addFillOutlineLayer(id, mode, styling, beneath);
        }
    }
    _addGeoJSONLayer(mode, featureType, features, styling) {
        const id = `td-${mode}-${featureType.toLowerCase()}`;
        this._addGeoJSONSource(id, features);
        this._addLayer(id, mode, featureType, styling);
        return id;
    }
    _setGeoJSONLayerData(mode, featureType, features) {
        const id = `td-${mode}-${featureType.toLowerCase()}`;
        this._map.getSource(id).setData({
            type: "FeatureCollection",
            features: features,
        });
        return id;
    }
    register(callbacks) {
        this._onClickListener = (event) => {
            callbacks.onClick({
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.lngLat.lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.lngLat.lat, this._coordinatePrecision),
                containerX: event.originalEvent.clientX - this.getMapContainer().offsetLeft,
                containerY: event.originalEvent.clientY - this.getMapContainer().offsetTop,
                button: event.originalEvent.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            });
        };
        this._map.on("click", this._onClickListener);
        this._map.on("contextmenu", this._onClickListener);
        this._onMouseMoveListener = (event) => {
            callbacks.onMouseMove({
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.lngLat.lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(event.lngLat.lat, this._coordinatePrecision),
                containerX: event.originalEvent.clientX - this.getMapContainer().offsetLeft,
                containerY: event.originalEvent.clientY - this.getMapContainer().offsetTop,
                button: event.originalEvent.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            });
        };
        this._map.on("mousemove", this._onMouseMoveListener);
        let dragState = "not-dragging";
        this._onDragStartListener = (event) => {
            dragState = "pre-dragging";
        };
        const container = this.getMapContainer();
        container.addEventListener("mousedown", this._onDragStartListener);
        this._onDragListener = (event) => {
            const { lng, lat } = this._map.unproject({
                x: event.clientX - container.offsetLeft,
                y: event.clientY - container.offsetTop,
            });
            const drawEvent = {
                lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                containerX: event.clientX - container.offsetLeft,
                containerY: event.clientY - container.offsetTop,
                button: event.button === 0 ? "left" : "right",
                heldKeys: [...this._heldKeys],
            };
            if (dragState === "pre-dragging") {
                dragState = "dragging";
                callbacks.onDragStart(drawEvent, (enabled) => {
                    if (enabled) {
                        this._map.dragPan.enable();
                    }
                    else {
                        this._map.dragPan.disable();
                    }
                });
            }
            else if (dragState === "dragging") {
                callbacks.onDrag(drawEvent);
            }
        };
        container.addEventListener("mousemove", this._onDragListener);
        this._onDragEndListener = (event) => {
            if (dragState === "dragging") {
                const point = {
                    x: event.clientX - container.offsetLeft,
                    y: event.clientY - container.offsetTop,
                };
                const { lng, lat } = this._map.unproject(point);
                callbacks.onDragEnd({
                    lng: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lng, this._coordinatePrecision),
                    lat: (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_1__.limitPrecision)(lat, this._coordinatePrecision),
                    containerX: event.clientX - container.offsetLeft,
                    containerY: event.clientY - container.offsetTop,
                    button: event.button === 0 ? "left" : "right",
                    heldKeys: [...this._heldKeys],
                }, (enabled) => {
                    if (enabled) {
                        this._map.dragPan.enable();
                    }
                    else {
                        this._map.dragPan.disable();
                    }
                });
            }
            dragState = "not-dragging";
        };
        container.addEventListener("mouseup", this._onDragEndListener);
        // map has no keypress event, so we add one to the canvas itself
        this._onKeyUpListener = (event) => {
            event.preventDefault();
            this._heldKeys.delete(event.key);
            callbacks.onKeyUp({
                key: event.key,
            });
        };
        container.addEventListener("keyup", this._onKeyUpListener);
        this._onKeyDownListener = (event) => {
            event.preventDefault();
            this._heldKeys.add(event.key);
            callbacks.onKeyDown({
                key: event.key,
            });
        };
        container.addEventListener("keydown", this._onKeyDownListener);
    }
    unregister() {
        if (this._onClickListener) {
            this._map.off("contextmenue", this._onClickListener);
            this._map.off("click", this._onClickListener);
            this._onClickListener = undefined;
        }
        if (this._onMouseMoveListener) {
            this._map.off("mousemove", this._onMouseMoveListener);
            this._onMouseMoveListener = undefined;
        }
        if (this._onKeyUpListener) {
            this._map
                .getCanvas()
                .removeEventListener("keypress", this._onKeyUpListener);
        }
        if (this._onDragStartListener) {
            this._map
                .getCanvas()
                .removeEventListener("mousedown", this._onDragStartListener);
        }
        if (this._onDragListener) {
            this._map
                .getCanvas()
                .removeEventListener("mousemove", this._onDragListener);
        }
        if (this._onDragEndListener) {
            this._map
                .getCanvas()
                .removeEventListener("mouseup", this._onDragEndListener);
        }
    }
    render(changes, styling) {
        const features = [
            ...changes.created,
            ...changes.updated,
            ...changes.unchanged,
        ];
        const modeFeatures = {};
        for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            Object.keys(styling).forEach((mode) => {
                const styles = styling[mode];
                if (feature.properties.mode !== mode) {
                    return;
                }
                if (!modeFeatures[mode]) {
                    modeFeatures[mode] = {
                        points: [],
                        linestrings: [],
                        polygons: [],
                    };
                }
                if (feature.geometry.type === "Point") {
                    if (feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED] ||
                        feature.properties.selectionPoint) {
                        feature.properties.pointColor = styles.selectedColor;
                        feature.properties.selectedPointOutlineColor =
                            styles.selectedPointOutlineColor;
                        feature.properties.pointWidth = styles.selectionPointWidth;
                    }
                    else if (feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT]) {
                        feature.properties.pointColor = styles.midPointColor;
                        feature.properties.selectedPointOutlineColor =
                            styles.midPointOutlineColor;
                        feature.properties.pointWidth = styles.midPointWidth;
                    }
                    else {
                        feature.properties.pointColor = styles.pointColor;
                        feature.properties.selectedPointOutlineColor = styles.pointColor;
                        feature.properties.pointWidth = styles.pointWidth;
                    }
                    modeFeatures[mode].points.push(feature);
                }
                else if (feature.geometry.type === "LineString") {
                    if (feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED]) {
                        feature.properties.lineStringColor = styles.selectedColor;
                    }
                    else {
                        feature.properties.lineStringColor = styles.lineStringColor;
                    }
                    modeFeatures[mode].linestrings.push(feature);
                }
                else if (feature.geometry.type === "Polygon") {
                    if (feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED]) {
                        feature.properties.polygonFillColor = styles.selectedColor;
                        feature.properties.polygonOutlineColor = styles.selectedColor;
                    }
                    else {
                        feature.properties.polygonFillColor = styles.polygonFillColor;
                        feature.properties.polygonOutlineColor = styles.polygonOutlineColor;
                    }
                    modeFeatures[mode].polygons.push(feature);
                }
            });
        }
        Object.keys(styling).forEach((mode) => {
            const styles = styling[mode];
            if (!modeFeatures[mode] || !styles) {
                return;
            }
            const { points, linestrings, polygons } = modeFeatures[mode];
            if (!this._rendered[mode]) {
                this._addGeoJSONLayer(mode, "Point", points, styles);
                this._addGeoJSONLayer(mode, "LineString", linestrings, styles);
                this._addGeoJSONLayer(mode, "Polygon", polygons, styles);
                this._rendered[mode] = true;
            }
            else {
                const pointId = this._setGeoJSONLayerData(mode, "Point", points);
                this._setGeoJSONLayerData(mode, "LineString", linestrings);
                this._setGeoJSONLayerData(mode, "Polygon", polygons);
                // TODO: This logic could be better - I think this will render the selection points above user
                // defined layers outside of TerraDraw which is perhaps unideal
                // Ensure selection/mid points are rendered on top
                this._map.moveLayer(pointId);
            }
        });
    }
}


/***/ }),

/***/ "../src/common.ts":
/*!************************!*\
  !*** ../src/common.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SELECT_PROPERTIES": () => (/* binding */ SELECT_PROPERTIES)
/* harmony export */ });
const SELECT_PROPERTIES = {
    SELECTED: "selected",
    MID_POINT: "midPoint",
    SELECTION_POINT: "selectionPoint",
};


/***/ }),

/***/ "../src/geometry/boolean/point-in-polygon.ts":
/*!***************************************************!*\
  !*** ../src/geometry/boolean/point-in-polygon.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pointInPolygon": () => (/* binding */ pointInPolygon)
/* harmony export */ });
// Based on which-polygon
// https://github.com/mapbox/which-polygon/blob/2eb5b8a427d018ebd964c05acd3b9166c4558b2c/index.js#L81
function pointInPolygon(point, rings) {
    let inside = false;
    for (let i = 0, len = rings.length; i < len; i++) {
        const ring = rings[i];
        for (let j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {
            if (rayIntersect(point, ring[j], ring[k])) {
                inside = !inside;
            }
        }
    }
    return inside;
}
function rayIntersect(p, p1, p2) {
    return (p1[1] > p[1] !== p2[1] > p[1] &&
        p[0] < ((p2[0] - p1[0]) * (p[1] - p1[1])) / (p2[1] - p1[1]) + p1[0]);
}


/***/ }),

/***/ "../src/geometry/boolean/self-intersects.ts":
/*!**************************************************!*\
  !*** ../src/geometry/boolean/self-intersects.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selfIntersects": () => (/* binding */ selfIntersects)
/* harmony export */ });
// Based on - https://github.com/mclaeysb/geojson-polygon-self-intersections
// MIT License
// Copyright (c) 2016 Manuel Claeys Bouuaert
function selfIntersects(feature) {
    const options = {
        epsilon: 0,
        // reportVertexOnVertex: false,
        // reportVertexOnEdge: false,
    };
    let coord;
    if (feature.geometry.type === "Polygon") {
        coord = feature.geometry.coordinates;
    }
    else if (feature.geometry.type === "LineString") {
        coord = [feature.geometry.coordinates];
    }
    else {
        throw new Error("Self intersects only accepts Polygons and LineStrings");
    }
    const output = [];
    const seen = {};
    for (let ring0 = 0; ring0 < coord.length; ring0++) {
        for (let edge0 = 0; edge0 < coord[ring0].length - 1; edge0++) {
            for (let ring1 = 0; ring1 < coord.length; ring1++) {
                for (let edge1 = 0; edge1 < coord[ring1].length - 1; edge1++) {
                    // speedup possible if only interested in unique: start last two loops at ring0 and edge0+1
                    ifInteresctionAddToOutput(ring0, edge0, ring1, edge1);
                }
            }
        }
    }
    return output.length > 0;
    // true if frac is (almost) 1.0 or 0.0
    // function isBoundaryCase(frac: number) {
    //   const e2 = options.epsilon * options.epsilon;
    //   return e2 >= (frac - 1) * (frac - 1) || e2 >= frac * frac;
    // }
    function isOutside(frac) {
        return frac < 0 - options.epsilon || frac > 1 + options.epsilon;
    }
    // Function to check if two edges intersect and add the intersection to the output
    function ifInteresctionAddToOutput(ring0, edge0, ring1, edge1) {
        const start0 = coord[ring0][edge0];
        const end0 = coord[ring0][edge0 + 1];
        const start1 = coord[ring1][edge1];
        const end1 = coord[ring1][edge1 + 1];
        const intersection = intersect(start0, end0, start1, end1);
        if (intersection === null) {
            return; // discard parallels and coincidence
        }
        let frac0;
        let frac1;
        if (end0[0] !== start0[0]) {
            frac0 = (intersection[0] - start0[0]) / (end0[0] - start0[0]);
        }
        else {
            frac0 = (intersection[1] - start0[1]) / (end0[1] - start0[1]);
        }
        if (end1[0] !== start1[0]) {
            frac1 = (intersection[0] - start1[0]) / (end1[0] - start1[0]);
        }
        else {
            frac1 = (intersection[1] - start1[1]) / (end1[1] - start1[1]);
        }
        // There are roughly three cases we need to deal with.
        // 1. If at least one of the fracs lies outside [0,1], there is no intersection.
        if (isOutside(frac0) || isOutside(frac1)) {
            return; // require segment intersection
        }
        // 2. If both are either exactly 0 or exactly 1, this is not an intersection but just
        // two edge segments sharing a common vertex.
        // if (isBoundaryCase(frac0) && isBoundaryCase(frac1)) {
        //   if (!options.reportVertexOnVertex) {
        //     return;
        //   }
        // }
        // // 3. If only one of the fractions is exactly 0 or 1, this is
        // // a vertex-on-edge situation.
        // if (isBoundaryCase(frac0) || isBoundaryCase(frac1)) {
        //   if (!options.reportVertexOnEdge) {
        //     return;
        //   }
        // }
        const key = intersection.toString();
        const unique = !seen[key];
        if (unique) {
            seen[key] = true;
        }
        output.push(intersection);
    }
}
function equalArrays(array1, array2) {
    return array1[0] === array2[0] && array1[1] === array2[1];
}
// Function to compute where two lines (not segments) intersect. From https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
function intersect(start0, end0, start1, end1) {
    if (equalArrays(start0, start1) ||
        equalArrays(start0, end1) ||
        equalArrays(end0, start1) ||
        equalArrays(end1, start1)) {
        return null;
    }
    const x0 = start0[0], y0 = start0[1], x1 = end0[0], y1 = end0[1], x2 = start1[0], y2 = start1[1], x3 = end1[0], y3 = end1[1];
    const denom = (x0 - x1) * (y2 - y3) - (y0 - y1) * (x2 - x3);
    if (denom === 0) {
        return null;
    }
    const x4 = ((x0 * y1 - y0 * x1) * (x2 - x3) - (x0 - x1) * (x2 * y3 - y2 * x3)) / denom;
    const y4 = ((x0 * y1 - y0 * x1) * (y2 - y3) - (y0 - y1) * (x2 * y3 - y2 * x3)) / denom;
    return [x4, y4];
}


/***/ }),

/***/ "../src/geometry/centroid.ts":
/*!***********************************!*\
  !*** ../src/geometry/centroid.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "centroid": () => (/* binding */ centroid)
/* harmony export */ });
function centroid(geojson) {
    let xSum = 0;
    let ySum = 0;
    let len = 0;
    const coordinates = geojson.geometry.type === "Polygon"
        ? geojson.geometry.coordinates[0].slice(0, -1)
        : geojson.geometry.coordinates;
    coordinates.forEach((coord) => {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return [xSum / len, ySum / len];
}


/***/ }),

/***/ "../src/geometry/get-coordinates-as-points.ts":
/*!****************************************************!*\
  !*** ../src/geometry/get-coordinates-as-points.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCoordinatesAsPoints": () => (/* binding */ getCoordinatesAsPoints)
/* harmony export */ });
function getCoordinatesAsPoints(selectedCoords, geometryType, properties) {
    const selectionPoints = [];
    // We can skip the last point for polygons
    // as it's a duplicate of the first
    const length = geometryType === "Polygon"
        ? selectedCoords.length - 1
        : selectedCoords.length;
    for (let i = 0; i < length; i++) {
        selectionPoints.push({
            geometry: {
                type: "Point",
                coordinates: selectedCoords[i],
            },
            properties: properties(i),
        });
    }
    return selectionPoints;
}


/***/ }),

/***/ "../src/geometry/get-midpoints.ts":
/*!****************************************!*\
  !*** ../src/geometry/get-midpoints.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMidPointCoordinates": () => (/* binding */ getMidPointCoordinates),
/* harmony export */   "getMidPoints": () => (/* binding */ getMidPoints)
/* harmony export */ });
/* harmony import */ var _midpoint_coordinate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./midpoint-coordinate */ "../src/geometry/midpoint-coordinate.ts");

function getMidPointCoordinates(featureCoords, precision) {
    const midPointCoords = [];
    for (let i = 0; i < featureCoords.length - 1; i++) {
        const mid = (0,_midpoint_coordinate__WEBPACK_IMPORTED_MODULE_0__.midpointCoordinate)(featureCoords[i], featureCoords[i + 1], precision);
        midPointCoords.push(mid);
    }
    return midPointCoords;
}
function getMidPoints(selectedCoords, properties, precision) {
    return getMidPointCoordinates(selectedCoords, precision).map((coord, i) => ({
        geometry: { type: "Point", coordinates: coord },
        properties: properties(i),
    }));
}


/***/ }),

/***/ "../src/geometry/helpers.ts":
/*!**********************************!*\
  !*** ../src/geometry/helpers.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "degreesToRadians": () => (/* binding */ degreesToRadians),
/* harmony export */   "earthRadius": () => (/* binding */ earthRadius),
/* harmony export */   "lengthToRadians": () => (/* binding */ lengthToRadians),
/* harmony export */   "radiansToDegrees": () => (/* binding */ radiansToDegrees)
/* harmony export */ });
const earthRadius = 6371008.8;
function degreesToRadians(degrees) {
    const radians = degrees % 360;
    return (radians * Math.PI) / 180;
}
function lengthToRadians(distance) {
    const factor = earthRadius / 1000;
    return distance / factor;
}
function radiansToDegrees(radians) {
    const degrees = radians % (2 * Math.PI);
    return (degrees * 180) / Math.PI;
}


/***/ }),

/***/ "../src/geometry/identical-coordinates.ts":
/*!************************************************!*\
  !*** ../src/geometry/identical-coordinates.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coordinatesIdentical": () => (/* binding */ coordinatesIdentical)
/* harmony export */ });
function coordinatesIdentical(coordinate, coordinateTwo) {
    console.log("proteced?", coordinate[0] === coordinateTwo[0] && coordinate[1] === coordinateTwo[1]);
    return coordinate[0] === coordinateTwo[0] && coordinate[1] === coordinateTwo[1];
}


/***/ }),

/***/ "../src/geometry/limit-decimal-precision.ts":
/*!**************************************************!*\
  !*** ../src/geometry/limit-decimal-precision.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "limitPrecision": () => (/* binding */ limitPrecision)
/* harmony export */ });
function limitPrecision(num, decimalLimit = 9) {
    const decimals = Math.pow(10, decimalLimit);
    return Math.round(num * decimals) / decimals;
}


/***/ }),

/***/ "../src/geometry/measure/haversine-distance.ts":
/*!*****************************************************!*\
  !*** ../src/geometry/measure/haversine-distance.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "haversineDistanceKilometers": () => (/* binding */ haversineDistanceKilometers)
/* harmony export */ });
function haversineDistanceKilometers(pointOne, pointTwo) {
    const toRadians = (latOrLng) => (latOrLng * Math.PI) / 180;
    const phiOne = toRadians(pointOne[1]);
    const lambdaOne = toRadians(pointOne[0]);
    const phiTwo = toRadians(pointTwo[1]);
    const lambdaTwo = toRadians(pointTwo[0]);
    const deltaPhi = phiTwo - phiOne;
    const deltalambda = lambdaTwo - lambdaOne;
    const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
        Math.cos(phiOne) *
            Math.cos(phiTwo) *
            Math.sin(deltalambda / 2) *
            Math.sin(deltalambda / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const radius = 6371e3;
    const distance = radius * c;
    return distance / 1000;
}


/***/ }),

/***/ "../src/geometry/measure/pixel-distance-to-line.ts":
/*!*********************************************************!*\
  !*** ../src/geometry/measure/pixel-distance-to-line.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pixelDistanceToLine": () => (/* binding */ pixelDistanceToLine)
/* harmony export */ });
const pixelDistanceToLine = (point, linePointOne, linePointTwo) => {
    const square = (x) => {
        return x * x;
    };
    const dist2 = (v, w) => {
        return square(v.x - w.x) + square(v.y - w.y);
    };
    const distToSegmentSquared = (p, v, w) => {
        const l2 = dist2(v, w);
        if (l2 === 0) {
            return dist2(p, v);
        }
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
    };
    return Math.sqrt(distToSegmentSquared(point, linePointOne, linePointTwo));
};


/***/ }),

/***/ "../src/geometry/measure/pixel-distance.ts":
/*!*************************************************!*\
  !*** ../src/geometry/measure/pixel-distance.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pixelDistance": () => (/* binding */ pixelDistance)
/* harmony export */ });
const pixelDistance = (pointOne, pointTwo) => {
    const { x: x1, y: y1 } = pointOne;
    const { x: x2, y: y2 } = pointTwo;
    const y = x2 - x1;
    const x = y2 - y1;
    return Math.sqrt(x * x + y * y);
};


/***/ }),

/***/ "../src/geometry/measure/rhumb-bearing.ts":
/*!************************************************!*\
  !*** ../src/geometry/measure/rhumb-bearing.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rhumbBearing": () => (/* binding */ rhumbBearing)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "../src/geometry/helpers.ts");

function rhumbBearing(start, end) {
    const from = start;
    const to = end;
    // φ => phi
    // Δλ => deltaLambda
    // Δψ => deltaPsi
    // θ => theta
    const phi1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(from[1]);
    const phi2 = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(to[1]);
    let deltaLambda = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(to[0] - from[0]);
    // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:
    if (deltaLambda > Math.PI) {
        deltaLambda -= 2 * Math.PI;
    }
    if (deltaLambda < -Math.PI) {
        deltaLambda += 2 * Math.PI;
    }
    const deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const theta = Math.atan2(deltaLambda, deltaPsi);
    const bear360 = ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.radiansToDegrees)(theta) + 360) % 360;
    const bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
    return bear180;
}


/***/ }),

/***/ "../src/geometry/measure/rhumb-destination.ts":
/*!****************************************************!*\
  !*** ../src/geometry/measure/rhumb-destination.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rhumbDestination": () => (/* binding */ rhumbDestination)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "../src/geometry/helpers.ts");

function rhumbDestination(origin, distanceMeters, bearing) {
    const wasNegativeDistance = distanceMeters < 0;
    let distanceInMeters = distanceMeters;
    if (wasNegativeDistance) {
        distanceInMeters = -Math.abs(distanceInMeters);
    }
    const delta = distanceMeters / _helpers__WEBPACK_IMPORTED_MODULE_0__.earthRadius; // angular distance in radians
    const lambda1 = (origin[0] * Math.PI) / 180; // to radians, but without normalize to 𝜋
    const phi1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(origin[1]);
    const theta = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(bearing);
    const DeltaPhi = delta * Math.cos(theta);
    let phi2 = phi1 + DeltaPhi;
    // check for going past the pole, normalise latitude if so
    if (Math.abs(phi2) > Math.PI / 2) {
        phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
    }
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    // E-W course becomes ill-conditioned with 0/0
    const q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    const DeltaLambda = (delta * Math.sin(theta)) / q;
    const lambda2 = lambda1 + DeltaLambda;
    // normalise to −180..+180°
    const destination = [
        (((lambda2 * 180) / Math.PI + 540) % 360) - 180,
        (phi2 * 180) / Math.PI,
    ];
    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
    destination[0] +=
        destination[0] - origin[0] > 180
            ? -360
            : origin[0] - destination[0] > 180
                ? 360
                : 0;
    return destination;
}


/***/ }),

/***/ "../src/geometry/measure/rhumb-distance.ts":
/*!*************************************************!*\
  !*** ../src/geometry/measure/rhumb-distance.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rhumbDistance": () => (/* binding */ rhumbDistance)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "../src/geometry/helpers.ts");

function rhumbDistance(destination, origin) {
    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)
    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678
    destination[0] +=
        destination[0] - origin[0] > 180
            ? -360
            : origin[0] - destination[0] > 180
                ? 360
                : 0;
    // see www.edwilliams.org/avform.htm#Rhumb
    const R = _helpers__WEBPACK_IMPORTED_MODULE_0__.earthRadius;
    const phi1 = (origin[1] * Math.PI) / 180;
    const phi2 = (destination[1] * Math.PI) / 180;
    const DeltaPhi = phi2 - phi1;
    let DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;
    // if dLon over 180° take shorter rhumb line across the anti-meridian:
    if (DeltaLambda > Math.PI) {
        DeltaLambda -= 2 * Math.PI;
    }
    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'
    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it
    const DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
    const q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
    // distance is pythagoras on 'stretched' Mercator projection
    const delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians
    const distanceMeters = delta * R;
    return distanceMeters;
}


/***/ }),

/***/ "../src/geometry/midpoint-coordinate.ts":
/*!**********************************************!*\
  !*** ../src/geometry/midpoint-coordinate.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "midpointCoordinate": () => (/* binding */ midpointCoordinate)
/* harmony export */ });
/* harmony import */ var _shape_create_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape/create-circle */ "../src/geometry/shape/create-circle.ts");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "../src/geometry/helpers.ts");
/* harmony import */ var _limit_decimal_precision__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");
/* harmony import */ var _measure_haversine_distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./measure/haversine-distance */ "../src/geometry/measure/haversine-distance.ts");




function bearing(coordinates1, coordinates2) {
    const lon1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates1[0]);
    const lon2 = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[0]);
    const lat1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates1[1]);
    const lat2 = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[1]);
    const a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    const b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.radiansToDegrees)(Math.atan2(a, b));
}
// Based on turf-midpoint: https://github.com/Turfjs/turf/tree/master/packages/turf-midpoint
function midpointCoordinate(coordinates1, coordinates2, precision) {
    const dist = (0,_measure_haversine_distance__WEBPACK_IMPORTED_MODULE_3__.haversineDistanceKilometers)(coordinates1, coordinates2);
    const heading = bearing(coordinates1, coordinates2);
    const midpoint = (0,_shape_create_circle__WEBPACK_IMPORTED_MODULE_0__.destination)(coordinates1, dist / 2, heading);
    return [
        (0,_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_2__.limitPrecision)(midpoint[0], precision),
        (0,_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_2__.limitPrecision)(midpoint[1], precision),
    ];
}


/***/ }),

/***/ "../src/geometry/shape/create-circle.ts":
/*!**********************************************!*\
  !*** ../src/geometry/shape/create-circle.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circle": () => (/* binding */ circle),
/* harmony export */   "destination": () => (/* binding */ destination)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "../src/geometry/helpers.ts");

// Based on Turf.js Circle module
// https://github.com/Turfjs/turf/blob/master/packages/turf-circle/index.ts
function destination(origin, distance, bearing) {
    const longitude1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(origin[0]);
    const latitude1 = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(origin[1]);
    const bearingRad = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.degreesToRadians)(bearing);
    const radians = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.lengthToRadians)(distance);
    // Main
    const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    const longitude2 = longitude1 +
        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    const lng = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.radiansToDegrees)(longitude2);
    const lat = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.radiansToDegrees)(latitude2);
    return [lng, lat];
}
function circle(options) {
    const { center, radiusKilometers } = options;
    const steps = options.steps ? options.steps : 64;
    const coordinates = [];
    for (let i = 0; i < steps; i++) {
        coordinates.push(destination(center, radiusKilometers, (i * -360) / steps));
    }
    coordinates.push(coordinates[0]);
    return {
        type: "Feature",
        geometry: { type: "Polygon", coordinates: [coordinates] },
        properties: {},
    };
}


/***/ }),

/***/ "../src/geometry/transform/rotate.ts":
/*!*******************************************!*\
  !*** ../src/geometry/transform/rotate.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformRotate": () => (/* binding */ transformRotate)
/* harmony export */ });
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../centroid */ "../src/geometry/centroid.ts");
/* harmony import */ var _measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../measure/rhumb-bearing */ "../src/geometry/measure/rhumb-bearing.ts");
/* harmony import */ var _measure_rhumb_destination__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../measure/rhumb-destination */ "../src/geometry/measure/rhumb-destination.ts");
/* harmony import */ var _measure_rhumb_distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../measure/rhumb-distance */ "../src/geometry/measure/rhumb-distance.ts");




function transformRotate(geojson, angle) {
    // Shortcut no-rotation
    if (angle === 0) {
        return geojson;
    }
    // Use centroid of GeoJSON if pivot is not provided
    const pivot = (0,_centroid__WEBPACK_IMPORTED_MODULE_0__.centroid)(geojson);
    const cooordinates = geojson.geometry.type === "Polygon"
        ? geojson.geometry.coordinates[0]
        : geojson.geometry.coordinates;
    cooordinates.forEach((pointCoords) => {
        const initialAngle = (0,_measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_1__.rhumbBearing)(pivot, pointCoords);
        const finalAngle = initialAngle + angle;
        const distance = (0,_measure_rhumb_distance__WEBPACK_IMPORTED_MODULE_3__.rhumbDistance)(pivot, pointCoords);
        const newCoords = (0,_measure_rhumb_destination__WEBPACK_IMPORTED_MODULE_2__.rhumbDestination)(pivot, distance, finalAngle);
        pointCoords[0] = newCoords[0];
        pointCoords[1] = newCoords[1];
    });
    return geojson;
}


/***/ }),

/***/ "../src/geometry/transform/scale.ts":
/*!******************************************!*\
  !*** ../src/geometry/transform/scale.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transformScale": () => (/* binding */ transformScale)
/* harmony export */ });
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../centroid */ "../src/geometry/centroid.ts");
/* harmony import */ var _measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../measure/rhumb-bearing */ "../src/geometry/measure/rhumb-bearing.ts");
/* harmony import */ var _measure_rhumb_destination__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../measure/rhumb-destination */ "../src/geometry/measure/rhumb-destination.ts");
/* harmony import */ var _measure_rhumb_distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../measure/rhumb-distance */ "../src/geometry/measure/rhumb-distance.ts");




function transformScale(feature, factor) {
    // Shortcut no-scaling
    if (factor === 1) {
        return feature;
    }
    const origin = (0,_centroid__WEBPACK_IMPORTED_MODULE_0__.centroid)(feature);
    const cooordinates = feature.geometry.type === "Polygon"
        ? feature.geometry.coordinates[0]
        : feature.geometry.coordinates;
    cooordinates.forEach((pointCoords) => {
        const originalDistance = (0,_measure_rhumb_distance__WEBPACK_IMPORTED_MODULE_3__.rhumbDistance)(origin, pointCoords);
        const bearing = (0,_measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_1__.rhumbBearing)(origin, pointCoords);
        const newDistance = originalDistance * factor;
        const newCoord = (0,_measure_rhumb_destination__WEBPACK_IMPORTED_MODULE_2__.rhumbDestination)(origin, newDistance, bearing);
        pointCoords[0] = newCoord[0];
        pointCoords[1] = newCoord[1];
    });
    return feature;
}


/***/ }),

/***/ "../src/modes/base.behavior.ts":
/*!*************************************!*\
  !*** ../src/modes/base.behavior.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawModeBehavior": () => (/* binding */ TerraDrawModeBehavior)
/* harmony export */ });
class TerraDrawModeBehavior {
    constructor({ store, mode, project, unproject, pointerDistance, coordinatePrecision, }) {
        this.store = store;
        this.mode = mode;
        this.project = project;
        this.unproject = unproject;
        this.pointerDistance = pointerDistance;
        this.coordinatePrecision = coordinatePrecision;
    }
}


/***/ }),

/***/ "../src/modes/base.mode.ts":
/*!*********************************!*\
  !*** ../src/modes/base.mode.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawBaseDrawMode": () => (/* binding */ TerraDrawBaseDrawMode)
/* harmony export */ });
/* harmony import */ var _util_styling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/styling */ "../src/util/styling.ts");

class TerraDrawBaseDrawMode {
    constructor(options) {
        this.behaviors = [];
        this._state = "unregistered";
        this._styling =
            options && options.styling
                ? Object.assign(Object.assign({}, (0,_util_styling__WEBPACK_IMPORTED_MODULE_0__.getDefaultStyling)()), options.styling) : (0,_util_styling__WEBPACK_IMPORTED_MODULE_0__.getDefaultStyling)();
        this.pointerDistance = (options && options.pointerDistance) || 40;
        this.coordinatePrecision = (options && options.coordinatePrecision) || 9;
    }
    get state() {
        return this._state;
    }
    set state(_) {
        throw new Error("Please use the modes lifecycle methods");
    }
    get styling() {
        return this._styling;
    }
    set styling(styling) {
        if (typeof styling !== "object") {
            throw new Error("Styling must be an object");
        }
        this.onStyleChange([], "styling");
        this._styling = styling;
    }
    registerBehaviors(behaviorConfig) { }
    setStarted() {
        if (this._state === "stopped" || this._state === "registered") {
            this._state = "started";
        }
        else {
            throw new Error("Mode must be unregistered or stopped to start");
        }
    }
    setStopped() {
        if (this._state === "started") {
            this._state = "stopped";
        }
        else {
            throw new Error("Mode must be started to be stopped");
        }
    }
    register(config) {
        if (this._state === "unregistered") {
            this._state = "registered";
            this.store = config.store;
            this.store.registerOnChange(config.onChange);
            this.project = config.project;
            this.unproject = config.unproject;
            this.onSelect = config.onSelect;
            this.onDeselect = config.onDeselect;
            this.setCursor = config.setCursor;
            this.onStyleChange = config.onChange;
            this.registerBehaviors({
                mode: config.mode,
                store: this.store,
                project: this.project,
                unproject: this.unproject,
                pointerDistance: this.pointerDistance,
                coordinatePrecision: this.coordinatePrecision,
            });
        }
        else {
            throw new Error("Can not register unless mode is unregistered");
        }
    }
    onDeselect(deselectedId) { }
    onSelect(selectedId) { }
}


/***/ }),

/***/ "../src/modes/circle/circle.mode.ts":
/*!******************************************!*\
  !*** ../src/modes/circle/circle.mode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawCircleMode": () => (/* binding */ TerraDrawCircleMode)
/* harmony export */ });
/* harmony import */ var _geometry_measure_haversine_distance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/measure/haversine-distance */ "../src/geometry/measure/haversine-distance.ts");
/* harmony import */ var _geometry_shape_create_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry/shape/create-circle */ "../src/geometry/shape/create-circle.ts");
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");



class TerraDrawCircleMode extends _base_mode__WEBPACK_IMPORTED_MODULE_2__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "circle";
        this.clickCount = 0;
        this.keyEvents =
            options && options.keyEvents ? options.keyEvents : { cancel: "Escape" };
    }
    start() {
        this.setStarted();
        this.setCursor("crosshair");
    }
    stop() {
        this.setStopped();
        this.setCursor("unset");
        this.cleanUp();
    }
    onClick(event) {
        if (this.clickCount === 0) {
            this.center = [event.lng, event.lat];
            const startingCircle = (0,_geometry_shape_create_circle__WEBPACK_IMPORTED_MODULE_1__.circle)({
                center: this.center,
                radiusKilometers: 0.00001,
            });
            const [createdId] = this.store.create([
                {
                    geometry: startingCircle.geometry,
                    properties: {
                        mode: this.mode,
                    },
                },
            ]);
            this.currentCircleId = createdId;
            this.clickCount++;
        }
        else {
            // Finish drawing
            this.center = undefined;
            this.currentCircleId = undefined;
            this.clickCount = 0;
        }
    }
    onMouseMove(event) {
        if (this.clickCount === 1 && this.center && this.currentCircleId) {
            const distanceKm = (0,_geometry_measure_haversine_distance__WEBPACK_IMPORTED_MODULE_0__.haversineDistanceKilometers)(this.center, [
                event.lng,
                event.lat,
            ]);
            const updatedCircle = (0,_geometry_shape_create_circle__WEBPACK_IMPORTED_MODULE_1__.circle)({
                center: this.center,
                radiusKilometers: distanceKm,
            });
            this.store.updateGeometry([
                { id: this.currentCircleId, geometry: updatedCircle.geometry },
            ]);
        }
    }
    onKeyDown() { }
    onKeyUp(event) {
        if (event.key === this.keyEvents.cancel) {
            this.cleanUp();
        }
    }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
    cleanUp() {
        try {
            if (this.currentCircleId) {
                this.store.delete([this.currentCircleId]);
            }
        }
        catch (error) { }
        this.center = undefined;
        this.currentCircleId = undefined;
        this.clickCount = 0;
    }
}


/***/ }),

/***/ "../src/modes/click-bounding-box.behavior.ts":
/*!***************************************************!*\
  !*** ../src/modes/click-bounding-box.behavior.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClickBoundingBoxBehavior": () => (/* binding */ ClickBoundingBoxBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.behavior */ "../src/modes/base.behavior.ts");

class ClickBoundingBoxBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config) {
        super(config);
    }
    create(event) {
        const { containerX: x, containerY: y } = event;
        const halfDist = this.pointerDistance / 2;
        const bbox = {
            type: "Feature",
            properties: {},
            geometry: {
                type: "Polygon",
                coordinates: [
                    [
                        this.unproject(x - halfDist, y - halfDist),
                        this.unproject(x + halfDist, y - halfDist),
                        this.unproject(x + halfDist, y + halfDist),
                        this.unproject(x - halfDist, y + halfDist),
                        this.unproject(x - halfDist, y - halfDist), // TopLeft
                    ].map((c) => [c.lng, c.lat]),
                ],
            },
        };
        return bbox;
    }
}


/***/ }),

/***/ "../src/modes/freehand/freehand.mode.ts":
/*!**********************************************!*\
  !*** ../src/modes/freehand/freehand.mode.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawFreehandMode": () => (/* binding */ TerraDrawFreehandMode)
/* harmony export */ });
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");

class TerraDrawFreehandMode extends _base_mode__WEBPACK_IMPORTED_MODULE_0__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "freehand";
        this.startingClick = false;
        this.skip = 0;
        this.everyNthMouseEvent = (options && options.everyNthMouseEvent) || 10;
        this.keyEvents =
            options && options.keyEvents ? options.keyEvents : { cancel: "Escape" };
    }
    start() {
        this.setStarted();
        this.setCursor("crosshair");
    }
    stop() {
        this.setStopped();
        this.setCursor("unset");
        this.cleanUp();
    }
    onMouseMove(event) {
        if (!this.currentId || this.startingClick === false) {
            return;
        }
        if (this.skip > this.everyNthMouseEvent) {
            this.skip = 0;
            const currentLineGeometry = this.store.getGeometryCopy(this.currentId);
            currentLineGeometry.coordinates[0].pop();
            this.store.updateGeometry([
                {
                    id: this.currentId,
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                ...currentLineGeometry.coordinates[0],
                                [event.lng, event.lat],
                                currentLineGeometry.coordinates[0][0],
                            ],
                        ],
                    },
                },
            ]);
        }
        this.skip++;
    }
    onClick(event) {
        if (this.startingClick === false) {
            const [createdId] = this.store.create([
                {
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                            ],
                        ],
                    },
                    properties: { mode: this.mode },
                },
            ]);
            this.currentId = createdId;
            this.startingClick = true;
            return;
        }
        this.startingClick = false;
        this.currentId = undefined;
    }
    onKeyDown() { }
    onKeyUp(event) {
        if (event.key === this.keyEvents.cancel) {
            this.cleanUp();
        }
    }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
    cleanUp() {
        try {
            if (this.currentId) {
                this.store.delete([this.currentId]);
            }
        }
        catch (error) { }
        this.currentId = undefined;
        this.startingClick = false;
    }
}


/***/ }),

/***/ "../src/modes/linestring/linestring.mode.ts":
/*!**************************************************!*\
  !*** ../src/modes/linestring/linestring.mode.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawLineStringMode": () => (/* binding */ TerraDrawLineStringMode)
/* harmony export */ });
/* harmony import */ var _geometry_boolean_self_intersects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/boolean/self-intersects */ "../src/geometry/boolean/self-intersects.ts");
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");
/* harmony import */ var _geometry_measure_pixel_distance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry/measure/pixel-distance */ "../src/geometry/measure/pixel-distance.ts");
/* harmony import */ var _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../click-bounding-box.behavior */ "../src/modes/click-bounding-box.behavior.ts");
/* harmony import */ var _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pixel-distance.behavior */ "../src/modes/pixel-distance.behavior.ts");
/* harmony import */ var _snapping_behavior__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../snapping.behavior */ "../src/modes/snapping.behavior.ts");






class TerraDrawLineStringMode extends _base_mode__WEBPACK_IMPORTED_MODULE_1__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "linestring";
        this.currentCoordinate = 0;
        this.snappingEnabled =
            options && options.snapping !== undefined ? options.snapping : false;
        this.allowSelfIntersections =
            options && options.allowSelfIntersections !== undefined
                ? options.allowSelfIntersections
                : true;
        this.keyEvents =
            options && options.keyEvents ? options.keyEvents : { cancel: "Escape" };
    }
    registerBehaviors(config) {
        this.snapping = new _snapping_behavior__WEBPACK_IMPORTED_MODULE_5__.SnappingBehavior(config, new _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_4__.PixelDistanceBehavior(config), new _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_3__.ClickBoundingBoxBehavior(config));
    }
    start() {
        this.setStarted();
        this.setCursor("crosshair");
    }
    stop() {
        this.setStopped();
        this.setCursor("unset");
        this.cleanUp();
    }
    onMouseMove(event) {
        if (!this.currentId || this.currentCoordinate === 0) {
            return;
        }
        const currentLineGeometry = this.store.getGeometryCopy(this.currentId);
        // Remove the 'live' point that changes on mouse move
        currentLineGeometry.coordinates.pop();
        const snappedCoord = this.snappingEnabled &&
            this.snapping.getSnappableCoordinate(event, this.currentId);
        const updatedCoord = snappedCoord ? snappedCoord : [event.lng, event.lat];
        // Update the 'live' point
        this.store.updateGeometry([
            {
                id: this.currentId,
                geometry: {
                    type: "LineString",
                    coordinates: [...currentLineGeometry.coordinates, updatedCoord],
                },
            },
        ]);
    }
    onClick(event) {
        const snappedCoord = this.currentId &&
            this.snappingEnabled &&
            this.snapping.getSnappableCoordinate(event, this.currentId);
        const updatedCoord = snappedCoord ? snappedCoord : [event.lng, event.lat];
        if (this.currentCoordinate === 0) {
            const [createdId] = this.store.create([
                {
                    geometry: {
                        type: "LineString",
                        coordinates: [
                            updatedCoord,
                            updatedCoord, // This is the 'live' point that changes on mouse move
                        ],
                    },
                    properties: { mode: this.mode },
                },
            ]);
            this.currentId = createdId;
            this.currentCoordinate++;
        }
        else if (this.currentCoordinate === 1 && this.currentId) {
            const currentLineGeometry = this.store.getGeometryCopy(this.currentId);
            this.store.updateGeometry([
                {
                    id: this.currentId,
                    geometry: {
                        type: "LineString",
                        coordinates: [
                            currentLineGeometry.coordinates[0],
                            updatedCoord,
                            updatedCoord,
                        ],
                    },
                },
            ]);
            this.currentCoordinate++;
        }
        else if (this.currentId) {
            const currentLineGeometry = this.store.getGeometryCopy(this.currentId);
            const [previousLng, previousLat] = currentLineGeometry.coordinates[currentLineGeometry.coordinates.length - 2];
            const { x, y } = this.project(previousLng, previousLat);
            const distance = (0,_geometry_measure_pixel_distance__WEBPACK_IMPORTED_MODULE_2__.pixelDistance)({ x, y }, { x: event.containerX, y: event.containerY });
            const isClosingClick = distance < this.pointerDistance;
            if (isClosingClick) {
                // Finish off the drawing
                currentLineGeometry.coordinates.pop();
                this.store.updateGeometry([
                    {
                        id: this.currentId,
                        geometry: {
                            type: "LineString",
                            coordinates: [...currentLineGeometry.coordinates],
                        },
                    },
                ]);
                this.currentCoordinate = 0;
                this.currentId = undefined;
            }
            else {
                // If not close to the final point, keep adding points
                const newLineString = {
                    type: "LineString",
                    coordinates: [...currentLineGeometry.coordinates, updatedCoord],
                };
                if (!this.allowSelfIntersections) {
                    const hasSelfIntersections = (0,_geometry_boolean_self_intersects__WEBPACK_IMPORTED_MODULE_0__.selfIntersects)({
                        type: "Feature",
                        geometry: newLineString,
                        properties: {},
                    });
                    if (hasSelfIntersections) {
                        return;
                    }
                }
                this.store.updateGeometry([
                    { id: this.currentId, geometry: newLineString },
                ]);
                this.currentCoordinate++;
            }
        }
    }
    onKeyDown() { }
    onKeyUp(event) {
        if (event.key === this.keyEvents.cancel) {
            this.cleanUp();
        }
    }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
    cleanUp() {
        try {
            if (this.currentId) {
                this.store.delete([this.currentId]);
            }
        }
        catch (error) { }
        this.currentId = undefined;
        this.currentCoordinate = 0;
    }
}


/***/ }),

/***/ "../src/modes/pixel-distance.behavior.ts":
/*!***********************************************!*\
  !*** ../src/modes/pixel-distance.behavior.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelDistanceBehavior": () => (/* binding */ PixelDistanceBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_measure_pixel_distance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/measure/pixel-distance */ "../src/geometry/measure/pixel-distance.ts");


class PixelDistanceBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config) {
        super(config);
    }
    measure(clickEvent, secondCoordinate) {
        const { x, y } = this.project(secondCoordinate[0], secondCoordinate[1]);
        const distance = (0,_geometry_measure_pixel_distance__WEBPACK_IMPORTED_MODULE_1__.pixelDistance)({ x, y }, { x: clickEvent.containerX, y: clickEvent.containerY });
        return distance;
    }
}


/***/ }),

/***/ "../src/modes/point/point.mode.ts":
/*!****************************************!*\
  !*** ../src/modes/point/point.mode.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawPointMode": () => (/* binding */ TerraDrawPointMode)
/* harmony export */ });
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");

class TerraDrawPointMode extends _base_mode__WEBPACK_IMPORTED_MODULE_0__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "point";
    }
    start() {
        this.setStarted();
        this.setCursor("crosshair");
    }
    stop() {
        this.setStopped();
        this.setCursor("unset");
        this.cleanUp();
    }
    onClick(event) {
        if (!this.store) {
            throw new Error("Mode must be registered first");
        }
        this.store.create([
            {
                geometry: {
                    type: "Point",
                    coordinates: [event.lng, event.lat],
                },
                properties: { mode: this.mode },
            },
        ]);
    }
    onMouseMove() { }
    onKeyDown() { }
    onKeyUp() { }
    cleanUp() { }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
}


/***/ }),

/***/ "../src/modes/polygon/polygon.mode.ts":
/*!********************************************!*\
  !*** ../src/modes/polygon/polygon.mode.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawPolygonMode": () => (/* binding */ TerraDrawPolygonMode)
/* harmony export */ });
/* harmony import */ var _geometry_boolean_self_intersects__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/boolean/self-intersects */ "../src/geometry/boolean/self-intersects.ts");
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");
/* harmony import */ var _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pixel-distance.behavior */ "../src/modes/pixel-distance.behavior.ts");
/* harmony import */ var _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../click-bounding-box.behavior */ "../src/modes/click-bounding-box.behavior.ts");
/* harmony import */ var _util_geoms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/geoms */ "../src/util/geoms.ts");
/* harmony import */ var _snapping_behavior__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../snapping.behavior */ "../src/modes/snapping.behavior.ts");
/* harmony import */ var _geometry_identical_coordinates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geometry/identical-coordinates */ "../src/geometry/identical-coordinates.ts");







class TerraDrawPolygonMode extends _base_mode__WEBPACK_IMPORTED_MODULE_1__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "polygon";
        this.currentCoordinate = 0;
        this.isClosed = false;
        this.snappingEnabled =
            options && options.snapping !== undefined ? options.snapping : false;
        this.allowSelfIntersections =
            options && options.allowSelfIntersections !== undefined
                ? options.allowSelfIntersections
                : true;
        this.keyEvents =
            options && options.keyEvents ? options.keyEvents : { cancel: "Escape" };
    }
    registerBehaviors(config) {
        this.pixelDistance = new _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_2__.PixelDistanceBehavior(config);
        this.snapping = new _snapping_behavior__WEBPACK_IMPORTED_MODULE_5__.SnappingBehavior(config, this.pixelDistance, new _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_3__.ClickBoundingBoxBehavior(config));
    }
    start() {
        this.setStarted();
        this.setCursor("crosshair");
    }
    stop() {
        this.setStopped();
        this.setCursor("unset");
        this.cleanUp();
    }
    onMouseMove(event) {
        this.setCursor("crosshair");
        if (!this.currentId || this.currentCoordinate === 0) {
            return;
        }
        const closestCoord = this.snappingEnabled
            ? this.snapping.getSnappableCoordinate(event, this.currentId)
            : undefined;
        const currentPolygonCoordinates = this.store.getGeometryCopy(this.currentId).coordinates[0];
        if (closestCoord) {
            event.lng = closestCoord[0];
            event.lat = closestCoord[1];
        }
        let updatedCoordinates;
        if (this.currentCoordinate === 1) {
            // We must add a very small epsilon value so that Mapbox GL
            // renders the polygon - There might be a cleaner solution?
            const epsilon = 1 / Math.pow(10, this.coordinatePrecision - 1);
            const offset = Math.max(0.000001, epsilon);
            updatedCoordinates = [
                currentPolygonCoordinates[0],
                [event.lng, event.lat],
                [event.lng, event.lat + offset],
                currentPolygonCoordinates[0],
            ];
        }
        else if (this.currentCoordinate === 2) {
            updatedCoordinates = [
                currentPolygonCoordinates[0],
                currentPolygonCoordinates[1],
                [event.lng, event.lat],
                currentPolygonCoordinates[0],
            ];
        }
        else {
            const distance = this.pixelDistance.measure(event, currentPolygonCoordinates[0]);
            const isClosing = distance < this.pointerDistance;
            if (isClosing) {
                if (!this.isClosed) {
                    updatedCoordinates = [
                        ...currentPolygonCoordinates.slice(0, -2),
                        currentPolygonCoordinates[0],
                        currentPolygonCoordinates[0]
                    ];
                    this.isClosed = true;
                }
                else {
                    updatedCoordinates = [
                        ...currentPolygonCoordinates
                    ];
                }
            }
            else {
                if (this.isClosed) {
                    this.isClosed = false;
                }
                updatedCoordinates = [
                    ...currentPolygonCoordinates.slice(0, -2),
                    [event.lng, event.lat],
                    currentPolygonCoordinates[0],
                ];
            }
        }
        this.store.updateGeometry([
            {
                id: this.currentId,
                geometry: {
                    type: "Polygon",
                    coordinates: [updatedCoordinates],
                },
            },
        ]);
    }
    onClick(event) {
        const closestCoord = this.currentId && this.snappingEnabled
            ? this.snapping.getSnappableCoordinate(event, this.currentId)
            : undefined;
        if (this.currentCoordinate === 0) {
            if (closestCoord) {
                event.lng = closestCoord[0];
                event.lat = closestCoord[1];
            }
            const [newId] = this.store.create([
                {
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                            ],
                        ],
                    },
                    properties: { mode: this.mode },
                },
            ]);
            this.currentId = newId;
            this.currentCoordinate++;
        }
        else if (this.currentCoordinate === 1 && this.currentId) {
            if (closestCoord) {
                event.lng = closestCoord[0];
                event.lat = closestCoord[1];
            }
            const currentPolygonGeometry = this.store.getGeometryCopy(this.currentId);
            const previousCoordinate = currentPolygonGeometry.coordinates[0][0];
            const isIdentical = (0,_geometry_identical_coordinates__WEBPACK_IMPORTED_MODULE_6__.coordinatesIdentical)([event.lng, event.lat], previousCoordinate);
            if (isIdentical) {
                return;
            }
            this.store.updateGeometry([
                {
                    id: this.currentId,
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                currentPolygonGeometry.coordinates[0][0],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                currentPolygonGeometry.coordinates[0][0],
                            ],
                        ],
                    },
                },
            ]);
            this.currentCoordinate++;
        }
        else if (this.currentCoordinate === 2 && this.currentId) {
            if (closestCoord) {
                event.lng = closestCoord[0];
                event.lat = closestCoord[1];
            }
            const currentPolygonGeometry = this.store.getGeometryCopy(this.currentId);
            const previousCoordinate = currentPolygonGeometry.coordinates[0][1];
            const isIdentical = (0,_geometry_identical_coordinates__WEBPACK_IMPORTED_MODULE_6__.coordinatesIdentical)([event.lng, event.lat], previousCoordinate);
            if (isIdentical) {
                return;
            }
            this.store.updateGeometry([
                {
                    id: this.currentId,
                    geometry: {
                        type: "Polygon",
                        coordinates: [
                            [
                                currentPolygonGeometry.coordinates[0][0],
                                currentPolygonGeometry.coordinates[0][1],
                                [event.lng, event.lat],
                                [event.lng, event.lat],
                                currentPolygonGeometry.coordinates[0][0],
                            ],
                        ],
                    },
                },
            ]);
            this.currentCoordinate++;
        }
        else if (this.currentId) {
            const currentPolygonGeometry = this.store.getGeometryCopy(this.currentId);
            const distance = this.pixelDistance.measure(event, currentPolygonGeometry.coordinates[0][0]);
            const isClosingClick = distance < this.pointerDistance;
            if (isClosingClick) {
                this.store.updateGeometry([
                    {
                        id: this.currentId,
                        geometry: {
                            type: "Polygon",
                            coordinates: [
                                [
                                    ...currentPolygonGeometry.coordinates[0].slice(0, -2),
                                    currentPolygonGeometry.coordinates[0][0],
                                ],
                            ],
                        },
                    },
                ]);
                this.currentCoordinate = 0;
                this.currentId = undefined;
            }
            else {
                if (closestCoord) {
                    event.lng = closestCoord[0];
                    event.lat = closestCoord[1];
                }
                const previousCoordinate = currentPolygonGeometry.coordinates[0][this.currentCoordinate - 1];
                const isIdentical = (0,_geometry_identical_coordinates__WEBPACK_IMPORTED_MODULE_6__.coordinatesIdentical)([event.lng, event.lat], previousCoordinate);
                if (isIdentical) {
                    return;
                }
                const updatedPolygon = (0,_util_geoms__WEBPACK_IMPORTED_MODULE_4__.createPolygon)([
                    [
                        ...currentPolygonGeometry.coordinates[0].slice(0, -1),
                        [event.lng, event.lat],
                        currentPolygonGeometry.coordinates[0][0],
                    ],
                ]);
                if (this.currentCoordinate > 2 && !this.allowSelfIntersections) {
                    const hasSelfIntersections = (0,_geometry_boolean_self_intersects__WEBPACK_IMPORTED_MODULE_0__.selfIntersects)(updatedPolygon);
                    if (hasSelfIntersections) {
                        // Don't update the geometry!
                        return;
                    }
                }
                // If not close to the final point, keep adding points
                this.store.updateGeometry([
                    { id: this.currentId, geometry: updatedPolygon.geometry },
                ]);
                this.currentCoordinate++;
            }
        }
    }
    onKeyUp(event) {
        if (event.key === this.keyEvents.cancel) {
            this.cleanUp();
        }
    }
    onKeyDown() { }
    onDragStart() {
        // We want to allow the default drag
        // cursor to exist
        this.setCursor("unset");
    }
    onDrag() { }
    onDragEnd() {
        // Set it back to crosshair
        this.setCursor("crosshair");
    }
    cleanUp() {
        try {
            if (this.currentId) {
                this.store.delete([this.currentId]);
            }
        }
        catch (error) { }
        this.currentId = undefined;
        this.currentCoordinate = 0;
    }
}


/***/ }),

/***/ "../src/modes/render/render.mode.ts":
/*!******************************************!*\
  !*** ../src/modes/render/render.mode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawRenderMode": () => (/* binding */ TerraDrawRenderMode)
/* harmony export */ });
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");

class TerraDrawRenderMode extends _base_mode__WEBPACK_IMPORTED_MODULE_0__.TerraDrawBaseDrawMode {
    constructor(options) {
        super({ styling: options.styling });
        this.mode = "render"; // This gets changed dynamically
    }
    // TODO: this is probably abusing
    // registerBehaviors but it works quite well conceptually
    registerBehaviors(behaviorConfig) {
        // We can set the mode name dynamically
        this.mode = behaviorConfig.mode;
    }
    start() {
        this.setStarted();
    }
    stop() {
        this.setStopped();
    }
    onKeyUp() { }
    onKeyDown() { }
    onClick() { }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
    onMouseMove() { }
}


/***/ }),

/***/ "../src/modes/select/behaviors/drag-coordinate.behavior.ts":
/*!*****************************************************************!*\
  !*** ../src/modes/select/behaviors/drag-coordinate.behavior.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragCoordinateBehavior": () => (/* binding */ DragCoordinateBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");

class DragCoordinateBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, pixelDistance, selectionPoints, midPoints) {
        super(config);
        this.config = config;
        this.pixelDistance = pixelDistance;
        this.selectionPoints = selectionPoints;
        this.midPoints = midPoints;
    }
    drag(event, selectedId) {
        const geometry = this.store.getGeometryCopy(selectedId);
        let geomCoordinates;
        if (geometry.type === "LineString") {
            geomCoordinates = geometry.coordinates;
        }
        else if (geometry.type === "Polygon") {
            geomCoordinates = geometry.coordinates[0];
        }
        else {
            // We don't want to handle dragging
            // points here
            return false;
        }
        const closestCoordinate = {
            dist: Infinity,
            index: -1,
            isFirstOrLastPolygonCoord: false,
        };
        // Look through the selected features coordinates
        // and try to find a coordinate that is draggable
        for (let i = 0; i < geomCoordinates.length; i++) {
            const coord = geomCoordinates[i];
            const distance = this.pixelDistance.measure(event, coord);
            if (distance < this.pointerDistance &&
                distance < closestCoordinate.dist) {
                // We don't create a point for the final
                // polygon coord, so we must set it to the first
                // coordinate instead
                const isFirstOrLastPolygonCoord = geometry.type === "Polygon" &&
                    (i === geomCoordinates.length - 1 || i === 0);
                closestCoordinate.dist = distance;
                closestCoordinate.index = isFirstOrLastPolygonCoord ? 0 : i;
                closestCoordinate.isFirstOrLastPolygonCoord = isFirstOrLastPolygonCoord;
            }
        }
        // No coordinate was within the pointer distance
        if (closestCoordinate.index === -1) {
            return false;
        }
        // Store the updated coord
        const updatedCoordinate = [event.lng, event.lat];
        // We want to update the actual Polygon/LineString itself -
        // for Polygons we want the first and last coordinates to match
        if (closestCoordinate.isFirstOrLastPolygonCoord) {
            const lastCoordIndex = geomCoordinates.length - 1;
            geomCoordinates[0] = updatedCoordinate;
            geomCoordinates[lastCoordIndex] = updatedCoordinate;
        }
        else {
            geomCoordinates[closestCoordinate.index] = updatedCoordinate;
        }
        const updatedSelectionPoint = this.selectionPoints.getOneUpdated(closestCoordinate.index, updatedCoordinate);
        const updatedSelectionPoints = updatedSelectionPoint
            ? [updatedSelectionPoint]
            : [];
        const updatedMidPoints = this.midPoints.getUpdated(geomCoordinates) || [];
        // Apply all the updates
        this.store.updateGeometry([
            // Update feature
            {
                id: selectedId,
                geometry: geometry,
            },
            // Update selection and mid points
            ...updatedSelectionPoints,
            ...updatedMidPoints,
        ]);
        return true;
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/drag-feature.behavior.ts":
/*!**************************************************************!*\
  !*** ../src/modes/select/behaviors/drag-feature.behavior.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DragFeatureBehavior": () => (/* binding */ DragFeatureBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");

class DragFeatureBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, featuresAtMouseEvent, selectionPoints, midPoints) {
        super(config);
        this.config = config;
        this.featuresAtMouseEvent = featuresAtMouseEvent;
        this.selectionPoints = selectionPoints;
        this.midPoints = midPoints;
    }
    get position() {
        return this.dragPosition ? this.dragPosition.concat() : undefined;
    }
    set position(newPosition) {
        if (newPosition === undefined) {
            this.dragPosition = undefined;
            return;
        }
        if (!Array.isArray(newPosition) ||
            newPosition.length !== 2 ||
            typeof newPosition[0] !== "number" ||
            typeof newPosition[1] !== "number") {
            throw new Error("Position must be [number, number] array");
        }
        this.dragPosition = newPosition.concat();
    }
    drag(event, selectedId) {
        const hasSelection = true;
        const { clickedFeature } = this.featuresAtMouseEvent.find(event, hasSelection);
        // If the cursor is not over the selected
        // feature then we don't want to drag
        if (!clickedFeature || clickedFeature.id !== selectedId) {
            return;
        }
        const geometry = this.store.getGeometryCopy(selectedId);
        const mouseCoord = [event.lng, event.lat];
        // Update the geometry of the dragged feature
        if (geometry.type === "Polygon" || geometry.type === "LineString") {
            let updatedCoords;
            let upToCoord;
            if (geometry.type === "Polygon") {
                updatedCoords = geometry.coordinates[0];
                upToCoord = updatedCoords.length - 1;
            }
            else if (geometry.type === "LineString") {
                updatedCoords = geometry.coordinates;
                upToCoord = updatedCoords.length;
            }
            if (upToCoord === undefined || !updatedCoords || !this.dragPosition) {
                return false;
            }
            for (let i = 0; i < upToCoord; i++) {
                const coordinate = updatedCoords[i];
                const delta = [
                    this.dragPosition[0] - mouseCoord[0],
                    this.dragPosition[1] - mouseCoord[1],
                ];
                updatedCoords[i] = [coordinate[0] - delta[0], coordinate[1] - delta[1]];
            }
            // Set final coordinate identical to first
            // We only want to do this for polygons!
            if (geometry.type === "Polygon") {
                updatedCoords[updatedCoords.length - 1] = [
                    updatedCoords[0][0],
                    updatedCoords[0][1],
                ];
            }
            const updatedSelectionPoints = this.selectionPoints.getUpdated(updatedCoords) || [];
            const updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];
            // Issue the update to the selected feature
            this.store.updateGeometry([
                { id: selectedId, geometry },
                ...updatedSelectionPoints,
                ...updatedMidPoints,
            ]);
            // Update mid point positions
        }
        else if (geometry.type === "Point") {
            // For mouse points we can simply move it
            // to the dragged position
            this.store.updateGeometry([
                {
                    id: selectedId,
                    geometry: {
                        type: "Point",
                        coordinates: mouseCoord,
                    },
                },
            ]);
        }
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/features-at-mouse-event.behavior.ts":
/*!*************************************************************************!*\
  !*** ../src/modes/select/behaviors/features-at-mouse-event.behavior.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FeaturesAtMouseEventBehavior": () => (/* binding */ FeaturesAtMouseEventBehavior)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common */ "../src/common.ts");
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../geometry/boolean/point-in-polygon */ "../src/geometry/boolean/point-in-polygon.ts");
/* harmony import */ var _geometry_measure_pixel_distance_to_line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../geometry/measure/pixel-distance-to-line */ "../src/geometry/measure/pixel-distance-to-line.ts");




class FeaturesAtMouseEventBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_1__.TerraDrawModeBehavior {
    constructor(config, createClickBoundingBox, pixelDistance) {
        super(config);
        this.config = config;
        this.createClickBoundingBox = createClickBoundingBox;
        this.pixelDistance = pixelDistance;
    }
    find(event, hasSelection) {
        let clickedFeature = undefined;
        let clickedFeatureDistance = Infinity;
        let clickedMidPoint = undefined;
        let clickedMidPointDistance = Infinity;
        const bbox = this.createClickBoundingBox.create(event);
        const features = this.store.search(bbox);
        for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            const geometry = feature.geometry;
            if (geometry.type === "Point") {
                // Ignore selection points always, and ignore mid points
                // when nothing is selected
                const isSelectionPoint = feature.properties.selectionPoint;
                const isNonSelectedMidPoint = !hasSelection && feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT];
                if (isSelectionPoint || isNonSelectedMidPoint) {
                    continue;
                }
                const distance = this.pixelDistance.measure(event, geometry.coordinates);
                // We want to catch both clicked
                // features but also any midpoints
                // in the clicked area
                if (feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT] &&
                    distance < this.pointerDistance &&
                    distance < clickedMidPointDistance) {
                    clickedMidPointDistance = distance;
                    clickedMidPoint = feature;
                }
                else if (!feature.properties[_common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.MID_POINT] &&
                    distance < this.pointerDistance &&
                    distance < clickedFeatureDistance) {
                    clickedFeatureDistance = distance;
                    clickedFeature = feature;
                }
            }
            else if (geometry.type === "LineString") {
                for (let i = 0; i < geometry.coordinates.length - 1; i++) {
                    const coord = geometry.coordinates[i];
                    const nextCoord = geometry.coordinates[i + 1];
                    const distanceToLine = (0,_geometry_measure_pixel_distance_to_line__WEBPACK_IMPORTED_MODULE_3__.pixelDistanceToLine)({ x: event.containerX, y: event.containerY }, this.project(coord[0], coord[1]), this.project(nextCoord[0], nextCoord[1]));
                    if (distanceToLine < this.pointerDistance &&
                        distanceToLine < clickedFeatureDistance) {
                        clickedFeatureDistance = distanceToLine;
                        clickedFeature = feature;
                    }
                }
            }
            else if (geometry.type === "Polygon") {
                const clickInsidePolygon = (0,_geometry_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_2__.pointInPolygon)([event.lng, event.lat], geometry.coordinates);
                if (clickInsidePolygon) {
                    clickedFeatureDistance = 0;
                    clickedFeature = feature;
                }
            }
        }
        return { clickedFeature, clickedMidPoint };
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/midpoint.behavior.ts":
/*!**********************************************************!*\
  !*** ../src/modes/select/behaviors/midpoint.behavior.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MidPointBehavior": () => (/* binding */ MidPointBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_get_midpoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry/get-midpoints */ "../src/geometry/get-midpoints.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common */ "../src/common.ts");



class MidPointBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, selectionPointBehavior) {
        super(config);
        this.config = config;
        this.selectionPointBehavior = selectionPointBehavior;
        this._midPoints = [];
    }
    get ids() {
        return this._midPoints.concat();
    }
    set ids(_) { }
    insert(midPointId, coordinatePrecision) {
        const midPoint = this.store.getGeometryCopy(midPointId);
        const { midPointFeatureId, midPointSegment } = this.store.getPropertiesCopy(midPointId);
        const geometry = this.store.getGeometryCopy(midPointFeatureId);
        // Update the coordinates to include inserted midpoint
        const updatedCoordinates = geometry.type === "Polygon"
            ? geometry.coordinates[0]
            : geometry.coordinates;
        updatedCoordinates.splice(midPointSegment + 1, 0, midPoint.coordinates);
        // Update geometry coordinates depending
        // on if a polygon or linestring
        geometry.coordinates =
            geometry.type === "Polygon" ? [updatedCoordinates] : updatedCoordinates;
        // Update the selected features geometry to insert
        // the new midpoint
        this.store.updateGeometry([{ id: midPointFeatureId, geometry }]);
        // TODO: is there a way of just updating the selection points rather
        // than fully deleting / recreating?
        // Recreate the selection points
        this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]);
        // We don't need to check if flags are correct
        // because selection points are prerequiste for midpoints
        this.create(updatedCoordinates, midPointFeatureId, coordinatePrecision);
        this.selectionPointBehavior.create(updatedCoordinates, geometry.type, midPointFeatureId);
    }
    create(selectedCoords, featureId, coordinatePrecision) {
        if (!this.store.has(featureId)) {
            throw new Error("Store does not have feature with this id");
        }
        this._midPoints = this.store.create((0,_geometry_get_midpoints__WEBPACK_IMPORTED_MODULE_1__.getMidPoints)(selectedCoords, (i) => ({
            mode: this.mode,
            [_common__WEBPACK_IMPORTED_MODULE_2__.SELECT_PROPERTIES.MID_POINT]: true,
            midPointSegment: i,
            midPointFeatureId: featureId,
        }), coordinatePrecision));
    }
    delete() {
        if (this._midPoints.length) {
            this.store.delete(this._midPoints);
            this._midPoints = [];
        }
    }
    getUpdated(updatedCoordinates) {
        if (this._midPoints.length === 0) {
            return undefined;
        }
        return (0,_geometry_get_midpoints__WEBPACK_IMPORTED_MODULE_1__.getMidPointCoordinates)(updatedCoordinates, this.coordinatePrecision).map((updatedMidPointCoord, i) => ({
            id: this._midPoints[i],
            geometry: {
                type: "Point",
                coordinates: updatedMidPointCoord,
            },
        }));
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/rotate-feature.behavior.ts":
/*!****************************************************************!*\
  !*** ../src/modes/select/behaviors/rotate-feature.behavior.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateFeatureBehavior": () => (/* binding */ RotateFeatureBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_transform_rotate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry/transform/rotate */ "../src/geometry/transform/rotate.ts");
/* harmony import */ var _geometry_centroid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../geometry/centroid */ "../src/geometry/centroid.ts");
/* harmony import */ var _geometry_measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../geometry/measure/rhumb-bearing */ "../src/geometry/measure/rhumb-bearing.ts");
/* harmony import */ var _geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../geometry/limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");





class RotateFeatureBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, selectionPoints, midPoints) {
        super(config);
        this.config = config;
        this.selectionPoints = selectionPoints;
        this.midPoints = midPoints;
    }
    reset() {
        this.lastBearing = undefined;
    }
    rotate(event, selectedId) {
        const geometry = this.store.getGeometryCopy(selectedId);
        // Update the geometry of the dragged feature
        if (geometry.type !== "Polygon" && geometry.type !== "LineString") {
            return;
        }
        const mouseCoord = [event.lng, event.lat];
        const bearing = (0,_geometry_measure_rhumb_bearing__WEBPACK_IMPORTED_MODULE_3__.rhumbBearing)((0,_geometry_centroid__WEBPACK_IMPORTED_MODULE_2__.centroid)({ type: "Feature", geometry, properties: {} }), mouseCoord);
        // We need an original bearing to compare against
        if (!this.lastBearing) {
            this.lastBearing = bearing + 180;
            return;
        }
        const angle = this.lastBearing - (bearing + 180);
        (0,_geometry_transform_rotate__WEBPACK_IMPORTED_MODULE_1__.transformRotate)({ type: "Feature", geometry, properties: {} }, -angle);
        let updatedCoords;
        if (geometry.type === "Polygon") {
            updatedCoords = geometry.coordinates[0];
        }
        else if (geometry.type === "LineString") {
            updatedCoords = geometry.coordinates;
        }
        else {
            return;
        }
        // Ensure that coordinate precision is maintained
        updatedCoords.forEach((coordinate) => {
            coordinate[0] = (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__.limitPrecision)(coordinate[0], this.coordinatePrecision);
            coordinate[1] = (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__.limitPrecision)(coordinate[1], this.coordinatePrecision);
        });
        const updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];
        const updatedSelectionPoints = this.selectionPoints.getUpdated(updatedCoords) || [];
        // Issue the update to the selected feature
        this.store.updateGeometry([
            { id: selectedId, geometry },
            ...updatedSelectionPoints,
            ...updatedMidPoints,
        ]);
        this.lastBearing = bearing + 180;
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/scale-feature.behavior.ts":
/*!***************************************************************!*\
  !*** ../src/modes/select/behaviors/scale-feature.behavior.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScaleFeatureBehavior": () => (/* binding */ ScaleFeatureBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_centroid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry/centroid */ "../src/geometry/centroid.ts");
/* harmony import */ var _geometry_measure_haversine_distance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../geometry/measure/haversine-distance */ "../src/geometry/measure/haversine-distance.ts");
/* harmony import */ var _geometry_transform_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../geometry/transform/scale */ "../src/geometry/transform/scale.ts");
/* harmony import */ var _geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../geometry/limit-decimal-precision */ "../src/geometry/limit-decimal-precision.ts");





class ScaleFeatureBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, selectionPoints, midPoints) {
        super(config);
        this.config = config;
        this.selectionPoints = selectionPoints;
        this.midPoints = midPoints;
    }
    reset() {
        this.lastDistance = undefined;
    }
    scale(event, selectedId) {
        const geometry = this.store.getGeometryCopy(selectedId);
        // Update the geometry of the dragged feature
        if (geometry.type !== "Polygon" && geometry.type !== "LineString") {
            return;
        }
        const mouseCoord = [event.lng, event.lat];
        const distance = (0,_geometry_measure_haversine_distance__WEBPACK_IMPORTED_MODULE_2__.haversineDistanceKilometers)((0,_geometry_centroid__WEBPACK_IMPORTED_MODULE_1__.centroid)({ type: "Feature", geometry, properties: {} }), mouseCoord);
        // We need an original bearing to compare against
        if (!this.lastDistance) {
            this.lastDistance = distance;
            return;
        }
        const scale = 1 - (this.lastDistance - distance) / distance;
        (0,_geometry_transform_scale__WEBPACK_IMPORTED_MODULE_3__.transformScale)({ type: "Feature", geometry, properties: {} }, scale);
        let updatedCoords;
        if (geometry.type === "Polygon") {
            updatedCoords = geometry.coordinates[0];
        }
        else if (geometry.type === "LineString") {
            updatedCoords = geometry.coordinates;
        }
        else {
            return;
        }
        // Ensure that coordinate precision is maintained
        updatedCoords.forEach((coordinate) => {
            coordinate[0] = (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__.limitPrecision)(coordinate[0], this.coordinatePrecision);
            coordinate[1] = (0,_geometry_limit_decimal_precision__WEBPACK_IMPORTED_MODULE_4__.limitPrecision)(coordinate[1], this.coordinatePrecision);
        });
        const updatedMidPoints = this.midPoints.getUpdated(updatedCoords) || [];
        const updatedSelectionPoints = this.selectionPoints.getUpdated(updatedCoords) || [];
        // Issue the update to the selected feature
        this.store.updateGeometry([
            { id: selectedId, geometry },
            ...updatedSelectionPoints,
            ...updatedMidPoints,
        ]);
        this.lastDistance = distance;
    }
}


/***/ }),

/***/ "../src/modes/select/behaviors/selection-point.behavior.ts":
/*!*****************************************************************!*\
  !*** ../src/modes/select/behaviors/selection-point.behavior.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionPointBehavior": () => (/* binding */ SelectionPointBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base.behavior */ "../src/modes/base.behavior.ts");
/* harmony import */ var _geometry_get_coordinates_as_points__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry/get-coordinates-as-points */ "../src/geometry/get-coordinates-as-points.ts");


class SelectionPointBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config) {
        super(config);
        this._selectionPoints = [];
    }
    get ids() {
        return this._selectionPoints.concat();
    }
    set ids(_) { }
    create(selectedCoords, type, featureId) {
        this._selectionPoints = this.store.create((0,_geometry_get_coordinates_as_points__WEBPACK_IMPORTED_MODULE_1__.getCoordinatesAsPoints)(selectedCoords, type, (i) => ({
            mode: this.mode,
            selectionPoint: true,
            selectionPointFeatureId: featureId,
            index: i,
        })));
    }
    delete() {
        if (this.ids.length) {
            this.store.delete(this.ids);
            this._selectionPoints = [];
        }
    }
    getUpdated(updatedCoordinates) {
        if (this._selectionPoints.length === 0) {
            return undefined;
        }
        return this._selectionPoints.map((id, i) => {
            return {
                id,
                geometry: {
                    type: "Point",
                    coordinates: updatedCoordinates[i],
                },
            };
        });
    }
    getOneUpdated(index, updatedCoordinate) {
        if (this._selectionPoints[index] === undefined) {
            return undefined;
        }
        return {
            id: this._selectionPoints[index],
            geometry: {
                type: "Point",
                coordinates: updatedCoordinate,
            },
        };
    }
}


/***/ }),

/***/ "../src/modes/select/select.mode.ts":
/*!******************************************!*\
  !*** ../src/modes/select/select.mode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawSelectMode": () => (/* binding */ TerraDrawSelectMode)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common */ "../src/common.ts");
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");
/* harmony import */ var _behaviors_midpoint_behavior__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./behaviors/midpoint.behavior */ "../src/modes/select/behaviors/midpoint.behavior.ts");
/* harmony import */ var _behaviors_selection_point_behavior__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./behaviors/selection-point.behavior */ "../src/modes/select/behaviors/selection-point.behavior.ts");
/* harmony import */ var _behaviors_features_at_mouse_event_behavior__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./behaviors/features-at-mouse-event.behavior */ "../src/modes/select/behaviors/features-at-mouse-event.behavior.ts");
/* harmony import */ var _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pixel-distance.behavior */ "../src/modes/pixel-distance.behavior.ts");
/* harmony import */ var _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../click-bounding-box.behavior */ "../src/modes/click-bounding-box.behavior.ts");
/* harmony import */ var _behaviors_drag_feature_behavior__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./behaviors/drag-feature.behavior */ "../src/modes/select/behaviors/drag-feature.behavior.ts");
/* harmony import */ var _behaviors_drag_coordinate_behavior__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./behaviors/drag-coordinate.behavior */ "../src/modes/select/behaviors/drag-coordinate.behavior.ts");
/* harmony import */ var _behaviors_rotate_feature_behavior__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./behaviors/rotate-feature.behavior */ "../src/modes/select/behaviors/rotate-feature.behavior.ts");
/* harmony import */ var _behaviors_scale_feature_behavior__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./behaviors/scale-feature.behavior */ "../src/modes/select/behaviors/scale-feature.behavior.ts");











class TerraDrawSelectMode extends _base_mode__WEBPACK_IMPORTED_MODULE_1__.TerraDrawBaseDrawMode {
    constructor(options) {
        super(options);
        this.mode = "select";
        this.dragEventThrottle = 5;
        this.dragEventCount = 0;
        this.selected = [];
        this.flags = options && options.flags ? options.flags : {};
        this.keyEvents =
            options && options.keyEvents
                ? options.keyEvents
                : { deselect: "Escape", delete: "Delete", rotate: "r", scale: "s" };
        this.dragEventThrottle =
            (options &&
                options.dragEventThrottle !== undefined &&
                options.dragEventThrottle) ||
                5;
    }
    registerBehaviors(config) {
        this.pixelDistance = new _pixel_distance_behavior__WEBPACK_IMPORTED_MODULE_5__.PixelDistanceBehavior(config);
        this.clickBoundingBox = new _click_bounding_box_behavior__WEBPACK_IMPORTED_MODULE_6__.ClickBoundingBoxBehavior(config);
        this.featuresAtMouseEvent = new _behaviors_features_at_mouse_event_behavior__WEBPACK_IMPORTED_MODULE_4__.FeaturesAtMouseEventBehavior(config, this.clickBoundingBox, this.pixelDistance);
        this.selectionPoints = new _behaviors_selection_point_behavior__WEBPACK_IMPORTED_MODULE_3__.SelectionPointBehavior(config);
        this.midPoints = new _behaviors_midpoint_behavior__WEBPACK_IMPORTED_MODULE_2__.MidPointBehavior(config, this.selectionPoints);
        this.rotateFeature = new _behaviors_rotate_feature_behavior__WEBPACK_IMPORTED_MODULE_9__.RotateFeatureBehavior(config, this.selectionPoints, this.midPoints);
        this.scaleFeature = new _behaviors_scale_feature_behavior__WEBPACK_IMPORTED_MODULE_10__.ScaleFeatureBehavior(config, this.selectionPoints, this.midPoints);
        this.dragFeature = new _behaviors_drag_feature_behavior__WEBPACK_IMPORTED_MODULE_7__.DragFeatureBehavior(config, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints);
        this.dragCoordinate = new _behaviors_drag_coordinate_behavior__WEBPACK_IMPORTED_MODULE_8__.DragCoordinateBehavior(config, this.pixelDistance, this.selectionPoints, this.midPoints);
    }
    deselect() {
        this.store.updateProperty(this.selected.map((id) => ({
            id,
            property: _common__WEBPACK_IMPORTED_MODULE_0__.SELECT_PROPERTIES.SELECTED,
            value: false,
        })));
        this.onDeselect(this.selected[0]);
        this.selected = [];
        this.selectionPoints.delete();
        this.midPoints.delete();
    }
    deleteSelected() {
        // Delete all selected features
        // from the store and clear selected
        // We don't need to set selected false
        // as we're going to delete the feature
        this.store.delete(this.selected);
        this.selected = [];
    }
    onRightClick(event) {
        if (!this.selectionPoints.ids.length) {
            return;
        }
        let clickedSelectionPointProps;
        let clickedFeatureDistance = Infinity;
        this.selectionPoints.ids.forEach((id) => {
            const geometry = this.store.getGeometryCopy(id);
            const distance = this.pixelDistance.measure(event, geometry.coordinates);
            if (distance < this.pointerDistance &&
                distance < clickedFeatureDistance) {
                clickedFeatureDistance = distance;
                clickedSelectionPointProps = this.store.getPropertiesCopy(id);
            }
        });
        if (!clickedSelectionPointProps) {
            return;
        }
        const featureId = clickedSelectionPointProps.selectionPointFeatureId;
        const coordinateIndex = clickedSelectionPointProps.index;
        // We allow for preventing deleting coordinates via flags
        const properties = this.store.getPropertiesCopy(featureId);
        const modeFlags = this.flags[properties.mode];
        // Check if we can actually delete the coordinate
        const cannotDelete = !modeFlags ||
            !modeFlags.feature ||
            !modeFlags.feature.coordinates ||
            !modeFlags.feature.coordinates.deletable;
        if (cannotDelete) {
            return;
        }
        const geometry = this.store.getGeometryCopy(featureId);
        let coordinates;
        if (geometry.type === "Polygon") {
            coordinates = geometry.coordinates[0];
            // Prevent creating an invalid polygon
            if (coordinates.length <= 4) {
                return;
            }
        }
        else if (geometry.type === "LineString") {
            coordinates = geometry.coordinates;
            // Prevent creating an invalid linestring
            if (coordinates.length <= 3) {
                return;
            }
        }
        // Geometry is not Polygon or LineString
        if (!coordinates) {
            return;
        }
        if ((geometry.type === "Polygon" && coordinateIndex === 0) ||
            coordinateIndex === coordinates.length - 1) {
            // Deleting the final coordinate in a polygon breaks it
            // because GeoJSON expects a duplicate, so we need to fix
            // it by adding the new first coordinate to the end
            coordinates.shift();
            coordinates.pop();
            coordinates.push([coordinates[0][0], coordinates[0][1]]);
        }
        else {
            // Remove coordinate from array
            coordinates.splice(coordinateIndex, 1);
        }
        this.store.delete([...this.midPoints.ids, ...this.selectionPoints.ids]);
        this.store.updateGeometry([
            {
                id: featureId,
                geometry,
            },
        ]);
        this.selectionPoints.create(coordinates, geometry.type, featureId);
        if (modeFlags &&
            modeFlags.feature &&
            modeFlags.feature.coordinates &&
            modeFlags.feature.coordinates.midpoints) {
            this.midPoints.create(coordinates, featureId, this.coordinatePrecision);
        }
    }
    onLeftClick(event) {
        const { clickedFeature, clickedMidPoint } = this.featuresAtMouseEvent.find(event, this.selected.length > 0);
        if (this.selected.length && clickedMidPoint) {
            // TODO: We probably want to make sure the midpoint
            // is visible?
            this.midPoints.insert(clickedMidPoint.id, this.coordinatePrecision);
            return;
        }
        if (clickedFeature) {
            const { mode } = this.store.getPropertiesCopy(clickedFeature.id);
            const previouslySelectedId = this.selected[0];
            // If we have something currently selected
            if (previouslySelectedId) {
                // If it matches the current selected feature id, do nothing
                if (previouslySelectedId === clickedFeature.id) {
                    return;
                }
                else {
                    // If it's a different feature set selected
                    // to false on previously selected feature
                    this.deselect();
                }
            }
            // This will be undefined for points
            const modeFlags = this.flags[mode];
            // If feature is not selectable then return
            if (!modeFlags || !modeFlags.feature) {
                return;
            }
            // Select feature
            this.selected = [clickedFeature.id];
            this.store.updateProperty([
                { id: clickedFeature.id, property: "selected", value: true },
            ]);
            this.onSelect(clickedFeature.id);
            // Get the clicked feature
            const { type, coordinates } = this.store.getGeometryCopy(clickedFeature.id);
            let selectedCoords;
            if (type === "LineString") {
                selectedCoords = coordinates;
            }
            else if (type === "Polygon") {
                selectedCoords = coordinates[0];
            }
            if (selectedCoords && modeFlags && modeFlags.feature.coordinates) {
                this.selectionPoints.create(selectedCoords, type, clickedFeature.id);
                if (modeFlags.feature.coordinates.midpoints) {
                    this.midPoints.create(selectedCoords, clickedFeature.id, this.coordinatePrecision);
                }
            }
        }
        else if (this.selected.length) {
            this.deselect();
            return;
        }
    }
    start() {
        this.setStarted();
    }
    stop() {
        this.setStopped();
        this.cleanUp();
    }
    onClick(event) {
        if (event.button === "right") {
            this.onRightClick(event);
            return;
        }
        else if (event.button === "left") {
            this.onLeftClick(event);
        }
    }
    onKeyDown() { }
    onKeyUp(event) {
        if (event.key === this.keyEvents.delete) {
            if (!this.selected.length) {
                return;
            }
            // We are technically deselecting
            // because the selected feature is deleted
            // and will no longer exist or be selected
            const previouslySelected = this.selected[0];
            this.onDeselect(previouslySelected);
            // Delete all selected features
            this.deleteSelected();
            // Remove all selection points
            this.selectionPoints.delete();
            this.midPoints.delete();
        }
        else if (event.key === this.keyEvents.deselect) {
            this.cleanUp();
        }
    }
    cleanUp() {
        if (this.selected.length) {
            this.deselect();
        }
    }
    onDragStart(event, setMapDraggability) {
        // We only need to stop the map dragging if
        // we actually have something selected
        if (!this.selected.length) {
            return;
        }
        // If the selected feature is not draggable
        // don't do anything
        const properties = this.store.getPropertiesCopy(this.selected[0]);
        const modeFlags = this.flags[properties.mode];
        const draggable = modeFlags &&
            modeFlags.feature &&
            (modeFlags.feature.draggable ||
                (modeFlags.feature.coordinates &&
                    modeFlags.feature.coordinates.draggable));
        if (!draggable) {
            return;
        }
        this.dragEventCount = 0;
        this.setCursor("grabbing");
        this.dragFeature.position = [event.lng, event.lat];
        setMapDraggability(false);
    }
    onDrag(event) {
        const selectedId = this.selected[0];
        // If nothing selected or the drag position hasn't been set
        // do nothing
        if (!selectedId || !this.dragFeature.position) {
            return;
        }
        const properties = this.store.getPropertiesCopy(selectedId);
        const modeFlags = this.flags[properties.mode];
        // Ensure drag count is incremented
        this.dragEventCount++;
        // Return if we haven't hit the drag throttle limit
        // (i.e. we only want to drag every nth event)
        if (this.dragEventCount % this.dragEventThrottle === 0) {
            return;
        }
        // Check if should rotate
        if (modeFlags &&
            modeFlags.feature &&
            modeFlags.feature.rotateable &&
            event.heldKeys.includes("r")) {
            this.rotateFeature.rotate(event, selectedId);
            return;
        }
        // Check if should scale
        if (modeFlags &&
            modeFlags.feature &&
            modeFlags.feature.scaleable &&
            event.heldKeys.includes("s")) {
            this.scaleFeature.scale(event, selectedId);
            return;
        }
        // Check if coordinate is draggable and is dragged
        if (modeFlags &&
            modeFlags.feature &&
            modeFlags.feature.coordinates &&
            modeFlags.feature.coordinates.draggable) {
            const coordinateWasDragged = this.dragCoordinate.drag(event, selectedId);
            if (coordinateWasDragged) {
                return;
            }
        }
        // Check if feature is draggable and is dragged
        if (modeFlags && modeFlags.feature && modeFlags.feature.draggable) {
            this.dragFeature.drag(event, selectedId);
            this.dragFeature.position = [event.lng, event.lat];
        }
    }
    onDragEnd(_, setMapDraggability) {
        this.setCursor("grab");
        this.dragFeature.position = undefined;
        this.rotateFeature.reset();
        this.scaleFeature.reset();
        setMapDraggability(true);
    }
    onMouseMove(event) {
        if (!this.selected.length || this.dragFeature.position) {
            return;
        }
        let nearbySelectionPoint = false;
        this.midPoints.ids.forEach((id) => {
            if (nearbySelectionPoint) {
                return;
            }
            const geometry = this.store.getGeometryCopy(id);
            const distance = this.pixelDistance.measure(event, geometry.coordinates);
            if (distance < this.pointerDistance) {
                nearbySelectionPoint = true;
            }
        });
        // TODO: Is there a cleaner way to handle prioritising
        // dragging selection points?
        this.selectionPoints.ids.forEach((id) => {
            const geometry = this.store.getGeometryCopy(id);
            const distance = this.pixelDistance.measure(event, geometry.coordinates);
            if (distance < this.pointerDistance) {
                nearbySelectionPoint = false;
            }
        });
        if (nearbySelectionPoint) {
            this.setCursor("crosshair");
        }
        else {
            this.setCursor("unset");
        }
    }
}


/***/ }),

/***/ "../src/modes/snapping.behavior.ts":
/*!*****************************************!*\
  !*** ../src/modes/snapping.behavior.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnappingBehavior": () => (/* binding */ SnappingBehavior)
/* harmony export */ });
/* harmony import */ var _base_behavior__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.behavior */ "../src/modes/base.behavior.ts");

class SnappingBehavior extends _base_behavior__WEBPACK_IMPORTED_MODULE_0__.TerraDrawModeBehavior {
    constructor(config, pixelDistance, clickBoundingBox) {
        super(config);
        this.config = config;
        this.pixelDistance = pixelDistance;
        this.clickBoundingBox = clickBoundingBox;
        this.getSnappableCoordinate = (event, currentFeatureId) => {
            return this.getSnappable(event, (feature) => {
                return Boolean(feature.properties &&
                    feature.properties.mode === this.mode &&
                    feature.id !== currentFeatureId);
            });
        };
    }
    getSnappable(event, filter) {
        const bbox = this.clickBoundingBox.create(event);
        const features = this.store.search(bbox, filter);
        const closest = {
            coord: undefined,
            minDist: Infinity,
        };
        features.forEach((feature) => {
            let coordinates;
            if (feature.geometry.type === "Polygon") {
                coordinates = feature.geometry.coordinates[0];
            }
            else if (feature.geometry.type === "LineString") {
                coordinates = feature.geometry.coordinates;
            }
            else {
                return;
            }
            coordinates.forEach((coord) => {
                const dist = this.pixelDistance.measure(event, coord);
                if (dist < closest.minDist && dist < this.pointerDistance) {
                    closest.coord = coord;
                }
            });
        });
        return closest.coord;
    }
}


/***/ }),

/***/ "../src/modes/static/static.mode.ts":
/*!******************************************!*\
  !*** ../src/modes/static/static.mode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDrawStaticMode": () => (/* binding */ TerraDrawStaticMode)
/* harmony export */ });
/* harmony import */ var _base_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base.mode */ "../src/modes/base.mode.ts");

class TerraDrawStaticMode extends _base_mode__WEBPACK_IMPORTED_MODULE_0__.TerraDrawBaseDrawMode {
    constructor() {
        super(...arguments);
        this.mode = "static";
    }
    start() { }
    stop() { }
    onKeyUp() { }
    onKeyDown() { }
    onClick() { }
    onDragStart() { }
    onDrag() { }
    onDragEnd() { }
    onMouseMove() { }
}


/***/ }),

/***/ "../src/store/spatial-index/quickselect.ts":
/*!*************************************************!*\
  !*** ../src/store/spatial-index/quickselect.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "quickselect": () => (/* binding */ quickselect)
/* harmony export */ });
// ISC License
// Copyright (c) 2018, Vladimir Agafonkin
function quickselect(arr, k, left, right, compare) {
    while (right > left) {
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp((2 * z) / 3);
            const sd = 0.5 * Math.sqrt((z * s * (n - s)) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            const newRight = Math.min(right, Math.floor(k + ((n - m) * s) / n + sd));
            quickselect(arr, k, newLeft, newRight, compare);
        }
        const t = arr[k];
        let i = left;
        let j = right;
        swap(arr, left, k);
        if (compare(arr[right], t) > 0)
            swap(arr, left, right);
        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0)
                i++;
            while (compare(arr[j], t) > 0)
                j--;
        }
        if (compare(arr[left], t) === 0) {
            swap(arr, left, j);
        }
        else {
            j++;
            swap(arr, j, right);
        }
        if (j <= k)
            left = j + 1;
        if (k <= j)
            right = j - 1;
    }
}
function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}


/***/ }),

/***/ "../src/store/spatial-index/rbush.ts":
/*!*******************************************!*\
  !*** ../src/store/spatial-index/rbush.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RBush": () => (/* binding */ RBush)
/* harmony export */ });
/* harmony import */ var _quickselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quickselect */ "../src/store/spatial-index/quickselect.ts");
// Base on Rbush - https://github.com/mourner/rbush
// MIT License
// Copyright (c) 2016 Vladimir Agafonkin

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}
// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode)
        destNode = createNode([]);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;
    for (let i = k; i < p; i++) {
        const child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }
    return destNode;
}
function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}
function compareNodeMinX(a, b) {
    return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
    return a.minY - b.minY;
}
function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
    return ((Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
        (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY)));
}
function intersectionArea(a, b) {
    const minX = Math.max(a.minX, b.minX);
    const minY = Math.max(a.minY, b.minY);
    const maxX = Math.min(a.maxX, b.maxX);
    const maxY = Math.min(a.maxY, b.maxY);
    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
    return (a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY);
}
function intersects(a, b) {
    return (b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY);
}
function createNode(children) {
    return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity,
    };
}
// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach
function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];
    while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n)
            continue;
        const mid = left + Math.ceil((right - left) / n / 2) * n;
        (0,_quickselect__WEBPACK_IMPORTED_MODULE_0__.quickselect)(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
    }
}
class RBush {
    constructor(maxEntries) {
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
    }
    search(bbox) {
        let node = this.data;
        const result = [];
        if (!intersects(bbox, node)) {
            return result;
        }
        const toBBox = this.toBBox;
        const nodesToSearch = [];
        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                    if (node.leaf)
                        result.push(child);
                    else if (contains(bbox, childBBox))
                        this._all(child, result);
                    else
                        nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }
        return result;
    }
    collides(bbox) {
        let node = this.data;
        const intersect = intersects(bbox, node);
        if (intersect) {
            const nodesToSearch = [];
            while (node) {
                for (let i = 0; i < node.children.length; i++) {
                    const child = node.children[i];
                    const childBBox = node.leaf ? this.toBBox(child) : child;
                    if (intersects(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) {
                            return true;
                        }
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }
        }
        return false;
    }
    load(data) {
        if (data.length < this._minEntries) {
            for (let i = 0; i < data.length; i++) {
                this.insert(data[i]);
            }
            return;
        }
        // recursively build the tree with the given data from scratch using OMT algorithm
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;
        }
        else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);
        }
        else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                const tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }
            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }
    }
    insert(item) {
        this._insert(item, this.data.height - 1);
    }
    clear() {
        this.data = createNode([]);
    }
    remove(item) {
        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i;
        let parent;
        let goingUp = false;
        // depth-first iterative tree traversal
        while (node || path.length) {
            if (!node) {
                // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }
            if (node.leaf) {
                // check current node
                const index = node.children.indexOf(item);
                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                }
            }
            if (!goingUp && !node.leaf && contains(node, bbox)) {
                // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];
            }
            else if (parent) {
                // go right
                i++;
                node = parent.children[i];
                goingUp = false;
            }
            else {
                node = null; // nothing found
            }
        }
    }
    toBBox(item) {
        return item;
    }
    compareMinX(a, b) {
        return a.minX - b.minX;
    }
    compareMinY(a, b) {
        return a.minY - b.minY;
    }
    _all(node, result) {
        const nodesToSearch = [];
        while (node) {
            if (node.leaf)
                result.push(...node.children);
            else
                nodesToSearch.push(...node.children);
            node = nodesToSearch.pop();
        }
        return result;
    }
    _build(items, left, right, height) {
        const N = right - left + 1;
        let M = this._maxEntries;
        let node;
        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }
        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));
            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        // split the items into M mostly square tiles
        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i = left; i <= right; i += N1) {
            const right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (let j = i; j <= right2; j += N2) {
                const right3 = Math.min(j + N2 - 1, right2);
                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }
        calcBBox(node, this.toBBox);
        return node;
    }
    _chooseSubtree(bbox, node, level, path) {
        while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level) {
                break;
            }
            let minArea = Infinity;
            let minEnlargement = Infinity;
            let targetNode;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const area = bboxArea(child);
                const enlargement = enlargedArea(bbox, child) - area;
                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;
                }
                else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }
            node = targetNode || node.children[0];
        }
        return node;
    }
    _insert(item, level, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];
        // find the best node for accommodating the item, saving all nodes along the path too
        const node = this._chooseSubtree(bbox, this.data, level, insertPath);
        // put the item into the node
        node.children.push(item);
        extend(node, bbox);
        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            }
            else
                break;
        }
        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    }
    // split overflowed node into two
    _split(insertPath, level) {
        const node = insertPath[level];
        const M = node.children.length;
        const m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        const splitIndex = this._chooseSplitIndex(node, m, M);
        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level)
            insertPath[level - 1].children.push(newNode);
        else
            this._splitRoot(node, newNode);
    }
    _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    }
    _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;
        for (let i = m; i <= M - m; i++) {
            const bbox1 = distBBox(node, 0, i, this.toBBox);
            const bbox2 = distBBox(node, i, M, this.toBBox);
            const overlap = intersectionArea(bbox1, bbox2);
            const area = bboxArea(bbox1) + bboxArea(bbox2);
            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;
                minArea = area < minArea ? area : minArea;
            }
            else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }
        return index || M - m;
    }
    // sorts node children by the best axis for split
    _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);
        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) {
            node.children.sort(compareMinX);
        }
    }
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i = m; i < M - m; i++) {
            const child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }
        for (let i = M - m - 1; i >= m; i--) {
            const child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }
        return margin;
    }
    _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (let i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    }
    _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (let i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                }
                else
                    this.clear();
            }
            else {
                calcBBox(path[i], this.toBBox);
            }
        }
    }
}


/***/ }),

/***/ "../src/store/spatial-index/spatial-index.ts":
/*!***************************************************!*\
  !*** ../src/store/spatial-index/spatial-index.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpatialIndex": () => (/* binding */ SpatialIndex)
/* harmony export */ });
/* harmony import */ var _rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rbush */ "../src/store/spatial-index/rbush.ts");

class SpatialIndex {
    constructor(options) {
        this.tree = new _rbush__WEBPACK_IMPORTED_MODULE_0__.RBush(options && options.maxEntries ? options.maxEntries : 9);
        this.idToNode = new Map();
        this.nodeToId = new Map();
    }
    setMaps(feature, bbox) {
        this.idToNode.set(String(feature.id), bbox);
        this.nodeToId.set(bbox, String(feature.id));
    }
    toBBox(feature) {
        const longitudes = [];
        const latitudes = [];
        let coordinates;
        if (feature.geometry.type === "Polygon") {
            coordinates = feature.geometry.coordinates[0];
        }
        else if (feature.geometry.type === "LineString") {
            coordinates = feature.geometry.coordinates;
        }
        else if (feature.geometry.type === "Point") {
            coordinates = [feature.geometry.coordinates];
        }
        else {
            throw new Error("Not a valid feature to turn into a bounding box");
        }
        for (let i = 0; i < coordinates.length; i++) {
            latitudes.push(coordinates[i][1]);
            longitudes.push(coordinates[i][0]);
        }
        const minLat = Math.min(...latitudes);
        const maxLat = Math.max(...latitudes);
        const minLng = Math.min(...longitudes);
        const maxLng = Math.max(...longitudes);
        return {
            minX: minLng,
            minY: minLat,
            maxX: maxLng,
            maxY: maxLat,
        };
    }
    insert(feature) {
        if (this.idToNode.get(String(feature.id))) {
            throw new Error("Feature already exists");
        }
        const bbox = this.toBBox(feature);
        this.setMaps(feature, bbox);
        this.tree.insert(bbox);
    }
    load(features) {
        const load = [];
        const seenIds = new Set();
        features.forEach((feature) => {
            const bbox = this.toBBox(feature);
            this.setMaps(feature, bbox);
            if (seenIds.has(String(feature.id))) {
                throw new Error(`Duplicate feature ID found ${feature.id}`);
            }
            seenIds.add(String(feature.id));
            load.push(bbox);
        });
        this.tree.load(load);
    }
    update(feature) {
        this.remove(feature.id);
        const bbox = this.toBBox(feature);
        this.setMaps(feature, bbox);
        this.tree.insert(bbox);
    }
    remove(featureId) {
        const node = this.idToNode.get(featureId);
        if (!node) {
            throw new Error(`${featureId} not inserted into the spatial index`);
        }
        this.tree.remove(node);
    }
    clear() {
        this.tree.clear();
    }
    search(feature) {
        const found = this.tree.search(this.toBBox(feature));
        return found.map((node) => {
            return this.nodeToId.get(node);
        });
    }
    collides(feature) {
        return this.tree.collides(this.toBBox(feature));
    }
}


/***/ }),

/***/ "../src/store/store.ts":
/*!*****************************!*\
  !*** ../src/store/store.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeoJSONStore": () => (/* binding */ GeoJSONStore)
/* harmony export */ });
/* harmony import */ var _util_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/id */ "../src/util/id.ts");
/* harmony import */ var _spatial_index_spatial_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spatial-index/spatial-index */ "../src/store/spatial-index/spatial-index.ts");


class GeoJSONStore {
    constructor(config) {
        // Default to no-op
        this._onChange = () => { };
        this.store = {};
        this.spatialIndex = new _spatial_index_spatial_index__WEBPACK_IMPORTED_MODULE_1__.SpatialIndex();
        // Setting tracked has to happen first
        // because we use it in featureValidation
        this.tracked = config && config.tracked === false ? false : true;
        if (config && config.data) {
            this.load(config.data, config.validateFeature);
        }
    }
    getId() {
        return (0,_util_id__WEBPACK_IMPORTED_MODULE_0__.uuid4)();
    }
    clone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    has(id) {
        return Boolean(this.store[id]);
    }
    load(data, featureValidation) {
        if (data.length === 0) {
            return;
        }
        // We don't want to update the original data
        const clonedData = this.clone(data);
        // We try to be a bit forgiving here as many users
        // may not set a feature id as UUID or createdAt/updatedAt
        clonedData.forEach((feature) => {
            if (!feature.id) {
                feature.id = (0,_util_id__WEBPACK_IMPORTED_MODULE_0__.uuid4)();
            }
            if (this.tracked) {
                if (!feature.properties.createdAt) {
                    feature.properties.createdAt = +new Date();
                }
                if (!feature.properties.updatedAt) {
                    feature.properties.updatedAt = +new Date();
                }
            }
        });
        const changes = [];
        clonedData.forEach((feature) => {
            if (featureValidation) {
                featureValidation(feature);
            }
            this.store[feature.id] = feature;
            changes.push(feature.id);
        });
        this.spatialIndex.load(clonedData);
        this._onChange(changes, "create");
    }
    search(bbox, filter) {
        const features = this.spatialIndex.search(bbox).map((id) => this.store[id]);
        if (filter) {
            return this.clone(features.filter(filter));
        }
        else {
            return this.clone(features);
        }
    }
    registerOnChange(onChange) {
        this._onChange = (ids, change) => {
            onChange(ids, change);
        };
    }
    getGeometryCopy(id) {
        const feature = this.store[id];
        if (!feature) {
            throw new Error(`No feature with this id (${id}), can not get geometry copy`);
        }
        return this.clone(feature.geometry);
    }
    getPropertiesCopy(id) {
        const feature = this.store[id];
        if (!feature) {
            throw new Error(`No feature with this id (${id}), can not get properties copy`);
        }
        return this.clone(feature.properties);
    }
    updateProperty(propertiesToUpdate) {
        const ids = [];
        propertiesToUpdate.forEach(({ id, property, value }) => {
            const feature = this.store[id];
            if (!feature) {
                throw new Error(`No feature with this (${id}), can not update geometry`);
            }
            ids.push(id);
            feature.properties[property] = value;
            // Update the time the feature was updated
            if (this.tracked) {
                feature.properties.updatedAt = +new Date();
            }
        });
        if (this._onChange) {
            this._onChange(ids, "update");
        }
    }
    updateGeometry(geometriesToUpdate) {
        const ids = [];
        geometriesToUpdate.forEach(({ id, geometry }) => {
            ids.push(id);
            const feature = this.store[id];
            if (!feature) {
                throw new Error(`No feature with this (${id}), can not update geometry`);
            }
            feature.geometry = this.clone(geometry);
            this.spatialIndex.update(feature);
            // Update the time the feature was updated
            if (this.tracked) {
                feature.properties.updatedAt = +new Date();
            }
        });
        if (this._onChange) {
            this._onChange(ids, "update");
        }
    }
    create(features) {
        const ids = [];
        features.forEach(({ geometry, properties }) => {
            let createdAt;
            let createdProperties = Object.assign({}, properties);
            if (this.tracked) {
                createdAt = +new Date();
                if (properties) {
                    createdProperties.createdAt =
                        typeof properties.createdAt === "number"
                            ? properties.createdAt
                            : createdAt;
                    createdProperties.updatedAt =
                        typeof properties.updatedAt === "number"
                            ? properties.updatedAt
                            : createdAt;
                }
                else {
                    createdProperties = { createdAt, updatedAt: createdAt };
                }
            }
            const id = this.getId();
            const feature = {
                id,
                type: "Feature",
                geometry,
                properties: createdProperties,
            };
            this.store[id] = feature;
            this.spatialIndex.insert(feature);
            ids.push(id);
        });
        if (this._onChange) {
            this._onChange([...ids], "create");
        }
        return ids;
    }
    delete(ids) {
        ids.forEach((id) => {
            if (this.store[id]) {
                delete this.store[id];
                this.spatialIndex.remove(id);
            }
            else {
                throw new Error("No feature with this id, can not delete");
            }
        });
        if (this._onChange) {
            this._onChange([...ids], "delete");
        }
    }
    copyAll() {
        return this.clone(Object.keys(this.store).map((id) => this.store[id]));
    }
}


/***/ }),

/***/ "../src/terra-draw.ts":
/*!****************************!*\
  !*** ../src/terra-draw.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TerraDraw": () => (/* binding */ TerraDraw),
/* harmony export */   "TerraDrawCircleMode": () => (/* reexport safe */ _modes_circle_circle_mode__WEBPACK_IMPORTED_MODULE_3__.TerraDrawCircleMode),
/* harmony export */   "TerraDrawFreehandMode": () => (/* reexport safe */ _modes_freehand_freehand_mode__WEBPACK_IMPORTED_MODULE_4__.TerraDrawFreehandMode),
/* harmony export */   "TerraDrawGoogleMapsAdapter": () => (/* reexport safe */ _adapters_google_maps_adapter__WEBPACK_IMPORTED_MODULE_0__.TerraDrawGoogleMapsAdapter),
/* harmony export */   "TerraDrawLeafletAdapter": () => (/* reexport safe */ _adapters_leaflet_adapter__WEBPACK_IMPORTED_MODULE_1__.TerraDrawLeafletAdapter),
/* harmony export */   "TerraDrawLineStringMode": () => (/* reexport safe */ _modes_linestring_linestring_mode__WEBPACK_IMPORTED_MODULE_5__.TerraDrawLineStringMode),
/* harmony export */   "TerraDrawMapboxGLAdapter": () => (/* reexport safe */ _adapters_mapbox_gl_adapter__WEBPACK_IMPORTED_MODULE_2__.TerraDrawMapboxGLAdapter),
/* harmony export */   "TerraDrawPointMode": () => (/* reexport safe */ _modes_point_point_mode__WEBPACK_IMPORTED_MODULE_6__.TerraDrawPointMode),
/* harmony export */   "TerraDrawPolygonMode": () => (/* reexport safe */ _modes_polygon_polygon_mode__WEBPACK_IMPORTED_MODULE_7__.TerraDrawPolygonMode),
/* harmony export */   "TerraDrawSelectMode": () => (/* reexport safe */ _modes_select_select_mode__WEBPACK_IMPORTED_MODULE_8__.TerraDrawSelectMode)
/* harmony export */ });
/* harmony import */ var _adapters_google_maps_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapters/google-maps.adapter */ "../src/adapters/google-maps.adapter.ts");
/* harmony import */ var _adapters_leaflet_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapters/leaflet.adapter */ "../src/adapters/leaflet.adapter.ts");
/* harmony import */ var _adapters_mapbox_gl_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./adapters/mapbox-gl.adapter */ "../src/adapters/mapbox-gl.adapter.ts");
/* harmony import */ var _modes_circle_circle_mode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modes/circle/circle.mode */ "../src/modes/circle/circle.mode.ts");
/* harmony import */ var _modes_freehand_freehand_mode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modes/freehand/freehand.mode */ "../src/modes/freehand/freehand.mode.ts");
/* harmony import */ var _modes_linestring_linestring_mode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modes/linestring/linestring.mode */ "../src/modes/linestring/linestring.mode.ts");
/* harmony import */ var _modes_point_point_mode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modes/point/point.mode */ "../src/modes/point/point.mode.ts");
/* harmony import */ var _modes_polygon_polygon_mode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modes/polygon/polygon.mode */ "../src/modes/polygon/polygon.mode.ts");
/* harmony import */ var _modes_select_select_mode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modes/select/select.mode */ "../src/modes/select/select.mode.ts");
/* harmony import */ var _modes_static_static_mode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modes/static/static.mode */ "../src/modes/static/static.mode.ts");
/* harmony import */ var _store_store__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./store/store */ "../src/store/store.ts");











class TerraDraw {
    constructor(options) {
        this._enabled = false;
        this._adapter = options.adapter;
        this._mode = new _modes_static_static_mode__WEBPACK_IMPORTED_MODULE_9__.TerraDrawStaticMode();
        this._modes = Object.assign(Object.assign({}, options.modes), { static: this._mode });
        this._eventListeners = { change: [], select: [], deselect: [] };
        if (options.data) {
            this._store = new _store_store__WEBPACK_IMPORTED_MODULE_10__.GeoJSONStore({ data: options.data });
        }
        else {
            this._store = new _store_store__WEBPACK_IMPORTED_MODULE_10__.GeoJSONStore();
        }
        const getChanged = (ids) => {
            const changed = [];
            const unchanged = this._store.copyAll().filter((f) => {
                if (ids.includes(f.id)) {
                    changed.push(f);
                    return false;
                }
                return true;
            });
            return { changed, unchanged };
        };
        const onChange = (ids, event) => {
            this._eventListeners.change.forEach((listener) => {
                listener(ids, event);
            });
            const { changed, unchanged } = getChanged(ids);
            if (event === "create") {
                this._adapter.render({
                    created: changed,
                    deletedIds: [],
                    unchanged,
                    updated: []
                }, this.getModeStyles());
            }
            else if (event === "update") {
                this._adapter.render({
                    created: [],
                    deletedIds: [],
                    unchanged,
                    updated: changed,
                }, this.getModeStyles());
            }
            else if (event === "delete") {
                this._adapter.render({ created: [], deletedIds: ids, unchanged, updated: [] }, this.getModeStyles());
            }
            else if (event === "styling") {
                this._adapter.render({ created: [], deletedIds: [], unchanged, updated: [] }, this.getModeStyles());
            }
        };
        const onSelect = (selectedId) => {
            this._eventListeners.select.forEach((listener) => {
                listener(selectedId);
            });
            const { changed, unchanged } = getChanged([selectedId]);
            this._adapter.render({ created: [], deletedIds: [], unchanged, updated: changed }, this.getModeStyles());
        };
        const onDeselect = (deselectedId) => {
            this._eventListeners.deselect.forEach((listener) => {
                listener();
            });
            const { changed, unchanged } = getChanged([deselectedId]);
            // onDeselect can be called after a delete call which means that
            // you are deselecting a feature that has been deleted. We
            // double check here to ensure that the feature still exists.
            if (changed) {
                this._adapter.render({
                    created: [],
                    deletedIds: [],
                    unchanged,
                    updated: changed,
                }, this.getModeStyles());
            }
        };
        // Register stores and callbacks
        Object.keys(this._modes).forEach((modeId) => {
            this._modes[modeId].register({
                mode: modeId,
                store: this._store,
                setCursor: this._adapter.setCursor,
                project: this._adapter.project,
                unproject: this._adapter.unproject,
                onChange: onChange,
                onSelect: onSelect,
                onDeselect: onDeselect,
            });
        });
        // If we pass in data, we want to render it on startup
        if (options.data) {
            // Remove all non mode features
            const initialRender = this._store.copyAll().filter((feature) => {
                if (feature.properties &&
                    !Object.keys(this._modes).includes(feature.properties.mode)) {
                    this._store.delete([feature.id]);
                    return false;
                }
                return true;
            });
            this._adapter.render({
                created: initialRender,
                deletedIds: [],
                unchanged: [],
                updated: [],
            }, this.getModeStyles());
        }
    }
    getModeStyles() {
        const modeStyles = {};
        Object.keys(this._modes).forEach((mode) => {
            modeStyles[mode] = this._modes[mode].styling;
        });
        return modeStyles;
    }
    setModeStyling(mode, styling) {
        this._modes[mode].styling = styling;
    }
    getSnapshot() {
        return this._store.copyAll();
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(_) {
        throw new Error("Enabled is read only");
    }
    getCurrentMode() {
        return this._mode.mode;
    }
    changeMode(mode) {
        if (this._modes[mode]) {
            // Before we swap modes we want to
            // clean up any state that has been left behind,
            // for example current drawing geometries
            // and mode state
            this._mode.stop();
            // Swap the mode to the new mode
            this._mode = this._modes[mode];
            // Start the new mode
            this._mode.start();
        }
        else {
            // If the mode doesn't exist, we throw an error
            throw new Error("No mode with this name present");
        }
    }
    start() {
        this._enabled = true;
        this._adapter.register({
            onClick: (event) => {
                this._mode.onClick(event);
            },
            onMouseMove: (event) => {
                this._mode.onMouseMove(event);
            },
            onKeyDown: (event) => {
                this._mode.onKeyDown(event);
            },
            onKeyUp: (event) => {
                this._mode.onKeyUp(event);
            },
            onDragStart: (event, setMapDraggability) => {
                this._mode.onDragStart(event, setMapDraggability);
            },
            onDrag: (event) => {
                this._mode.onDrag(event);
            },
            onDragEnd: (event, setMapDraggability) => {
                this._mode.onDragEnd(event, setMapDraggability);
            },
        });
    }
    stop() {
        this._enabled = false;
        this._adapter.unregister();
    }
    on(event, callback) {
        const listeners = this._eventListeners[event];
        if (!listeners.includes(callback)) {
            listeners.push(callback);
        }
    }
    off(event, callback) {
        const listeners = this._eventListeners[event];
        if (listeners.includes(callback)) {
            listeners.splice(listeners.indexOf(callback), 1);
        }
    }
}



/***/ }),

/***/ "../src/util/geoms.ts":
/*!****************************!*\
  !*** ../src/util/geoms.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLineString": () => (/* binding */ createLineString),
/* harmony export */   "createPolygon": () => (/* binding */ createPolygon)
/* harmony export */ });
function createPolygon(coordinates = [
    [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0],
        [0, 0],
    ],
]) {
    return {
        type: "Feature",
        geometry: {
            type: "Polygon",
            coordinates,
        },
        properties: {},
    };
}
function createLineString(coordinates) {
    return {
        type: "Feature",
        geometry: {
            type: "LineString",
            coordinates,
        },
        properties: {},
    };
}


/***/ }),

/***/ "../src/util/id.ts":
/*!*************************!*\
  !*** ../src/util/id.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uuid4": () => (/* binding */ uuid4)
/* harmony export */ });
const uuid4 = function () {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0, v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};


/***/ }),

/***/ "../src/util/styling.ts":
/*!******************************!*\
  !*** ../src/util/styling.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultStyling": () => (/* binding */ getDefaultStyling)
/* harmony export */ });
const getDefaultStyling = () => {
    return {
        polygonFillColor: "#3f97e0",
        polygonOutlineColor: "#3f97e0",
        polygonOutlineWidth: 4,
        polygonFillOpacity: 0.3,
        pointColor: "#3f97e0",
        pointOutlineColor: "#3f97e0",
        pointWidth: 6,
        lineStringColor: "#3f97e0",
        lineStringWidth: 4,
        selectedColor: "#26a9c8",
        selectedPointOutlineColor: "#ffffff",
        selectionPointWidth: 6,
        midPointColor: "#3f97e0",
        midPointOutlineColor: "#ffffff",
        midPointWidth: 4,
    };
};


/***/ }),

/***/ "./node_modules/@turf/area/dist/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/area/dist/es/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ area)
/* harmony export */ });
/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/dist/es/index.js");

// Note: change RADIUS => earthRadius
var RADIUS = 6378137;
/**
 * Takes one or more features and returns their area in square meters.
 *
 * @name area
 * @param {GeoJSON} geojson input GeoJSON feature(s)
 * @returns {number} area in square meters
 * @example
 * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);
 *
 * var area = turf.area(polygon);
 *
 * //addToMap
 * var addToMap = [polygon]
 * polygon.properties.area = area
 */
function area(geojson) {
    return (0,_turf_meta__WEBPACK_IMPORTED_MODULE_0__.geomReduce)(geojson, function (value, geom) {
        return value + calculateArea(geom);
    }, 0);
}
/**
 * Calculate Area
 *
 * @private
 * @param {Geometry} geom GeoJSON Geometries
 * @returns {number} area
 */
function calculateArea(geom) {
    var total = 0;
    var i;
    switch (geom.type) {
        case "Polygon":
            return polygonArea(geom.coordinates);
        case "MultiPolygon":
            for (i = 0; i < geom.coordinates.length; i++) {
                total += polygonArea(geom.coordinates[i]);
            }
            return total;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
            return 0;
    }
    return 0;
}
function polygonArea(coords) {
    var total = 0;
    if (coords && coords.length > 0) {
        total += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            total -= Math.abs(ringArea(coords[i]));
        }
    }
    return total;
}
/**
 * @private
 * Calculate the approximate area of the polygon were it projected onto the earth.
 * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for Polygons on a Sphere",
 * JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409
 *
 * @param {Array<Array<number>>} coords Ring Coordinates
 * @returns {number} The approximate signed geodesic area of the polygon in square meters.
 */
function ringArea(coords) {
    var p1;
    var p2;
    var p3;
    var lowerIndex;
    var middleIndex;
    var upperIndex;
    var i;
    var total = 0;
    var coordsLength = coords.length;
    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {
                // i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength - 1;
                upperIndex = 0;
            }
            else if (i === coordsLength - 1) {
                // i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            }
            else {
                // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i + 1;
                upperIndex = i + 2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
        }
        total = (total * RADIUS * RADIUS) / 2;
    }
    return total;
}
function rad(num) {
    return (num * Math.PI) / 180;
}


/***/ }),

/***/ "./node_modules/@turf/distance/dist/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@turf/distance/dist/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");


//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord | Point} from origin point or coordinate
 * @param {Coord | Point} to destination point or coordinate
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
    if (options === void 0) { options = {}; }
    var coordinates1 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(from);
    var coordinates2 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(to);
    var dLat = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[1] - coordinates1[1]);
    var dLon = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[0] - coordinates1[0]);
    var lat1 = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates1[1]);
    var lat2 = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) +
        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.radiansToLength)(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (distance);


/***/ }),

/***/ "./node_modules/@turf/helpers/dist/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@turf/helpers/dist/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaFactors": () => (/* binding */ areaFactors),
/* harmony export */   "bearingToAzimuth": () => (/* binding */ bearingToAzimuth),
/* harmony export */   "convertArea": () => (/* binding */ convertArea),
/* harmony export */   "convertLength": () => (/* binding */ convertLength),
/* harmony export */   "degreesToRadians": () => (/* binding */ degreesToRadians),
/* harmony export */   "earthRadius": () => (/* binding */ earthRadius),
/* harmony export */   "factors": () => (/* binding */ factors),
/* harmony export */   "feature": () => (/* binding */ feature),
/* harmony export */   "featureCollection": () => (/* binding */ featureCollection),
/* harmony export */   "geometry": () => (/* binding */ geometry),
/* harmony export */   "geometryCollection": () => (/* binding */ geometryCollection),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "lengthToDegrees": () => (/* binding */ lengthToDegrees),
/* harmony export */   "lengthToRadians": () => (/* binding */ lengthToRadians),
/* harmony export */   "lineString": () => (/* binding */ lineString),
/* harmony export */   "lineStrings": () => (/* binding */ lineStrings),
/* harmony export */   "multiLineString": () => (/* binding */ multiLineString),
/* harmony export */   "multiPoint": () => (/* binding */ multiPoint),
/* harmony export */   "multiPolygon": () => (/* binding */ multiPolygon),
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "points": () => (/* binding */ points),
/* harmony export */   "polygon": () => (/* binding */ polygon),
/* harmony export */   "polygons": () => (/* binding */ polygons),
/* harmony export */   "radiansToDegrees": () => (/* binding */ radiansToDegrees),
/* harmony export */   "radiansToLength": () => (/* binding */ radiansToLength),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "unitsFactors": () => (/* binding */ unitsFactors),
/* harmony export */   "validateBBox": () => (/* binding */ validateBBox),
/* harmony export */   "validateId": () => (/* binding */ validateId)
/* harmony export */ });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
var earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1000,
    kilometres: earthRadius / 1000,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1000,
    millimetres: earthRadius * 1000,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
var areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    hectares: 0.0001,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, _options) {
    if (_options === void 0) { _options = {}; }
    switch (type) {
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return (degrees * 180) / Math.PI;
}
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return (radians * Math.PI) / 180;
}
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return !!input && input.constructor === Object;
}
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}


/***/ }),

/***/ "./node_modules/@turf/invariant/dist/es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@turf/invariant/dist/es/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "collectionOf": () => (/* binding */ collectionOf),
/* harmony export */   "containsNumber": () => (/* binding */ containsNumber),
/* harmony export */   "featureOf": () => (/* binding */ featureOf),
/* harmony export */   "geojsonType": () => (/* binding */ geojsonType),
/* harmony export */   "getCoord": () => (/* binding */ getCoord),
/* harmony export */   "getCoords": () => (/* binding */ getCoords),
/* harmony export */   "getGeom": () => (/* binding */ getGeom),
/* harmony export */   "getType": () => (/* binding */ getType)
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" &&
            coord.geometry !== null &&
            coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) &&
        coord.length >= 2 &&
        !Array.isArray(coord[0]) &&
        !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[0]) &&
        (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            value.type);
    }
}
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            feature.geometry.type);
    }
}
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                feature.geometry.type);
        }
    }
}
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}


/***/ }),

/***/ "./node_modules/@turf/length/dist/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@turf/length/dist/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ length)
/* harmony export */ });
/* harmony import */ var _turf_distance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/distance */ "./node_modules/@turf/distance/dist/es/index.js");
/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/dist/es/index.js");


/**
 * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.
 *
 * @name length
 * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers
 * @returns {number} length of GeoJSON
 * @example
 * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);
 * var length = turf.length(line, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line];
 * line.properties.distance = length;
 */
function length(geojson, options) {
    if (options === void 0) { options = {}; }
    // Calculate distance from 2-vertex line segments
    return (0,_turf_meta__WEBPACK_IMPORTED_MODULE_1__.segmentReduce)(geojson, function (previousValue, segment) {
        var coords = segment.geometry.coordinates;
        return previousValue + (0,_turf_distance__WEBPACK_IMPORTED_MODULE_0__["default"])(coords[0], coords[1], options);
    }, 0);
}


/***/ }),

/***/ "./node_modules/@turf/meta/dist/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/meta/dist/es/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coordAll": () => (/* binding */ coordAll),
/* harmony export */   "coordEach": () => (/* binding */ coordEach),
/* harmony export */   "coordReduce": () => (/* binding */ coordReduce),
/* harmony export */   "featureEach": () => (/* binding */ featureEach),
/* harmony export */   "featureReduce": () => (/* binding */ featureReduce),
/* harmony export */   "findPoint": () => (/* binding */ findPoint),
/* harmony export */   "findSegment": () => (/* binding */ findSegment),
/* harmony export */   "flattenEach": () => (/* binding */ flattenEach),
/* harmony export */   "flattenReduce": () => (/* binding */ flattenReduce),
/* harmony export */   "geomEach": () => (/* binding */ geomEach),
/* harmony export */   "geomReduce": () => (/* binding */ geomReduce),
/* harmony export */   "lineEach": () => (/* binding */ lineEach),
/* harmony export */   "lineReduce": () => (/* binding */ lineReduce),
/* harmony export */   "propEach": () => (/* binding */ propEach),
/* harmony export */   "propReduce": () => (/* binding */ propReduce),
/* harmony export */   "segmentEach": () => (/* binding */ segmentEach),
/* harmony export */   "segmentReduce": () => (/* binding */ segmentReduce)
/* harmony export */ });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/dist/es/index.js");


/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
  // Handles null Geometry -- Skips this GeoJSON
  if (geojson === null) return;
  var j,
    k,
    l,
    geometry,
    stopG,
    coords,
    geometryMaybeCollection,
    wrapShrink = 0,
    coordIndex = 0,
    isGeometryCollection,
    type = geojson.type,
    isFeatureCollection = type === "FeatureCollection",
    isFeature = type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[featureIndex].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[geomIndex]
        : geometryMaybeCollection;

      // Handles null Geometry -- Skips this geometry
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;

      wrapShrink =
        excludeWrapCoord &&
        (geomType === "Polygon" || geomType === "MultiPolygon")
          ? 1
          : 0;

      switch (geomType) {
        case null:
          break;
        case "Point":
          if (
            callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (
              callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false
            )
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (
                callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false
              )
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (
                  callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false
                )
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (
              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===
              false
            )
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
  var previousValue = initialValue;
  coordEach(
    geojson,
    function (
      currentCoord,
      coordIndex,
      featureIndex,
      multiFeatureIndex,
      geometryIndex
    ) {
      if (coordIndex === 0 && initialValue === undefined)
        previousValue = currentCoord;
      else
        previousValue = callback(
          previousValue,
          currentCoord,
          coordIndex,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    },
    excludeWrapCoord
  );
  return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
  var i;
  switch (geojson.type) {
    case "FeatureCollection":
      for (i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i].properties, i) === false) break;
      }
      break;
    case "Feature":
      callback(geojson.properties, 0);
      break;
  }
}

/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  propEach(geojson, function (currentProperties, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentProperties;
    else
      previousValue = callback(previousValue, currentProperties, featureIndex);
  });
  return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  featureEach(geojson, function (currentFeature, featureIndex) {
    if (featureIndex === 0 && initialValue === undefined)
      previousValue = currentFeature;
    else previousValue = callback(previousValue, currentFeature, featureIndex);
  });
  return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
  var coords = [];
  coordEach(geojson, function (coord) {
    coords.push(coord);
  });
  return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
  var i,
    j,
    g,
    geometry,
    stopG,
    geometryMaybeCollection,
    isGeometryCollection,
    featureProperties,
    featureBBox,
    featureId,
    featureIndex = 0,
    isFeatureCollection = geojson.type === "FeatureCollection",
    isFeature = geojson.type === "Feature",
    stop = isFeatureCollection ? geojson.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection
      ? geojson.features[i].geometry
      : isFeature
      ? geojson.geometry
      : geojson;
    featureProperties = isFeatureCollection
      ? geojson.features[i].properties
      : isFeature
      ? geojson.properties
      : {};
    featureBBox = isFeatureCollection
      ? geojson.features[i].bbox
      : isFeature
      ? geojson.bbox
      : undefined;
    featureId = isFeatureCollection
      ? geojson.features[i].id
      : isFeature
      ? geojson.id
      : undefined;
    isGeometryCollection = geometryMaybeCollection
      ? geometryMaybeCollection.type === "GeometryCollection"
      : false;
    stopG = isGeometryCollection
      ? geometryMaybeCollection.geometries.length
      : 1;

    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection
        ? geometryMaybeCollection.geometries[g]
        : geometryMaybeCollection;

      // Handle null Geometry
      if (geometry === null) {
        if (
          callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false
        )
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (
            callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false
          )
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (
              callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false
            )
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    // Only increase `featureIndex` per each feature
    featureIndex++;
  }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  geomEach(
    geojson,
    function (
      currentGeometry,
      featureIndex,
      featureProperties,
      featureBBox,
      featureId
    ) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentGeometry;
      else
        previousValue = callback(
          previousValue,
          currentGeometry,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        );
    }
  );
  return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
    // Callback for single geometry
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (
          callback(
            (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geometry, properties, { bbox: bbox, id: id }),
            featureIndex,
            0
          ) === false
        )
          return false;
        return;
    }

    var geomType;

    // Callback for multi-geometry
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }

    for (
      var multiFeatureIndex = 0;
      multiFeatureIndex < geometry.coordinates.length;
      multiFeatureIndex++
    ) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate,
      };
      if (
        callback((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.feature)(geom, properties), featureIndex, multiFeatureIndex) ===
        false
      )
        return false;
    }
  });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  flattenEach(
    geojson,
    function (currentFeature, featureIndex, multiFeatureIndex) {
      if (
        featureIndex === 0 &&
        multiFeatureIndex === 0 &&
        initialValue === undefined
      )
        previousValue = currentFeature;
      else
        previousValue = callback(
          previousValue,
          currentFeature,
          featureIndex,
          multiFeatureIndex
        );
    }
  );
  return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;

    // Exclude null Geometries
    if (!feature.geometry) return;
    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
    var type = feature.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;

    // Generate 2-vertex line segments
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (
      coordEach(
        feature,
        function (
          currentCoord,
          coordIndex,
          featureIndexCoord,
          multiPartIndexCoord,
          geometryIndex
        ) {
          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
          if (
            previousCoords === undefined ||
            featureIndex > previousFeatureIndex ||
            multiPartIndexCoord > previousMultiIndex ||
            geometryIndex > prevGeomIndex
          ) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
            [previousCoords, currentCoord],
            feature.properties
          );
          if (
            callback(
              currentSegment,
              featureIndex,
              multiFeatureIndex,
              geometryIndex,
              segmentIndex
            ) === false
          )
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false
    )
      return false;
  });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentIndex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function (
      currentSegment,
      featureIndex,
      multiFeatureIndex,
      geometryIndex,
      segmentIndex
    ) {
      if (started === false && initialValue === undefined)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
  // validation
  if (!geojson) throw new Error("geojson is required");

  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
    if (feature.geometry === null) return;
    var type = feature.geometry.type;
    var coords = feature.geometry.coordinates;
    switch (type) {
      case "LineString":
        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)
          return false;
        break;
      case "Polygon":
        for (
          var geometryIndex = 0;
          geometryIndex < coords.length;
          geometryIndex++
        ) {
          if (
            callback(
              (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(coords[geometryIndex], feature.properties),
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false
          )
            return false;
        }
        break;
    }
  });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  lineEach(
    geojson,
    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
      if (featureIndex === 0 && initialValue === undefined)
        previousValue = currentLine;
      else
        previousValue = callback(
          previousValue,
          currentLine,
          featureIndex,
          multiFeatureIndex,
          geometryIndex
        );
    }
  );
  return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var segmentIndex = options.segmentIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find SegmentIndex
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [coords[segmentIndex], coords[segmentIndex + 1]],
        properties,
        options
      );
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[geometryIndex][segmentIndex],
          coords[geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (segmentIndex < 0)
        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[multiFeatureIndex][segmentIndex],
          coords[multiFeatureIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (segmentIndex < 0)
        segmentIndex =
          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(
        [
          coords[multiFeatureIndex][geometryIndex][segmentIndex],
          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],
        ],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
  // Optional Parameters
  options = options || {};
  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) throw new Error("options is invalid");
  var featureIndex = options.featureIndex || 0;
  var multiFeatureIndex = options.multiFeatureIndex || 0;
  var geometryIndex = options.geometryIndex || 0;
  var coordIndex = options.coordIndex || 0;

  // Find FeatureIndex
  var properties = options.properties;
  var geometry;

  switch (geojson.type) {
    case "FeatureCollection":
      if (featureIndex < 0)
        featureIndex = geojson.features.length + featureIndex;
      properties = properties || geojson.features[featureIndex].properties;
      geometry = geojson.features[featureIndex].geometry;
      break;
    case "Feature":
      properties = properties || geojson.properties;
      geometry = geojson.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      geometry = geojson;
      break;
    default:
      throw new Error("geojson is invalid");
  }

  // Find Coord Index
  if (geometry === null) return null;
  var coords = geometry.coordinates;
  switch (geometry.type) {
    case "Point":
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords, properties, options);
    case "MultiPoint":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex], properties, options);
    case "LineString":
      if (coordIndex < 0) coordIndex = coords.length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[coordIndex], properties, options);
    case "Polygon":
      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
      if (coordIndex < 0)
        coordIndex = coords[geometryIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[geometryIndex][coordIndex], properties, options);
    case "MultiLineString":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (coordIndex < 0)
        coordIndex = coords[multiFeatureIndex].length + coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(coords[multiFeatureIndex][coordIndex], properties, options);
    case "MultiPolygon":
      if (multiFeatureIndex < 0)
        multiFeatureIndex = coords.length + multiFeatureIndex;
      if (geometryIndex < 0)
        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
      if (coordIndex < 0)
        coordIndex =
          coords[multiFeatureIndex][geometryIndex].length - coordIndex;
      return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(
        coords[multiFeatureIndex][geometryIndex][coordIndex],
        properties,
        options
      );
  }
  throw new Error("geojson is invalid");
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _turf_area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/area */ "./node_modules/@turf/area/dist/es/index.js");
/* harmony import */ var _turf_length__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/length */ "./node_modules/@turf/length/dist/es/index.js");
/* harmony import */ var _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/terra-draw */ "../src/terra-draw.ts");
/* harmony import */ var _common_addModeChangeHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/addModeChangeHandler */ "../common/addModeChangeHandler.ts");
/* harmony import */ var _src_modes_render_render_mode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../src/modes/render/render.mode */ "../src/modes/render/render.mode.ts");






let currentSelected = {
    button: undefined,
    mode: "static",
};
const example = {
    lng: -0.118092,
    lat: 51.509865,
    zoom: 12,
    initialised: [],
    initLeaflet(id) {
        if (this.initialised.includes("leaflet")) {
            return;
        }
        const { lng, lat, zoom } = this;
        const map = leaflet__WEBPACK_IMPORTED_MODULE_0__.map(id, {
            center: [lat, lng],
            zoom: zoom + 1, // starting zoom
        });
        leaflet__WEBPACK_IMPORTED_MODULE_0__.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        }).addTo(map);
        const draw = new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDraw({
            adapter: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawLeafletAdapter({
                lib: leaflet__WEBPACK_IMPORTED_MODULE_0__,
                map,
                coordinatePrecision: 9,
            }),
            modes: {
                select: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawSelectMode({
                    flags: {
                        arbitary: {
                            feature: {},
                        },
                        polygon: {
                            feature: {
                                scaleable: true,
                                rotateable: true,
                                draggable: true,
                                coordinates: {
                                    midpoints: true,
                                    draggable: true,
                                    deletable: true,
                                },
                            },
                        },
                        linestring: {
                            feature: {
                                draggable: true,
                                coordinates: {
                                    midpoints: true,
                                    draggable: true,
                                    deletable: true,
                                },
                            },
                        },
                        circle: {
                            feature: {
                                draggable: true,
                            },
                        },
                        point: {
                            feature: {
                                draggable: true,
                            },
                        },
                        freehand: {
                            feature: {
                                draggable: true,
                            },
                        },
                    },
                }),
                point: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawPointMode(),
                linestring: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawLineStringMode({
                    snapping: true,
                    allowSelfIntersections: false,
                }),
                polygon: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawPolygonMode({
                    // snapping: true,
                    allowSelfIntersections: false,
                }),
                circle: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawCircleMode(),
                freehand: new _src_terra_draw__WEBPACK_IMPORTED_MODULE_3__.TerraDrawFreehandMode(),
                arbitary: new _src_modes_render_render_mode__WEBPACK_IMPORTED_MODULE_5__.TerraDrawRenderMode({
                    styling: {
                        polygonFillColor: "#4357AD",
                        polygonOutlineColor: "#48A9A6",
                        polygonOutlineWidth: 2,
                    },
                }),
            },
        });
        draw.start();
        const getHHMMSS = (timestamp) => new Date(timestamp).toTimeString().split(" ")[0];
        const setInfo = function () {
            const snapshot = draw.getSnapshot();
            const features = snapshot.filter((f) => !f.properties.selectionPoint && !f.properties.midPoint);
            const selected = snapshot.find((f) => f.properties.selected);
            const div = document.getElementById("info");
            if (!div) {
                return;
            }
            div.innerHTML = `
      <div class="current">
        <h3> Current Feature </h3>
        <span><b>ID</b> ${selected ? selected.id : "N/A"} </span>
        <span><b>Geometry Type</b> ${selected ? selected.geometry.type : "N/A"} </span>
        <span><b>Created</b> ${selected ? getHHMMSS(selected.properties.createdAt) : "N/A"} </span>
        <span><b>Updated</b> ${selected ? getHHMMSS(selected.properties.updatedAt) : "N/A"} </span>
        <span><b>Coordinates</b> ${selected && selected.geometry.type === "Polygon"
                ? selected.geometry.coordinates[0].length
                : selected && selected.geometry.type === "LineString"
                    ? selected.geometry.coordinates.length
                    : "N/A"}</b> </span>
        ${selected && selected.geometry.type === "Polygon"
                ? `<span><b>Area (m2)</b> ${(0,_turf_area__WEBPACK_IMPORTED_MODULE_1__["default"])(selected).toFixed(2)} </span>`
                : ""}
        ${selected && selected.geometry.type === "LineString"
                ? `<span><b>Length (km)</b> ${(0,_turf_length__WEBPACK_IMPORTED_MODULE_2__["default"])(selected).toFixed(2)} </span>`
                : ""}
      </div>

      <div class="all">
        <h3> All Features </h3>
        <span><b>Total</b> ${features.length}</span>
        <span><b>Polygons:</b> ${features.filter((f) => f.geometry.type === "Polygon").length}</span>
        <span><b>LineStrings:</b> ${features.filter((f) => f.geometry.type === "LineString").length}</span>
        <span><b>Points:</b> ${features.filter((f) => f.geometry.type === "Point").length}</span>
      </div>
    `;
        };
        setInfo();
        draw.on("change", () => {
            setInfo();
        });
        (0,_common_addModeChangeHandler__WEBPACK_IMPORTED_MODULE_4__.addModeChangeHandler)(draw, currentSelected);
        this.initialised.push("leaflet");
    },
};
example.initLeaflet("leaflet-map");

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCLE9BQU8sc0NBQXNDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsc0JBQXNCLElBQUk7QUFDekUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEcsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUJBQXFCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixlQUFlOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQTJDO0FBQ3pFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekUsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEOztBQUUxRDtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EOztBQUVBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EOztBQUVwRCxpREFBaUQsU0FBUzs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCLGVBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsZ0NBQWdDO0FBQ2hDLHdDQUF3QyxVQUFVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsNkJBQTZCOztBQUU1RTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLHlCQUF5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxJQUFJLElBQUksaUNBQWlDLGtGQUFrRjtBQUNqTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRTtBQUN0RDtBQUNBO0FBQ0EsT0FBTyxFQUFFLHlIQUF5SCwyQ0FBMkMsK0NBQStDLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLHdCQUF3QixFQUFFLDhCQUE4QjtBQUNwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLGlCQUFpQixJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDLDJDQUEyQyx1QkFBdUI7QUFDbEUsc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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LEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxDQUFPLEVBQUUsQ0FBTztJQUNsQyxPQUFPLENBQ0gsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekQsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FDcEQsQ0FBQztBQUNOLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLENBQU8sRUFBRSxDQUFPO0lBQ3RDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFdEMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FB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QUMsQ0FBQyxNQUN4RDtvQ0FFRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxZQUFZLENBQUMsQ0FBQyxNQUMzRDsrQkFFRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsQ0FBQyxNQUN0RDs7S0FFSCxDQUFDO1FBQ0YsQ0FBQyxDQUFDO1FBRUYsT0FBTyxFQUFFLENBQUM7UUFFVixJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUU7WUFDckIsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDLENBQUMsQ0FBQztRQUVILGtGQUFvQixDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztRQUU1QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuQyxDQUFDO0NBQ0YsQ0FBQztBQUVGLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9jb21tb24vYWRkTW9kZUNoYW5nZUhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9hZGFwdGVycy9nb29nbGUtbWFwcy5hZGFwdGVyLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvYWRhcHRlcnMvbGVhZmxldC5hZGFwdGVyLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvYWRhcHRlcnMvbWFwYm94LWdsLmFkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9jb21tb24udHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9ib29sZWFuL3BvaW50LWluLXBvbHlnb24udHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9ib29sZWFuL3NlbGYtaW50ZXJzZWN0cy50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L2NlbnRyb2lkLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvZ2VvbWV0cnkvZ2V0LWNvb3JkaW5hdGVzLWFzLXBvaW50cy50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L2dldC1taWRwb2ludHMudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9oZWxwZXJzLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvZ2VvbWV0cnkvaWRlbnRpY2FsLWNvb3JkaW5hdGVzLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvZ2VvbWV0cnkvbGltaXQtZGVjaW1hbC1wcmVjaXNpb24udHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9tZWFzdXJlL2hhdmVyc2luZS1kaXN0YW5jZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L21lYXN1cmUvcGl4ZWwtZGlzdGFuY2UtdG8tbGluZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L21lYXN1cmUvcGl4ZWwtZGlzdGFuY2UudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9tZWFzdXJlL3JodW1iLWJlYXJpbmcudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9tZWFzdXJlL3JodW1iLWRlc3RpbmF0aW9uLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvZ2VvbWV0cnkvbWVhc3VyZS9yaHVtYi1kaXN0YW5jZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L21pZHBvaW50LWNvb3JkaW5hdGUudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9nZW9tZXRyeS9zaGFwZS9jcmVhdGUtY2lyY2xlLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvZ2VvbWV0cnkvdHJhbnNmb3JtL3JvdGF0ZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL2dlb21ldHJ5L3RyYW5zZm9ybS9zY2FsZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL2Jhc2UuYmVoYXZpb3IudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9iYXNlLm1vZGUudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9jaXJjbGUvY2lyY2xlLm1vZGUudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9jbGljay1ib3VuZGluZy1ib3guYmVoYXZpb3IudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9mcmVlaGFuZC9mcmVlaGFuZC5tb2RlLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvbW9kZXMvbGluZXN0cmluZy9saW5lc3RyaW5nLm1vZGUudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9waXhlbC1kaXN0YW5jZS5iZWhhdmlvci50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3BvaW50L3BvaW50Lm1vZGUudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9wb2x5Z29uL3BvbHlnb24ubW9kZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3JlbmRlci9yZW5kZXIubW9kZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3NlbGVjdC9iZWhhdmlvcnMvZHJhZy1jb29yZGluYXRlLmJlaGF2aW9yLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvbW9kZXMvc2VsZWN0L2JlaGF2aW9ycy9kcmFnLWZlYXR1cmUuYmVoYXZpb3IudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9zZWxlY3QvYmVoYXZpb3JzL2ZlYXR1cmVzLWF0LW1vdXNlLWV2ZW50LmJlaGF2aW9yLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvbW9kZXMvc2VsZWN0L2JlaGF2aW9ycy9taWRwb2ludC5iZWhhdmlvci50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3NlbGVjdC9iZWhhdmlvcnMvcm90YXRlLWZlYXR1cmUuYmVoYXZpb3IudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9zZWxlY3QvYmVoYXZpb3JzL3NjYWxlLWZlYXR1cmUuYmVoYXZpb3IudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9tb2Rlcy9zZWxlY3QvYmVoYXZpb3JzL3NlbGVjdGlvbi1wb2ludC5iZWhhdmlvci50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3NlbGVjdC9zZWxlY3QubW9kZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL21vZGVzL3NuYXBwaW5nLmJlaGF2aW9yLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvbW9kZXMvc3RhdGljL3N0YXRpYy5tb2RlLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvc3RvcmUvc3BhdGlhbC1pbmRleC9xdWlja3NlbGVjdC50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL3N0b3JlL3NwYXRpYWwtaW5kZXgvcmJ1c2gudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9zdG9yZS9zcGF0aWFsLWluZGV4L3NwYXRpYWwtaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy9zdG9yZS9zdG9yZS50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL3RlcnJhLWRyYXcudHMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4uL3NyYy91dGlsL2dlb21zLnRzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uLi9zcmMvdXRpbC9pZC50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi4vc3JjL3V0aWwvc3R5bGluZy50cyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQHR1cmYvYXJlYS9kaXN0L2VzL2luZGV4LmpzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AdHVyZi9kaXN0YW5jZS9kaXN0L2VzL2luZGV4LmpzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AdHVyZi9oZWxwZXJzL2Rpc3QvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2ludmFyaWFudC9kaXN0L2VzL2luZGV4LmpzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9AdHVyZi9sZW5ndGgvZGlzdC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvQHR1cmYvbWV0YS9kaXN0L2VzL2luZGV4LmpzIiwid2VicGFjazovL3RlcnJhLWRyYXctZ2gtZXhhbXBsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vdGVycmEtZHJhdy1naC1leGFtcGxlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90ZXJyYS1kcmF3LWdoLWV4YW1wbGUvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQHByZXNlcnZlXG4gKiBMZWFmbGV0IDEuOC4wLCBhIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHMuIGh0dHBzOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAyMiBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5sZWFmbGV0ID0ge30pKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjEuOC4wXCI7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFV0aWxcclxuICAgKlxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqL1xyXG5cclxuICAvLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbiAgLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuICBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG4gIFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuICBcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG4gIFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcbiAgXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuICBcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZGVzdDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG4gIHZhciBjcmVhdGUkMiA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuICBcdGZ1bmN0aW9uIEYoKSB7fVxyXG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG4gIFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG4gIFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuICBcdH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuICAvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG4gIFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuICBcdGlmIChmbi5iaW5kKSB7XHJcbiAgXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbiAgLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuICB2YXIgbGFzdElkID0gMDtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbiAgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcbiAgXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuICBcdFx0b2JqWydfbGVhZmxldF9pZCddID0gKytsYXN0SWQ7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4gIC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4gIC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcbiAgLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4gIC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuICAvLyBIYXMgYW4gYEwudGhyb3R0bGVgIHNob3J0Y3V0LlxyXG4gIGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcbiAgXHR2YXIgbG9jaywgYXJncywgd3JhcHBlckZuLCBsYXRlcjtcclxuXHJcbiAgXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuICBcdFx0bG9jayA9IGZhbHNlO1xyXG4gIFx0XHRpZiAoYXJncykge1xyXG4gIFx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICBcdFx0XHRhcmdzID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcblxyXG4gIFx0d3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobG9jaykge1xyXG4gIFx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG4gIFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuICBcdFx0XHRmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gIFx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG4gIFx0XHRcdGxvY2sgPSB0cnVlO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiB3cmFwcGVyRm47XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbiAgLy8gYHJhbmdlWzBdYCBhbmQgYHJhbmdlWzFdYC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgYWx3YXlzIHNtYWxsZXIgdGhhblxyXG4gIC8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gIGZ1bmN0aW9uIHdyYXBOdW0oeCwgcmFuZ2UsIGluY2x1ZGVNYXgpIHtcclxuICBcdHZhciBtYXggPSByYW5nZVsxXSxcclxuICBcdCAgICBtaW4gPSByYW5nZVswXSxcclxuICBcdCAgICBkID0gbWF4IC0gbWluO1xyXG4gIFx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZhbHNlRm4oKTogRnVuY3Rpb25cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuICBmdW5jdGlvbiBmYWxzZUZuKCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgd2l0aCBzcGVjaWZpZWQgYHByZWNpc2lvbmAuXHJcbiAgLy8gVGhlIGRlZmF1bHQgYHByZWNpc2lvbmAgdmFsdWUgaXMgNiBkZWNpbWFsIHBsYWNlcy5cclxuICAvLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuICBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBwcmVjaXNpb24pIHtcclxuICBcdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuICBcdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2IDogcHJlY2lzaW9uKTtcclxuICBcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuICAvLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbiAgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuICBcdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuICAvLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuICBcdGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ29wdGlvbnMnKSkge1xyXG4gIFx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlJDIob2JqLm9wdGlvbnMpIDoge307XHJcbiAgXHR9XHJcbiAgXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iajogT2JqZWN0LCBleGlzdGluZ1VybD86IFN0cmluZywgdXBwZXJjYXNlPzogQm9vbGVhbik6IFN0cmluZ1xyXG4gIC8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuICAvLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbiAgLy8gYmUgYXBwZW5kZWQgYXQgdGhlIGVuZC4gSWYgYHVwcGVyY2FzZWAgaXMgYHRydWVgLCB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGxcclxuICAvLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbiAgZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcbiAgXHR2YXIgcGFyYW1zID0gW107XHJcbiAgXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG4gIFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuICB9XHJcblxyXG4gIHZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4gIC8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4gIC8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbiAgLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbiAgLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbiAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcbiAgXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcbiAgXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHZhbHVlO1xyXG4gIFx0fSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbiAgLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG4gIH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4gIC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbiAgLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbiAgLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbiAgLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG4gIHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuICAvLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG4gIFx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbiAgfVxyXG5cclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuICAvLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbiAgZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcbiAgXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG4gIFx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcbiAgXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gIFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxuICB9XHJcblxyXG4gIHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbiAgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcbiAgXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4gIC8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuICAvLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4gIC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuICAvLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbiAgLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcbiAgXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcbiAgXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuICAvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuICBcdGlmIChpZCkge1xyXG4gIFx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG4gIFx0fVxyXG4gIH1cblxuICB2YXIgVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBiaW5kOiBiaW5kLFxuICAgIGdldCBsYXN0SWQgKCkgeyByZXR1cm4gbGFzdElkOyB9LFxuICAgIHN0YW1wOiBzdGFtcCxcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgd3JhcE51bTogd3JhcE51bSxcbiAgICBmYWxzZUZuOiBmYWxzZUZuLFxuICAgIGZvcm1hdE51bTogZm9ybWF0TnVtLFxuICAgIHRyaW06IHRyaW0sXG4gICAgc3BsaXRXb3Jkczogc3BsaXRXb3JkcyxcbiAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zLFxuICAgIGdldFBhcmFtU3RyaW5nOiBnZXRQYXJhbVN0cmluZyxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIGVtcHR5SW1hZ2VVcmw6IGVtcHR5SW1hZ2VVcmwsXG4gICAgcmVxdWVzdEZuOiByZXF1ZXN0Rm4sXG4gICAgY2FuY2VsRm46IGNhbmNlbEZuLFxuICAgIHJlcXVlc3RBbmltRnJhbWU6IHJlcXVlc3RBbmltRnJhbWUsXG4gICAgY2FuY2VsQW5pbUZyYW1lOiBjYW5jZWxBbmltRnJhbWVcbiAgfTtcblxuICAvLyBAY2xhc3MgQ2xhc3NcclxuICAvLyBAYWthIEwuQ2xhc3NcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuICAvLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbiAgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcbiAgXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG4gIFx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcbiAgXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuICBcdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcyk7XHJcblxyXG4gIFx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG4gIFx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcbiAgXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG4gIFx0fTtcclxuXHJcbiAgXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcbiAgXHR2YXIgcHJvdG8gPSBjcmVhdGUkMihwYXJlbnRQcm90byk7XHJcbiAgXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuICBcdE5ld0NsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cclxuICBcdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG4gIFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcbiAgXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuICBcdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuICBcdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcbiAgXHRcdGV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG4gIFx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcbiAgXHRcdGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKHByb3BzLmluY2x1ZGVzKTtcclxuICBcdFx0ZXh0ZW5kLmFwcGx5KG51bGwsIFtwcm90b10uY29uY2F0KHByb3BzLmluY2x1ZGVzKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgXHRleHRlbmQocHJvdG8sIHByb3BzKTtcclxuICBcdGRlbGV0ZSBwcm90by5zdGF0aWNzO1xyXG4gIFx0ZGVsZXRlIHByb3RvLmluY2x1ZGVzO1xyXG5cclxuICBcdC8vIG1lcmdlIG9wdGlvbnNcclxuICBcdGlmIChwcm90by5vcHRpb25zKSB7XHJcbiAgXHRcdHByb3RvLm9wdGlvbnMgPSBwYXJlbnRQcm90by5vcHRpb25zID8gY3JlYXRlJDIocGFyZW50UHJvdG8ub3B0aW9ucykgOiB7fTtcclxuICBcdFx0ZXh0ZW5kKHByb3RvLm9wdGlvbnMsIHByb3BzLm9wdGlvbnMpO1xyXG4gIFx0fVxyXG5cclxuICBcdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcbiAgXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG4gIFx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG4gIFx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG5cclxuICBcdHJldHVybiBOZXdDbGFzcztcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbiAgQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gIFx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbiAgXHRpZiAocHJvcHMub3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLnByb3RvdHlwZS5vcHRpb25zID0gcGFyZW50T3B0aW9ucztcclxuICBcdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuICAvLyBbTWVyZ2VzIGBvcHRpb25zYF0oI2NsYXNzLW9wdGlvbnMpIGludG8gdGhlIGRlZmF1bHRzIG9mIHRoZSBjbGFzcy5cclxuICBDbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0ZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuICAvLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG4gIENsYXNzLmFkZEluaXRIb29rID0gZnVuY3Rpb24gKGZuKSB7IC8vIChGdW5jdGlvbikgfHwgKFN0cmluZywgYXJncy4uLilcclxuICBcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcbiAgXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICBcdH07XHJcblxyXG4gIFx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcbiAgXHR0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzLnB1c2goaW5pdCk7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhpbmNsdWRlcykge1xyXG4gIFx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcbiAgXHRpbmNsdWRlcyA9IGlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuICBcdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG4gIFx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEV2ZW50ZWRcclxuICAgKiBAYWthIEwuRXZlbnRlZFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICAgKiB9ICk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAgICpcclxuICAgKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAgICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcbiAgdmFyIEV2ZW50cyA9IHtcclxuICBcdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcbiAgXHQgKiBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbiAgXHQgKi9cclxuICBcdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcclxuICBcdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuICBcdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcbiAgXHRcdFx0XHQvLyB3ZSBkb24ndCBwcm9jZXNzIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgaGVyZSBmb3IgcGVyZm9ybWFuY2U7XHJcbiAgXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuICBcdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcbiAgXHRcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBtZXRob2Qgb2ZmKHR5cGU6IFN0cmluZywgZm4/OiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgXHQgKlxyXG4gIFx0ICogQGFsdGVybmF0aXZlXHJcbiAgXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG4gIFx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBhbHRlcm5hdGl2ZVxyXG4gIFx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuICBcdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIG9uIHRoZSBvYmplY3QuIFRoaXMgaW5jbHVkZXMgaW1wbGljaXRseSBhdHRhY2hlZCBldmVudHMuXHJcbiAgXHQgKi9cclxuICBcdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuICBcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG4gIFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChyZW1vdmVBbGwpIHtcclxuICBcdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG4gIFx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuICBcdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gIFx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcbiAgXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG4gIFx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICBcdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcbiAgXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG4gIFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuICBcdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuICBcdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG4gIFx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcbiAgXHRcdFx0XHRyZXR1cm47XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0XHR2YXIgbGlzdGVuZXJzLFxyXG4gIFx0XHQgICAgaSxcclxuICBcdFx0ICAgIGxlbjtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuICBcdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IC8vIHJlbW92ZSBhbGxcclxuICBcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcFxyXG4gIFx0XHRcdFx0Ly8gc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcbiAgXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gZmFsc2VGbjtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG4gIFx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcbiAgXHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcbiAgXHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuICBcdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG4gIFx0XHRcdFx0XHRsLmZuID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRcdC8qIGNvcHkgYXJyYXkgaW4gY2FzZSBldmVudHMgYXJlIGJlaW5nIGZpcmVkICovXHJcbiAgXHRcdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuXHJcbiAgXHRcdFx0XHRyZXR1cm47XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGNvbnNvbGUud2FybignbGlzdGVuZXIgbm90IGZvdW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBGaXJlcyBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgZGF0YVxyXG4gIFx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuICBcdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcbiAgXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBldmVudCA9IGV4dGVuZCh7fSwgZGF0YSwge1xyXG4gIFx0XHRcdHR5cGU6IHR5cGUsXHJcbiAgXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG4gIFx0XHRcdHNvdXJjZVRhcmdldDogZGF0YSAmJiBkYXRhLnNvdXJjZVRhcmdldCB8fCB0aGlzXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG4gIFx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG4gIFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuICBcdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuICBcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcbiAgXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcbiAgXHRcdFx0XHR9XHJcblxyXG4gIFx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG4gIFx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuICBcdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcbiAgXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcbiAgXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRjb25zb2xlLndhcm4oJ1wic3RyaW5nXCIgdHlwZSBhcmd1bWVudCBleHBlY3RlZCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gIFx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcbiAgXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuICBcdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcbiAgXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG4gIFx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcbiAgXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG4gIFx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGhhbmRsZXIgPSBiaW5kKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHR0aGlzXHJcbiAgXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG4gIFx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuICBcdFx0fSwgdGhpcyk7XHJcblxyXG4gIFx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcbiAgXHRcdHJldHVybiB0aGlzXHJcbiAgXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG4gIFx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG4gIFx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuICBcdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG4gIFx0XHR0aGlzLl9ldmVudFBhcmVudHNbc3RhbXAob2JqKV0gPSBvYmo7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcbiAgXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tzdGFtcChvYmopXTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuICBcdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBleHRlbmQoe1xyXG4gIFx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG4gIFx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcbiAgXHRcdFx0fSwgZSksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbiAgLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuICBFdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbiAgLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuICAvLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuICAvLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbiAgRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4gIC8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuICBFdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbiAgLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4gIC8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuICBFdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4gIC8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4gIC8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuICBFdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbiAgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb2ludFxyXG4gICAqIEBha2EgTC5Qb2ludFxyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIHBvaW50IHdpdGggYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gICAqIG1hcC5wYW5CeShMLnBvaW50KDIwMCwgMzAwKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYFBvaW50YCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAgICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBQb2ludCh4LCB5LCByb3VuZCkge1xyXG4gIFx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG4gIFx0Ly8gQHByb3BlcnR5IHk6IE51bWJlcjsgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gIFx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xyXG4gIFx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxuICB9O1xyXG5cclxuICBQb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG4gIFx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcbiAgXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG4gIFx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG4gIFx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0dGhpcy54IC89IG51bTtcclxuICBcdFx0dGhpcy55IC89IG51bTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuICBcdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG4gIFx0XHR0aGlzLnggKj0gbnVtO1xyXG4gIFx0XHR0aGlzLnkgKj0gbnVtO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcbiAgXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG4gIFx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuICBcdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuICBcdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG4gIFx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuICBcdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG4gIFx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG4gIFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG4gIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcbiAgXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcbiAgXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCB0cnVuY2F0ZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdG93YXJkcyB6ZXJvKS5cclxuICBcdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG4gIFx0XHR0aGlzLnkgPSB0cnVuYyh0aGlzLnkpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyUG9pbnQ6IFBvaW50KTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG4gIFx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwb2ludCBoYXMgdGhlIHNhbWUgY29vcmRpbmF0ZXMuXHJcbiAgXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG4gIFx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyUG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuICBcdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICdQb2ludCgnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG4gIFx0XHQgICAgICAgIGZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuICAvLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4gIC8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuICAvLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG4gIGZ1bmN0aW9uIHRvUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuICBcdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHg7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheSh4KSkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG4gIFx0fVxyXG4gIFx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcbiAgXHRcdHJldHVybiB4O1xyXG4gIFx0fVxyXG4gIFx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBCb3VuZHNcclxuICAgKiBAYWthIEwuQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICAgKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICAgKiBib3VuZHMgPSBMLmJvdW5kcyhwMSwgcDIpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBgQm91bmRzYCBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogb3RoZXJCb3VuZHMuaW50ZXJzZWN0cyhbWzEwLCAxMF0sIFs0MCwgNjBdXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYEJvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuICBcdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgQm91bmRzLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuICBcdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuICBcdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcbiAgXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcbiAgXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuICBcdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuICBcdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuICBcdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcbiAgXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuICBcdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcbiAgXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG4gIFx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuICBcdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG4gIFx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG4gIFx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuICBcdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuICBcdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcbiAgXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuICBcdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRcdG1pbiA9IG9iai5taW47XHJcbiAgXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuICBcdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG4gIFx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcbiAgXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuICBcdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG4gIFx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcbiAgXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuICBcdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG4gIFx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuICBcdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG4gIFx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuICBcdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuICBcdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuICBcdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG4gIFx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcbiAgXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuICBcdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcbiAgXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuICAvLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4gIC8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuICBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBMYXRMbmdCb3VuZHNcclxuICAgKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAgICpcclxuICAgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgZ2VvZ3JhcGhpY2FsIGFyZWEgb24gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAgICogY29ybmVyMiA9IEwubGF0TG5nKDQwLjc3NCwgLTc0LjEyNSksXHJcbiAgICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFwLmZpdEJvdW5kcyhbXHJcbiAgICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICAgKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAgICogXSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgYExhdExuZ0JvdW5kc2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICAgKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gICAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcbiAgXHRpZiAoIWNvcm5lcjEpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIExhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuICBcdC8vIEBhbHRlcm5hdGl2ZVxyXG4gIFx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG4gIFx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqO1xyXG4gIFx0XHRcdG5lMiA9IG9iajtcclxuXHJcbiAgXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcbiAgXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcbiAgXHRcdFx0bmUyID0gb2JqLl9ub3J0aEVhc3Q7XHJcblxyXG4gIFx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmV0dXJuIG9iaiA/IHRoaXMuZXh0ZW5kKHRvTGF0TG5nKG9iaikgfHwgdG9MYXRMbmdCb3VuZHMob2JqKSkgOiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG4gIFx0XHRcdHRoaXMuX3NvdXRoV2VzdCA9IG5ldyBMYXRMbmcoc3cyLmxhdCwgc3cyLmxuZyk7XHJcbiAgXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG4gIFx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcbiAgXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuICBcdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuICBcdC8vIEZvciBleGFtcGxlLCBhIHJhdGlvIG9mIDAuNSBleHRlbmRzIHRoZSBib3VuZHMgYnkgNTAlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG4gIFx0Ly8gTmVnYXRpdmUgdmFsdWVzIHdpbGwgcmV0cmFjdCB0aGUgYm91bmRzLlxyXG4gIFx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcbiAgXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcbiAgXHRcdCAgICAgICAgbmV3IExhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sYXQgKyB0aGlzLl9ub3J0aEVhc3QubGF0KSAvIDIsXHJcbiAgXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNvdXRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuICBcdGdldE5vcnRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTb3V0aEVhc3QoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcbiAgXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcbiAgXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuICBcdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG4gIFx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG4gIFx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG4gIFx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcbiAgXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuICBcdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcbiAgXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG4gIFx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuICBcdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuICBcdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG4gIFx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuICBcdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcbiAgXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcbiAgXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG4gIFx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcbiAgXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcbiAgXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG4gIFx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG4gIFx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuICBcdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuICBcdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG4gIFx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVxdWl2YWxlbnQgKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikgdG8gdGhlIGdpdmVuIGJvdW5kcy4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpLCBtYXhNYXJnaW4pICYmXHJcbiAgXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gIFx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcbiAgXHR9XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbiAgLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4gIC8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuICBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcbiAgXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG4gIFx0XHRyZXR1cm4gYTtcclxuICBcdH1cclxuICBcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG4gIH1cblxuICAvKiBAY2xhc3MgTGF0TG5nXHJcbiAgICogQGFrYSBMLkxhdExuZ1xyXG4gICAqXHJcbiAgICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIHZhciBsYXRsbmcgPSBMLmxhdExuZyg1MC41LCAzMC41KTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtIGFuZCBzaW1wbGUgb2JqZWN0IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICAgKlxyXG4gICAqIGBgYFxyXG4gICAqIG1hcC5wYW5UbyhbNTAsIDMwXSk7XHJcbiAgICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAgICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAgICogbWFwLnBhblRvKEwubGF0TG5nKDUwLCAzMCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IGBMYXRMbmdgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAgICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICAgKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcbiAgXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG4gIFx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG4gIFx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG4gIFx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuICBcdHRoaXMubG5nID0gK2xuZztcclxuXHJcbiAgXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuICBcdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcbiAgXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0dGhpcy5hbHQgPSArYWx0O1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG4gIFx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuICBcdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuICBcdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG4gIFx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcbiAgXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcbiAgXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuICBcdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlckxhdExuZzogTGF0TG5nKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gIFx0XHRyZXR1cm4gRWFydGguZGlzdGFuY2UodGhpcywgdG9MYXRMbmcob3RoZXIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2l0aCB0aGUgbG9uZ2l0dWRlIHdyYXBwZWQgc28gaXQncyBhbHdheXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcbiAgXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG4gIFx0dG9Cb3VuZHM6IGZ1bmN0aW9uIChzaXplSW5NZXRlcnMpIHtcclxuICBcdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcbiAgXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuICBcdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuICBcdH1cclxuICB9O1xyXG5cclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIHRoZSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChhbmQgb3B0aW9uYWxseSBhbHRpdHVkZSkuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbTnVtYmVyLCBOdW1iZXJdYCBvciBgW051bWJlciwgTnVtYmVyLCBOdW1iZXJdYCBpbnN0ZWFkLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4gIC8vIEV4cGVjdHMgYW4gcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyfWAgb3IgYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXIsIGFsdDogTnVtYmVyfWAgaW5zdGVhZC5cclxuXHJcbiAgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG4gIFx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAoaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAzKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIG51bGw7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuICBcdFx0cmV0dXJuIGE7XHJcbiAgXHR9XHJcbiAgXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uLCBhLmFsdCk7XHJcbiAgXHR9XHJcbiAgXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBudWxsO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkJhc2VcclxuICAgKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICAgKiBnZW9ncmFwaGljYWwgcG9pbnRzIGludG8gcGl4ZWwgKHNjcmVlbikgY29vcmRpbmF0ZXMgYW5kIGJhY2sgKGFuZCB0b1xyXG4gICAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAgICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BhdGlhbF9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICAgKlxyXG4gICAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAgICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gICAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gICAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuICB2YXIgQ1JTID0ge1xyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb1BvaW50KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuICBcdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuICBcdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcbiAgXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuICBcdC8vIHpvb20gaW50byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcbiAgXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHVudHJhbnNmb3JtZWRQb2ludCA9IHRoaXMudHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocG9pbnQsIHNjYWxlKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcbiAgXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuICBcdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG4gIFx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG4gIFx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNjYWxlKHpvb206IE51bWJlcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG4gIFx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG4gIFx0Ly8gYDI1NiAqIDJeem9vbWAgZm9yIE1lcmNhdG9yLWJhc2VkIENSUy5cclxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuICBcdC8vIGZhY3RvciBvZiBgc2NhbGVgLlxyXG4gIFx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcbiAgXHRnZXRQcm9qZWN0ZWRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcbiAgXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gIFx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcbiAgXHRcdCAgICBzID0gdGhpcy5zY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuICBcdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKG1pbiwgbWF4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuICBcdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG4gIFx0Ly9cclxuICBcdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG4gIFx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcbiAgXHQvLyBheGlzIHdyYXBzIGFyb3VuZCBhIGdpdmVuIHJhbmdlIGFuZCBob3cuIERlZmF1bHRzIHRvIGBbLTE4MCwgMTgwXWAgaW4gbW9zdFxyXG4gIFx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcbiAgXHQvL1xyXG4gIFx0Ly8gQHByb3BlcnR5IHdyYXBMYXQ6IE51bWJlcltdXHJcbiAgXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuICBcdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcbiAgXHQvLyB3cmFwTGF0OiBbbWluLCBtYXhdLFxyXG5cclxuICBcdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG4gIFx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuICBcdGluZmluaXRlOiBmYWxzZSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuICBcdC8vIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IHdyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcbiAgXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyB3cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG4gIFx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKGxhdCwgbG5nLCBhbHQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmdcclxuICBcdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuICBcdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcbiAgXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuICBcdFx0ICAgIGxhdFNoaWZ0ID0gY2VudGVyLmxhdCAtIG5ld0NlbnRlci5sYXQsXHJcbiAgXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuICBcdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGJvdW5kcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG4gIFx0XHQgICAgbmUgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcbiAgXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuICBcdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMobmV3U3csIG5ld05lKTtcclxuICBcdH1cclxuICB9O1xuXG4gIC8qXG4gICAqIEBuYW1lc3BhY2UgQ1JTXG4gICAqIEBjcnMgTC5DUlMuRWFydGhcbiAgICpcbiAgICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAgICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAgICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gICAqIG1ldGVycy5cbiAgICovXG5cbiAgdmFyIEVhcnRoID0gZXh0ZW5kKHt9LCBDUlMsIHtcbiAgXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuICBcdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG4gIFx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcbiAgXHQvLyBzZWUgaHR0cHM6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuICBcdFI6IDYzNzEwMDAsXG5cbiAgXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcbiAgXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG4gIFx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuICBcdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcbiAgXHRcdCAgICBzaW5ETG9uID0gTWF0aC5zaW4oKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkIC8gMiksXG4gIFx0XHQgICAgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIHNpbkRMb24gKiBzaW5ETG9uLFxuICBcdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICBcdFx0cmV0dXJuIHRoaXMuUiAqIGM7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gICAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gICAqXHJcbiAgICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICAgKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAgICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbiAgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuICBcdFI6IGVhcnRoUmFkaXVzLFxyXG4gIFx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcbiAgXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuICBcdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuICBcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcbiAgXHR9LFxyXG5cclxuICBcdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG4gIFx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuICBcdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG4gIFx0fSkoKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICAgKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAgICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gICAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAgICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICAgKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gICAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuICAvLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdGlmIChpc0FycmF5KGEpKSB7XHJcbiAgXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcbiAgXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG4gIFx0XHR0aGlzLl9iID0gYVsxXTtcclxuICBcdFx0dGhpcy5fYyA9IGFbMl07XHJcbiAgXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG4gIFx0XHRyZXR1cm47XHJcbiAgXHR9XHJcbiAgXHR0aGlzLl9hID0gYTtcclxuICBcdHRoaXMuX2IgPSBiO1xyXG4gIFx0dGhpcy5fYyA9IGM7XHJcbiAgXHR0aGlzLl9kID0gZDtcclxuICB9XHJcblxyXG4gIFRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuICBcdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG4gIFx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG4gIFx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG4gIFx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcbiAgXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcbiAgXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG4gIFx0XHRyZXR1cm4gcG9pbnQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcbiAgXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuICBcdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcbiAgXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChcclxuICBcdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG4gIFx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbiAgLy8gRXhwZWN0cyBhbiBjb2VmZmljaWVudHMgYXJyYXkgb2YgdGhlIGZvcm1cclxuICAvLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuICBmdW5jdGlvbiB0b1RyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuICBcdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBDUlNcclxuICAgKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAgICpcclxuICAgKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICAgKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICAgKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHMzg1NyA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG4gIFx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG4gIFx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcbiAgXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuICBcdH0oKSlcclxuICB9KTtcclxuXHJcbiAgdmFyIEVQU0c5MDA5MTMgPSBleHRlbmQoe30sIEVQU0czODU3LCB7XHJcbiAgXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbiAgfSk7XG5cbiAgLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4gIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4gIC8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuICAvLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG4gIGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG4gIFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbiAgfVxuXG4gIC8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuICAvLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4gIC8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbiAgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcbiAgXHR2YXIgc3RyID0gJycsXG4gIFx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cbiAgXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdHAgPSBwb2ludHNbal07XG4gIFx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcbiAgXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG4gIFx0fVxuXG4gIFx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3NcbiAgXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbiAgfVxuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAgICogQGFrYSBMLkJyb3dzZXJcclxuICAgKlxyXG4gICAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAgICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuICB2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuICAvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbiAgdmFyIGllbHQ5ID0gaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG4gIHZhciBlZGdlID0gJ21zTGF1bmNoVXJpJyBpbiBuYXZpZ2F0b3IgJiYgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbiAgLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbiAgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuICAvLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbiAgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbiAgdmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4gIC8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxuICB2YXIgd2Via2l0VmVyID0gcGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKTsgLy8gYWxzbyBtYXRjaGVzIEFwcGxlV2ViS2l0XHJcbiAgLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG4gIHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXJcclxuICB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNocm9tZTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgQ2hyb21lIGJyb3dzZXIuXHJcbiAgdmFyIGNocm9tZSA9ICFlZGdlICYmIHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxuICB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBzYWZhcmk6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIFNhZmFyaSBicm93c2VyLlxyXG4gIHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbiAgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbiAgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuICAvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuOyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG4gIHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbiAgLy8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuICB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgdmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG4gIHZhciBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdtb2JpbGUnKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlV2Via2l0ID0gbW9iaWxlICYmIHdlYmtpdDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG4gIHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG4gIHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBwb2ludGVyOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG4gIHZhciBwb2ludGVyID0gISEod2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIpO1xyXG5cclxuICAvLyBAcHJvcGVydHkgdG91Y2hOYXRpdmU6IEJvb2xlYW5cclxuICAvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4gIC8vICoqVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuKiogdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4gIC8vIGEgdG91Y2hzY3JlZW4sIGl0IG9ubHkgbWVhbnMgdGhhdCB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIHVuZGVyc3RhbmRpbmdcclxuICAvLyB0b3VjaCBldmVudHMuXHJcbiAgdmFyIHRvdWNoTmF0aXZlID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8ICEhd2luZG93LlRvdWNoRXZlbnQ7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbiAgLy8gTm90ZTogcG9pbnRlciBldmVudHMgd2lsbCBiZSBwcmVmZXJyZWQgKGlmIGF2YWlsYWJsZSksIGFuZCBwcm9jZXNzZWQgZm9yIGFsbCBgdG91Y2gqYCBsaXN0ZW5lcnMuXHJcbiAgdmFyIHRvdWNoID0gIXdpbmRvdy5MX05PX1RPVUNIICYmICh0b3VjaE5hdGl2ZSB8fCBwb2ludGVyKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuICB2YXIgbW9iaWxlT3BlcmEgPSBtb2JpbGUgJiYgb3BlcmE7XHJcblxyXG4gIC8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbiAgLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxuICB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuICAvLyBAcHJvcGVydHkgcGFzc2l2ZUV2ZW50czogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG4gIHZhciBwYXNzaXZlRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHZhciBzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSBmYWxzZTtcclxuICBcdHRyeSB7XHJcbiAgXHRcdHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICBcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXHJcbiAgXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fSk7XHJcbiAgXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIGZhbHNlRm4sIG9wdHMpO1xyXG4gIFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBmYWxzZUZuLCBvcHRzKTtcclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0Ly8gRXJyb3JzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBzaW5jZSB0aGlzIGlzIG9ubHkgYSBicm93c2VyIHN1cHBvcnQgdGVzdC5cclxuICBcdH1cclxuICBcdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IGNhbnZhczogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbiAgdmFyIGNhbnZhcyQxID0gKGZ1bmN0aW9uICgpIHtcclxuICBcdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbiAgfSgpKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbiAgdmFyIHN2ZyQxID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4gIHZhciBpbmxpbmVTdmcgPSAhIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcbiAgXHRyZXR1cm4gKGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLm5hbWVzcGFjZVVSSSkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4gIC8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuICB2YXIgdm1sID0gIXN2ZyQxICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgXHR0cnkge1xyXG4gIFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuICBcdFx0dmFyIHNoYXBlID0gZGl2LmZpcnN0Q2hpbGQ7XHJcbiAgXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcbiAgXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuICBcdH0gY2F0Y2ggKGUpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIH0oKSk7XHJcblxyXG4gIGZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG4gIFx0cmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cikgPj0gMDtcclxuICB9XHJcblxyXG5cclxuICB2YXIgQnJvd3NlciA9IHtcclxuICBcdGllOiBpZSxcclxuICBcdGllbHQ5OiBpZWx0OSxcclxuICBcdGVkZ2U6IGVkZ2UsXHJcbiAgXHR3ZWJraXQ6IHdlYmtpdCxcclxuICBcdGFuZHJvaWQ6IGFuZHJvaWQsXHJcbiAgXHRhbmRyb2lkMjM6IGFuZHJvaWQyMyxcclxuICBcdGFuZHJvaWRTdG9jazogYW5kcm9pZFN0b2NrLFxyXG4gIFx0b3BlcmE6IG9wZXJhLFxyXG4gIFx0Y2hyb21lOiBjaHJvbWUsXHJcbiAgXHRnZWNrbzogZ2Vja28sXHJcbiAgXHRzYWZhcmk6IHNhZmFyaSxcclxuICBcdHBoYW50b206IHBoYW50b20sXHJcbiAgXHRvcGVyYTEyOiBvcGVyYTEyLFxyXG4gIFx0d2luOiB3aW4sXHJcbiAgXHRpZTNkOiBpZTNkLFxyXG4gIFx0d2Via2l0M2Q6IHdlYmtpdDNkLFxyXG4gIFx0Z2Vja28zZDogZ2Vja28zZCxcclxuICBcdGFueTNkOiBhbnkzZCxcclxuICBcdG1vYmlsZTogbW9iaWxlLFxyXG4gIFx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcbiAgXHRtb2JpbGVXZWJraXQzZDogbW9iaWxlV2Via2l0M2QsXHJcbiAgXHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuICBcdHBvaW50ZXI6IHBvaW50ZXIsXHJcbiAgXHR0b3VjaDogdG91Y2gsXHJcbiAgXHR0b3VjaE5hdGl2ZTogdG91Y2hOYXRpdmUsXHJcbiAgXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcbiAgXHRtb2JpbGVHZWNrbzogbW9iaWxlR2Vja28sXHJcbiAgXHRyZXRpbmE6IHJldGluYSxcclxuICBcdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcbiAgXHRjYW52YXM6IGNhbnZhcyQxLFxyXG4gIFx0c3ZnOiBzdmckMSxcclxuICBcdHZtbDogdm1sLFxyXG4gIFx0aW5saW5lU3ZnOiBpbmxpbmVTdmdcclxuICB9O1xuXG4gIC8qXG4gICAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gICAqL1xuXG4gIHZhciBQT0lOVEVSX0RPV04gPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nO1xuICB2YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbiAgdmFyIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnO1xuICB2YXIgUE9JTlRFUl9DQU5DRUwgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnO1xuICB2YXIgcEV2ZW50ID0ge1xuICBcdHRvdWNoc3RhcnQgIDogUE9JTlRFUl9ET1dOLFxuICBcdHRvdWNobW92ZSAgIDogUE9JTlRFUl9NT1ZFLFxuICBcdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcbiAgXHR0b3VjaGNhbmNlbCA6IFBPSU5URVJfQ0FOQ0VMXG4gIH07XG4gIHZhciBoYW5kbGUgPSB7XG4gIFx0dG91Y2hzdGFydCAgOiBfb25Qb2ludGVyU3RhcnQsXG4gIFx0dG91Y2htb3ZlICAgOiBfaGFuZGxlUG9pbnRlcixcbiAgXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuICBcdHRvdWNoY2FuY2VsIDogX2hhbmRsZVBvaW50ZXJcbiAgfTtcbiAgdmFyIF9wb2ludGVycyA9IHt9O1xuICB2YXIgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4gIC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbiAgLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbiAgZnVuY3Rpb24gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcikge1xuICBcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgXHRcdF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKTtcbiAgXHR9XG4gIFx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuIEwuVXRpbC5mYWxzZUZuO1xuICBcdH1cbiAgXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG4gIFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG4gIFx0cmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG4gIFx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcbiAgXHRcdGNvbnNvbGUud2Fybignd3JvbmcgZXZlbnQgc3BlY2lmaWVkOicsIHR5cGUpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihwRXZlbnRbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG4gIFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuICBcdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG4gIFx0XHRfcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2xvYmFsUG9pbnRlclVwKGUpIHtcbiAgXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRQb2ludGVyRG9jTGlzdGVuZXIoKSB7XG4gIFx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG4gIFx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG4gIFx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcbiAgXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG4gIFx0XHRfcG9pbnRlckRvY0xpc3RlbmVyID0gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihoYW5kbGVyLCBlKSB7XG4gIFx0aWYgKGUucG9pbnRlclR5cGUgPT09IChlLk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8ICdtb3VzZScpKSB7IHJldHVybjsgfVxuXG4gIFx0ZS50b3VjaGVzID0gW107XG4gIFx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcbiAgXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG4gIFx0fVxuICBcdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cbiAgXHRoYW5kbGVyKGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uUG9pbnRlclN0YXJ0KGhhbmRsZXIsIGUpIHtcbiAgXHQvLyBJRTEwIHNwZWNpZmljOiBNc1RvdWNoIG5lZWRzIHByZXZlbnREZWZhdWx0LiBTZWUgIzIwMDBcbiAgXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcbiAgXHR9XG4gIFx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG4gIH1cblxuICAvKlxyXG4gICAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICAgKlxyXG4gICAqIE5vdGU6IGN1cnJlbnRseSBtb3N0IGJyb3dzZXJzIGZpcmUgbmF0aXZlIGRibGNsaWNrLCB3aXRoIG9ubHkgYSBmZXcgZXhjZXB0aW9uc1xyXG4gICAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gICAqL1xyXG5cclxuICBmdW5jdGlvbiBtYWtlRGJsY2xpY2soZXZlbnQpIHtcclxuICBcdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9HZXR0ZXJfb25seVxyXG4gIFx0dmFyIG5ld0V2ZW50ID0ge30sXHJcbiAgXHQgICAgcHJvcCwgaTtcclxuICBcdGZvciAoaSBpbiBldmVudCkge1xyXG4gIFx0XHRwcm9wID0gZXZlbnRbaV07XHJcbiAgXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuICBcdH1cclxuICBcdGV2ZW50ID0gbmV3RXZlbnQ7XHJcbiAgXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuICBcdG5ld0V2ZW50LmRldGFpbCA9IDI7XHJcbiAgXHRuZXdFdmVudC5pc1RydXN0ZWQgPSBmYWxzZTtcclxuICBcdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuICBcdHJldHVybiBuZXdFdmVudDtcclxuICB9XHJcblxyXG4gIHZhciBkZWxheSA9IDIwMDtcclxuICBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpIHtcclxuICBcdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIpO1xyXG5cclxuICBcdC8vIE9uIHNvbWUgcGxhdGZvcm1zIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSBuYXRpdmUgZGJsY2xpY2tzIGZvciB0b3VjaCBldmVudHMuXHJcbiAgXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuICBcdC8vIFNvIGhlcmUgd2UgcmVseSBvbiB0aGF0IGZhY3QgdG8gYXZvaWQgZXhjZXNzaXZlICdkYmxjbGljaycgc2ltdWxhdGlvbiB3aGVuIG5vdCBuZWVkZWQuXHJcbiAgXHR2YXIgbGFzdCA9IDAsXHJcbiAgXHQgICAgZGV0YWlsO1xyXG4gIFx0ZnVuY3Rpb24gc2ltRGJsY2xpY2soZSkge1xyXG4gIFx0XHRpZiAoZS5kZXRhaWwgIT09IDEpIHtcclxuICBcdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcbiAgXHRcdFx0KGUuc291cmNlQ2FwYWJpbGl0aWVzICYmICFlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSkge1xyXG5cclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBub3cgPSBEYXRlLm5vdygpO1xyXG4gIFx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG4gIFx0XHRcdGRldGFpbCsrO1xyXG4gIFx0XHRcdGlmIChkZXRhaWwgPT09IDIpIHtcclxuICBcdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZGV0YWlsID0gMTtcclxuICBcdFx0fVxyXG4gIFx0XHRsYXN0ID0gbm93O1xyXG4gIFx0fVxyXG5cclxuICBcdG9iai5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNpbURibGNsaWNrKTtcclxuXHJcbiAgXHRyZXR1cm4ge1xyXG4gIFx0XHRkYmxjbGljazogaGFuZGxlcixcclxuICBcdFx0c2ltRGJsY2xpY2s6IHNpbURibGNsaWNrXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVycykge1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG4gIFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcnMuc2ltRGJsY2xpY2spO1xyXG4gIH1cblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gICAqXHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gICAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gICAqXHJcbiAgICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gICAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICAgKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAgICovXHJcblxyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuICAvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuICB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcbiAgXHRbJ3RyYW5zZm9ybScsICd3ZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4gIC8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuICAvLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbiAgLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuICBcdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuICAvLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4gIC8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbiAgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuICBcdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICAvLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuICAvLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG4gIGZ1bmN0aW9uIGdldChpZCkge1xyXG4gIFx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4gIC8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuICBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuICBcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuICBcdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcbiAgXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuICBcdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuICBcdH1cclxuICBcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZSQxKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcbiAgXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG4gIFx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuICBcdGlmIChjb250YWluZXIpIHtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICBcdHJldHVybiBlbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG4gIGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG4gIFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgXHRpZiAocGFyZW50KSB7XHJcbiAgXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuICBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG4gIFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICBcdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcbiAgXHR9XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbiAgLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcbiAgXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuICBcdGlmIChwYXJlbnQgJiYgcGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuICBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuICBcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gIFx0aWYgKHBhcmVudCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuICBcdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcbiAgXHR9XHJcbiAgXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG4gIFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdHZhciBjbGFzc2VzID0gc3BsaXRXb3JkcyhuYW1lKTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuICBcdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuICAvLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcbiAgXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdHNldENsYXNzKGVsLCB0cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4gIC8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG4gIFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuICBcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4gIC8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuICBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG4gIFx0Ly8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYW4gU1ZHRWxlbWVudEluc3RhbmNlIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmdFbGVtZW50IGluc3RlYWRcclxuICBcdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuICBcdGlmIChlbC5jb3JyZXNwb25kaW5nRWxlbWVudCkge1xyXG4gIFx0XHRlbCA9IGVsLmNvcnJlc3BvbmRpbmdFbGVtZW50O1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4gIC8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4gIC8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuICBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG4gIFx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG4gIFx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcbiAgXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcbiAgXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcbiAgXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG4gIFx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgXHR0cnkge1xyXG4gIFx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcbiAgXHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG4gIFx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG4gIFx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcbiAgXHR9XHJcblxyXG4gIFx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcbiAgXHRpZiAoZmlsdGVyKSB7XHJcbiAgXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG4gIFx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuICAvLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbiAgLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuICAvLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuICBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG4gIFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbiAgLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuICAvLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbiAgLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbiAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcbiAgXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcbiAgXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuICBcdFx0KEJyb3dzZXIuaWUzZCA/XHJcbiAgXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG4gIFx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG4gIFx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuICAvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4gIC8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbiAgLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG4gIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuICBcdC8qZXNsaW50LWRpc2FibGUgKi9cclxuICBcdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG4gIFx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuICBcdGlmIChCcm93c2VyLmFueTNkKSB7XHJcbiAgXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG4gIFx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuICBcdH1cclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4gIC8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuICBcdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG4gIFx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcbiAgXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbiAgLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4gIC8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuICAvLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4gIC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbiAgdmFyIF91c2VyU2VsZWN0O1xyXG4gIGlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvbih3aW5kb3csICdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICBcdH07XHJcbiAgXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRvZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgXHR9O1xyXG4gIH0gZWxzZSB7XHJcbiAgXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcbiAgXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuICBcdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcbiAgXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG4gIFx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuICBcdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG4gIFx0XHR9XHJcbiAgXHR9O1xyXG4gIFx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG4gIFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcbiAgXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuICBcdH07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbiAgLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4gIC8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG4gIGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvbih3aW5kb3csICdkcmFnc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuICAvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuICBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcbiAgXHRvZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuICAvLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4gIC8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbiAgLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuICAvLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbiAgLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuICBcdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG4gIFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gIFx0fVxyXG4gIFx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG4gIFx0cmVzdG9yZU91dGxpbmUoKTtcclxuICBcdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xyXG4gIFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG4gIFx0b24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbiAgLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuICBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuICBcdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG4gIFx0X291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmUgPSBfb3V0bGluZVN0eWxlO1xyXG4gIFx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gIFx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuICBcdG9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIC8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG4gIGZ1bmN0aW9uIGdldFNpemVkUGFyZW50Tm9kZShlbGVtZW50KSB7XHJcbiAgXHRkbyB7XHJcbiAgXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgXHR9IHdoaWxlICgoIWVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWVsZW1lbnQub2Zmc2V0SGVpZ2h0KSAmJiBlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KTtcclxuICBcdHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFNjYWxlKGVsOiBIVE1MRWxlbWVudCk6IE9iamVjdFxyXG4gIC8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbiAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBtZW1iZXJzIGFzIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjYWxlcyByZXNwZWN0aXZlbHksXHJcbiAgLy8gYW5kIGBib3VuZGluZ0NsaWVudFJlY3RgIGFzIHRoZSByZXN1bHQgb2YgW2BnZXRCb3VuZGluZ0NsaWVudFJlY3QoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCkuXHJcbiAgZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xyXG4gIFx0dmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBSZWFkLW9ubHkgaW4gb2xkIGJyb3dzZXJzLlxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHg6IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEsXHJcbiAgXHRcdHk6IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSxcclxuICBcdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcbiAgXHR9O1xyXG4gIH1cblxuICB2YXIgRG9tVXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgVFJBTlNGT1JNOiBUUkFOU0ZPUk0sXG4gICAgVFJBTlNJVElPTjogVFJBTlNJVElPTixcbiAgICBUUkFOU0lUSU9OX0VORDogVFJBTlNJVElPTl9FTkQsXG4gICAgZ2V0OiBnZXQsXG4gICAgZ2V0U3R5bGU6IGdldFN0eWxlLFxuICAgIGNyZWF0ZTogY3JlYXRlJDEsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIHRvRnJvbnQ6IHRvRnJvbnQsXG4gICAgdG9CYWNrOiB0b0JhY2ssXG4gICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG4gICAgc2V0Q2xhc3M6IHNldENsYXNzLFxuICAgIGdldENsYXNzOiBnZXRDbGFzcyxcbiAgICBzZXRPcGFjaXR5OiBzZXRPcGFjaXR5LFxuICAgIHRlc3RQcm9wOiB0ZXN0UHJvcCxcbiAgICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybSxcbiAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgZ2V0UG9zaXRpb246IGdldFBvc2l0aW9uLFxuICAgIGdldCBkaXNhYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBkaXNhYmxlVGV4dFNlbGVjdGlvbjsgfSxcbiAgICBnZXQgZW5hYmxlVGV4dFNlbGVjdGlvbiAoKSB7IHJldHVybiBlbmFibGVUZXh0U2VsZWN0aW9uOyB9LFxuICAgIGRpc2FibGVJbWFnZURyYWc6IGRpc2FibGVJbWFnZURyYWcsXG4gICAgZW5hYmxlSW1hZ2VEcmFnOiBlbmFibGVJbWFnZURyYWcsXG4gICAgcHJldmVudE91dGxpbmU6IHByZXZlbnRPdXRsaW5lLFxuICAgIHJlc3RvcmVPdXRsaW5lOiByZXN0b3JlT3V0bGluZSxcbiAgICBnZXRTaXplZFBhcmVudE5vZGU6IGdldFNpemVkUGFyZW50Tm9kZSxcbiAgICBnZXRTY2FsZTogZ2V0U2NhbGVcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICAgKi9cclxuXHJcbiAgLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbiAgLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbiAgLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuICAvLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4gIC8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuICBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuICBcdGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHR0eXBlcyA9IHNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuICAvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4gIC8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuICAvLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbiAgLy8gQGFsdGVybmF0aXZlXHJcbiAgLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcpOiB0aGlzXHJcbiAgLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgb2YgZ2l2ZW4gdHlwZXMuXHJcblxyXG4gIC8vIEBhbHRlcm5hdGl2ZVxyXG4gIC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4gIC8vIFJlbW92ZXMgYWxsIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXJzIGZyb20gZ2l2ZW4gSFRNTEVsZW1lbnRcclxuICBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcbiAgXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gIFx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG4gIFx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblxyXG4gIFx0fSBlbHNlIGlmICh0eXBlcyAmJiB0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuICBcdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0dHlwZXMgPSBzcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgXHRcdFx0YmF0Y2hSZW1vdmUob2JqLCBmdW5jdGlvbiAodHlwZSkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIGluZGV4T2YodHlwZXMsIHR5cGUpICE9PSAtMTtcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcbiAgXHRmb3IgKHZhciBpZCBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG4gIFx0XHR2YXIgdHlwZSA9IGlkLnNwbGl0KC9cXGQvKVswXTtcclxuICBcdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG4gIFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGUsIG51bGwsIG51bGwsIGlkKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgdmFyIG1vdXNlU3Vic3QgPSB7XHJcbiAgXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuICBcdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXHJcbiAgXHR3aGVlbDogISgnb253aGVlbCcgaW4gd2luZG93KSAmJiAnbW91c2V3aGVlbCdcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhZGRPbmUob2JqLCB0eXBlLCBmbiwgY29udGV4dCkge1xyXG4gIFx0dmFyIGlkID0gdHlwZSArIHN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG4gIFx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuICBcdH07XHJcblxyXG4gIFx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0Ly8gTmVlZHMgRG9tRXZlbnQuUG9pbnRlci5qc1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRoYW5kbGVyID0gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyKTtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBCcm93c2VyLnBhc3NpdmVFdmVudHMgPyB7cGFzc2l2ZTogZmFsc2V9IDogZmFsc2UpO1xyXG5cclxuICBcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XHJcbiAgXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcbiAgXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9O1xyXG4gIFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb3JpZ2luYWxIYW5kbGVyLCBmYWxzZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG4gIFx0fVxyXG5cclxuICBcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQsIGlkKSB7XHJcbiAgXHRpZCA9IGlkIHx8IHR5cGUgKyBzdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIHN0YW1wKGNvbnRleHQpIDogJycpO1xyXG4gIFx0dmFyIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG4gIFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuICBcdFx0cmVtb3ZlUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlcik7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG4gIFx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuICBcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuICBcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VTdWJzdFt0eXBlXSB8fCB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG4gIFx0fSBlbHNlIHtcclxuICBcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuICBcdH1cclxuXHJcbiAgXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbiAgLy8gYGBganNcclxuICAvLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbiAgLy8gfSk7XHJcbiAgLy8gYGBgXHJcbiAgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcbiAgXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuICBcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICBcdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcbiAgXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcbiAgXHR9IGVsc2Uge1xyXG4gIFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuICBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuICAvLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RibGNsaWNrJ2AsIGAnY29udGV4dG1lbnUnYCxcclxuICAvLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbiAgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuICBcdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2sgY29udGV4dG1lbnUnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG4gIFx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcbiAgXHRyZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbiAgLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4gIC8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuICAvLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4gIC8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICBcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICBcdH1cclxuICBcdHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIHN0b3AoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4gIC8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuICBmdW5jdGlvbiBzdG9wKGUpIHtcclxuICBcdHByZXZlbnREZWZhdWx0KGUpO1xyXG4gIFx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG4gIFx0cmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuICAvLyBHZXRzIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb24gZnJvbSBhIERPTSBldmVudCByZWxhdGl2ZSB0byB0aGVcclxuICAvLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSwgY29udGFpbmVyKSB7XHJcbiAgXHRpZiAoIWNvbnRhaW5lcikge1xyXG4gIFx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICBcdH1cclxuXHJcbiAgXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG4gIFx0ICAgIG9mZnNldCA9IHNjYWxlLmJvdW5kaW5nQ2xpZW50UmVjdDsgLy8gbGVmdCBhbmQgdG9wICB2YWx1ZXMgYXJlIGluIHBhZ2Ugc2NhbGUgKGxpa2UgdGhlIGV2ZW50IGNsaWVudFgvWSlcclxuXHJcbiAgXHRyZXR1cm4gbmV3IFBvaW50KFxyXG4gIFx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcbiAgXHRcdC8vIHdoZXJlYXMgY2xpZW50TGVmdC9Ub3AgKGJvcmRlciB3aWR0aCkgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgdmFsdWVzIChiZWZvcmUgQ1NTIHNjYWxlIGFwcGxpZXMpLlxyXG4gIFx0XHQoZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQpIC8gc2NhbGUueCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG4gIFx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG4gIFx0KTtcclxuICB9XHJcblxyXG4gIC8vIENocm9tZSBvbiBXaW4gc2Nyb2xscyBkb3VibGUgdGhlIHBpeGVscyBhcyBpbiBvdGhlciBwbGF0Zm9ybXMgKHNlZSAjNDUzOCksXHJcbiAgLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG4gIHZhciB3aGVlbFB4RmFjdG9yID1cclxuICBcdChCcm93c2VyLndpbiAmJiBCcm93c2VyLmNocm9tZSkgPyAyICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gOlxyXG4gIFx0QnJvd3Nlci5nZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbiAgLy8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSB3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbiAgLy8gcGl4ZWxzIHNjcm9sbGVkIChuZWdhdGl2ZSBpZiBzY3JvbGxpbmcgZG93bikuXHJcbiAgLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuICAvLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG4gIGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG4gIFx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuICBcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG4gIFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcbiAgXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuICBcdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcbiAgXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcbiAgXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG4gIFx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuICBcdCAgICAgICAwO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbiAgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuICBcdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICBcdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdHRyeSB7XHJcbiAgXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuICBcdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG4gIFx0XHR9XHJcbiAgXHR9IGNhdGNoIChlcnIpIHtcclxuICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gIFx0fVxyXG4gIFx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbiAgfVxuXG4gIHZhciBEb21FdmVudCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHN0b3BQcm9wYWdhdGlvbjogc3RvcFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uLFxuICAgIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uOiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbixcbiAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBnZXRNb3VzZVBvc2l0aW9uLFxuICAgIGdldFdoZWVsRGVsdGE6IGdldFdoZWVsRGVsdGEsXG4gICAgaXNFeHRlcm5hbFRhcmdldDogaXNFeHRlcm5hbFRhcmdldCxcbiAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgcmVtb3ZlTGlzdGVuZXI6IG9mZlxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAgICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICAgKiBAaW5oZXJpdHMgRXZlbnRlZFxuICAgKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICAgKiBmeC5ydW4oZWwsIFszMDAsIDUwMF0sIDAuNSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAY29uc3RydWN0b3IgTC5Qb3NBbmltYXRpb24oKVxuICAgKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKi9cblxuICB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG4gIFx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcbiAgXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG4gIFx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG4gIFx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuICBcdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuICBcdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG4gIFx0XHR0aGlzLnN0b3AoKTtcblxuICBcdFx0dGhpcy5fZWwgPSBlbDtcbiAgXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuICBcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuICBcdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IGdldFBvc2l0aW9uKGVsKTtcbiAgXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuICBcdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICBcdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG4gIFx0XHR0aGlzLl9hbmltYXRlKCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc3RvcCgpXG4gIFx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fc3RlcCh0cnVlKTtcbiAgXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBhbmltYXRpb24gbG9vcFxuICBcdFx0dGhpcy5fYW5pbUlkID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcbiAgXHRcdHRoaXMuX3N0ZXAoKTtcbiAgXHR9LFxuXG4gIFx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuICBcdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuICBcdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG4gIFx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG4gIFx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG4gIFx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuICBcdFx0aWYgKHJvdW5kKSB7XG4gIFx0XHRcdHBvcy5fcm91bmQoKTtcbiAgXHRcdH1cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG4gIFx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cbiAgXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuICBcdH0sXG5cbiAgXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG4gIFx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG4gIFx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG4gIFx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuICBcdH0sXG5cbiAgXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG4gIFx0fVxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBNYXBcclxuICAgKiBAYWthIEwuTWFwXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gICAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAgICogXHR6b29tOiAxM1xyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuICBcdFx0Ly8gVGhlIFtDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1dKCNjcnMpIHRvIHVzZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdFxyXG4gIFx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcbiAgXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNlbnRlcjogTGF0TG5nID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbTogTnVtYmVyID0gdW5kZWZpbmVkXHJcbiAgXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuICBcdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGxvd2VzdCBvZiB0aGVpciBgbWluWm9vbWAgb3B0aW9ucyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICBcdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcbiAgXHRcdC8vIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuICBcdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuICBcdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG4gIFx0XHRsYXllcnM6IFtdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuICBcdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG4gIFx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIGlmIHRoZSB1c2VyIHRyaWVzIHRvIHBhblxyXG4gIFx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuICBcdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG4gIFx0XHRtYXhCb3VuZHM6IHVuZGVmaW5lZCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG4gIFx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcbiAgXHRcdC8vIG9yIGBMLkNhbnZhc2AgYnkgZGVmYXVsdCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0LlxyXG4gIFx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcbiAgXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0em9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG4gIFx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDQsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuICBcdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG4gIFx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG4gIFx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG4gIFx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuICBcdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG4gIFx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG4gIFx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG4gIFx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG4gIFx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG4gIFx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcbiAgXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG4gIFx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcbiAgXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG4gIFx0XHR6b29tU25hcDogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcbiAgXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuICBcdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuICBcdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuICBcdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG4gIFx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG4gIFx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIE1ha2Ugc3VyZSB0byBhc3NpZ24gaW50ZXJuYWwgZmxhZ3MgYXQgdGhlIGJlZ2lubmluZyxcclxuICBcdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcbiAgXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG4gIFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuICBcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuICBcdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG4gIFx0XHR0aGlzLl9vblJlc2l6ZSA9IGJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuICBcdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IFRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG4gIFx0XHRcdFx0dGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XHJcblxyXG4gIFx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuICBcdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuICBcdFx0XHRvbih0aGlzLl9wcm94eSwgVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2FkZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzKTtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFZpZXcoY2VudGVyOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcbiAgXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuICBcdHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG4gIFx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnpvb20gPSBleHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMuem9vbSk7XHJcbiAgXHRcdFx0XHRvcHRpb25zLnBhbiA9IGV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLCBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbn0sIG9wdGlvbnMucGFuKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuICBcdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG4gIFx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG4gIFx0XHRcdGlmIChtb3ZlZCkge1xyXG4gIFx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG4gIFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcbiAgXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcbiAgXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG4gIFx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcbiAgXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG4gIFx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG4gIFx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcbiAgXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG4gIFx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG4gIFx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuICBcdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcbiAgXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG4gIFx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBcdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcbiAgXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG4gIFx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuICBcdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcbiAgXHRcdFx0cmV0dXJuIHtcclxuICBcdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG4gIFx0XHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHRcdH07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG4gIFx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcbiAgXHRcdFx0em9vbTogem9vbVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuICBcdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG4gIFx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuICBcdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG4gIFx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuICBcdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcbiAgXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG4gIFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuICBcdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuICBcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG4gIFx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG4gIFx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG4gIFx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG4gIFx0XHRcdH0sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG4gIFx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcbiAgXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcbiAgXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcbiAgXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG4gIFx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG4gIFx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuICBcdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcbiAgXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG4gIFx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcbiAgXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcbiAgXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuICBcdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG4gIFx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcbiAgXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG4gIFx0XHQgICAgcmhvID0gMS40MixcclxuICBcdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG4gIFx0XHRmdW5jdGlvbiByKGkpIHtcclxuICBcdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG4gIFx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG4gIFx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcbiAgXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG4gIFx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuICBcdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG4gIFx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcbiAgXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcbiAgXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuICBcdFx0XHRyZXR1cm4gbG9nO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuICBcdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuICBcdFx0dmFyIHIwID0gcigwKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcbiAgXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuICBcdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuICBcdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuICBcdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG4gIFx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuICBcdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcbiAgXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcbiAgXHRcdFx0aWYgKHQgPD0gMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRcdHRoaXMuX21vdmUoXHJcbiAgXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcbiAgXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuICBcdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzXHJcbiAgXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcbiAgXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcbiAgXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcbiAgXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbiAgXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG4gIFx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG4gIFx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcbiAgXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG4gIFx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuICBcdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuICBcdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNaW5ab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRNYXhab29tKHpvb206IE51bWJlcik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcbiAgXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG4gIFx0XHR2YXIgb2xkWm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuICBcdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFBhbnMgdGhlIG1hcCB0byB0aGUgY2xvc2VzdCB2aWV3IHRoYXQgd291bGQgbGllIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIChpZiBpdCdzIG5vdCBhbHJlYWR5KSwgY29udHJvbGxpbmcgdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgb3B0aW9ucyBzcGVjaWZpYywgaWYgYW55LlxyXG4gIFx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG4gIFx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcbiAgXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5UbyhuZXdDZW50ZXIsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gUGFucyB0aGUgbWFwIHRoZSBtaW5pbXVtIGFtb3VudCB0byBtYWtlIHRoZSBgbGF0bG5nYCB2aXNpYmxlLiBVc2VcclxuICBcdC8vIHBhZGRpbmcgb3B0aW9ucyB0byBmaXQgdGhlIGRpc3BsYXkgdG8gbW9yZSByZXN0cmljdGVkIGJvdW5kcy5cclxuICBcdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG4gIFx0Ly8gdGhlIG1hcCB3aWxsIG5vdCBiZSBwYW5uZWQuXHJcbiAgXHRwYW5JbnNpZGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuICBcdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG4gIFx0XHQgICAgcGl4ZWxQb2ludCA9IHRoaXMucHJvamVjdChsYXRsbmcpLFxyXG4gIFx0XHQgICAgcGl4ZWxCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcbiAgXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG4gIFx0XHQgICAgcGFkZGVkU2l6ZSA9IHBhZGRlZEJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG4gIFx0XHRpZiAoIXBhZGRlZEJvdW5kcy5jb250YWlucyhwaXhlbFBvaW50KSkge1xyXG4gIFx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcbiAgXHRcdFx0dmFyIGNlbnRlck9mZnNldCA9IHBpeGVsUG9pbnQuc3VidHJhY3QocGFkZGVkQm91bmRzLmdldENlbnRlcigpKTtcclxuICBcdFx0XHR2YXIgb2Zmc2V0ID0gcGFkZGVkQm91bmRzLmV4dGVuZChwaXhlbFBvaW50KS5nZXRTaXplKCkuc3VidHJhY3QocGFkZGVkU2l6ZSk7XHJcbiAgXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuICBcdFx0XHRwaXhlbENlbnRlci55ICs9IGNlbnRlck9mZnNldC55IDwgMCA/IC1vZmZzZXQueSA6IG9mZnNldC55O1xyXG4gIFx0XHRcdHRoaXMucGFuVG8odGhpcy51bnByb2plY3QocGl4ZWxDZW50ZXIpLCBvcHRpb25zKTtcclxuICBcdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShvcHRpb25zOiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG4gIFx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcbiAgXHQvLyBwYW4gYnkgZGVmYXVsdC4gSWYgYG9wdGlvbnMucGFuYCBpcyBgZmFsc2VgLCBwYW5uaW5nIHdpbGwgbm90IG9jY3VyLlxyXG4gIFx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcbiAgXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG4gIFx0Ly8gdGltZXMgaW4gYSByb3cuXHJcblxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcbiAgXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcbiAgXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuICBcdC8vIHBhbiBieSBkZWZhdWx0LlxyXG4gIFx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gZXh0ZW5kKHtcclxuICBcdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuICBcdFx0XHRwYW46IHRydWVcclxuICBcdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuICBcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcbiAgXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcbiAgXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuICBcdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuICBcdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHJlc2l6ZTogUmVzaXplRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuICBcdFx0XHRvbGRTaXplOiBvbGRTaXplLFxyXG4gIFx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuICBcdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcbiAgXHQvLyBTdG9wcyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYHBhblRvYCBvciBgZmx5VG9gIGFuaW1hdGlvbiwgaWYgYW55LlxyXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMuem9vbVNuYXApIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzLl9zdG9wKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuICBcdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcbiAgXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuICBcdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcbiAgXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcbiAgXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcbiAgXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcbiAgXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gIFx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICBcdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBleHRlbmQoe1xyXG4gIFx0XHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG4gIFx0XHRcdHdhdGNoOiBmYWxzZVxyXG4gIFx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcbiAgXHRcdFx0Ly8gbWF4Wm9vbTogPE51bWJlcj5cclxuICBcdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcbiAgXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG4gIFx0XHR9LCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG4gIFx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG4gIFx0XHRcdFx0Y29kZTogMCxcclxuICBcdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuICBcdFx0XHR9KTtcclxuICBcdFx0XHRyZXR1cm4gdGhpcztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIG9uUmVzcG9uc2UgPSBiaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG4gIFx0XHQgICAgb25FcnJvciA9IGJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcbiAgXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG4gIFx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcbiAgXHQvLyBhbmQgYWJvcnRzIHJlc2V0dGluZyB0aGUgbWFwIHZpZXcgaWYgbWFwLmxvY2F0ZSB3YXMgY2FsbGVkIHdpdGhcclxuICBcdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG4gIFx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uICYmIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKSB7XHJcbiAgXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucykge1xyXG4gIFx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG4gIFx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDEgPyAncGVybWlzc2lvbiBkZW5pZWQnIDpcclxuICBcdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpdFdvcmxkKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgbG9jYXRpb25lcnJvcjogRXJyb3JFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuICBcdFx0XHRjb2RlOiBjLFxyXG4gIFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuICBcdFx0fSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGxhdCA9IHBvcy5jb29yZHMubGF0aXR1ZGUsXHJcbiAgXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuICBcdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG4gIFx0XHQgICAgYm91bmRzID0gbGF0bG5nLnRvQm91bmRzKHBvcy5jb29yZHMuYWNjdXJhY3kgKiAyKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zO1xyXG5cclxuICBcdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG4gIFx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcbiAgXHRcdFx0dGhpcy5zZXRWaWV3KGxhdGxuZywgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4oem9vbSwgb3B0aW9ucy5tYXhab29tKSA6IHpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuICBcdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuICBcdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuICBcdFx0fTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG4gIFx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRcdGRhdGFbaV0gPSBwb3MuY29vcmRzW2ldO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZm91bmQ6IExvY2F0aW9uRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuICBcdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcbiAgXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuICBcdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcbiAgXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG4gIFx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICBcdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG4gIFx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0cnkge1xyXG4gIFx0XHRcdC8vIHRocm93cyBlcnJvciBpbiBJRTYtOFxyXG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG4gIFx0XHR9IGNhdGNoIChlKSB7XHJcbiAgXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gIFx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuICBcdFx0XHQvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2NhdGlvbldhdGNoSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fbWFwUGFuZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcbiAgXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcbiAgXHRcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IG51bGw7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG4gIFx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcbiAgXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGk7XHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcbiAgXHRcdH1cclxuICBcdFx0Zm9yIChpIGluIHRoaXMuX3BhbmVzKSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3BhbmVzW2ldKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX3BhbmVzID0gW107XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVQYW5lKG5hbWU6IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcbiAgXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuICBcdC8vIGFzIGEgY2hpbGQgb2YgdGhlIG1haW4gbWFwIHBhbmUgaWYgbm90IHNldC5cclxuICBcdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuICBcdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcbiAgXHRcdCAgICBwYW5lID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyIHx8IHRoaXMuX21hcFBhbmUpO1xyXG5cclxuICBcdFx0aWYgKG5hbWUpIHtcclxuICBcdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHBhbmU7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIEdldHRpbmcgTWFwIFN0YXRlXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG4gIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX2xhc3RDZW50ZXI7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuICBcdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuICBcdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcbiAgXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcbiAgXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuICBcdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG4gIFx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuICBcdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuICBcdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcbiAgXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcbiAgXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcbiAgXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuICBcdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuICBcdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuICBcdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG4gIFx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcbiAgXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuICBcdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG4gIFx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcbiAgXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcbiAgXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG4gIFx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG4gIFx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG4gIFx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG4gIFx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuICBcdFx0aWYgKHNuYXApIHtcclxuICBcdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcbiAgXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcbiAgXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcbiAgXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuICBcdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuICBcdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcbiAgXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG4gIFx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuICBcdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuICBcdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG4gIFx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG4gIFx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcbiAgXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG4gIFx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG4gIFx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG4gIFx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcbiAgXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG4gIFx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcbiAgXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG5cclxuICBcdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG4gIFx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcbiAgXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcbiAgXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuICBcdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcbiAgXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuICBcdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG4gIFx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuICBcdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG4gIFx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcbiAgXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG4gIFx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuICBcdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG4gIFx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcbiAgXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG4gIFx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuICBcdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuICBcdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuICBcdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcbiAgXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG4gIFx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG4gIFx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcbiAgXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuICBcdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuICBcdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcbiAgXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG4gIFx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG4gIFx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuICBcdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG4gIFx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuICBcdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuICBcdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG4gIFx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG4gIFx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcbiAgXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG4gIFx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcbiAgXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG4gIFx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuICBcdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG4gIFx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG4gIFx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRyZXR1cm4gZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG4gIFx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG4gIFx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG4gIFx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcbiAgXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG4gIFx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuICBcdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcbiAgXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBnZXQoaWQpO1xyXG5cclxuICBcdFx0aWYgKCFjb250YWluZXIpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gc3RhbXAoY29udGFpbmVyKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcbiAgXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG4gIFx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG4gIFx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcbiAgXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG4gIFx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG4gIFx0XHR2YXIgcG9zaXRpb24gPSBnZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuICBcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcbiAgXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuICBcdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuICBcdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcbiAgXHRcdC8vIFtgbWFwLmdldFBhbmVzYF0oI21hcC1nZXRwYW5lcykgbWV0aG9kcy4gTmV3IHBhbmVzIGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlXHJcbiAgXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuICBcdFx0Ly9cclxuICBcdFx0Ly8gRXZlcnkgbWFwIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHQgcGFuZXMgdGhhdCBkaWZmZXIgb25seSBpbiB6SW5kZXguXHJcbiAgXHRcdC8vXHJcbiAgXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcbiAgXHRcdC8vIFBhbmUgdGhhdCBjb250YWlucyBhbGwgb3RoZXIgbWFwIHBhbmVzXHJcblxyXG4gIFx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBgR3JpZExheWVyYHMgYW5kIGBUaWxlTGF5ZXJgc1xyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciB2ZWN0b3JzIChgUGF0aGBzLCBsaWtlIGBQb2x5bGluZWBzIGFuZCBgUG9seWdvbmBzKSwgYEltYWdlT3ZlcmxheWBzIGFuZCBgVmlkZW9PdmVybGF5YHNcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG4gIFx0XHQvLyBQYW5lIGZvciBvdmVybGF5IHNoYWRvd3MgKGUuZy4gYE1hcmtlcmAgc2hhZG93cylcclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcbiAgXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcbiAgXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuICBcdFx0Ly8gUGFuZSBmb3IgYFRvb2x0aXBgcy5cclxuICBcdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG4gIFx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcbiAgXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG4gIFx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHRcdGFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuXHJcbiAgXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0c2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcbiAgXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuICBcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuICBcdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcbiAgXHRcdHRoaXMuZmlyZSgndmlld3ByZXJlc2V0Jyk7XHJcblxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG4gIFx0XHR0aGlzXHJcbiAgXHRcdFx0Ll9tb3ZlU3RhcnQoem9vbUNoYW5nZWQsIGZhbHNlKVxyXG4gIFx0XHRcdC5fbW92ZShjZW50ZXIsIHpvb20pXHJcbiAgXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcbiAgXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBuZWVkcyB0byByZWRyYXcgaXRzIGNvbnRlbnQgKHRoaXMgdXN1YWxseSBoYXBwZW5zXHJcbiAgXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuICBcdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuICBcdFx0aWYgKGxvYWRpbmcpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcbiAgXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG4gIFx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmICghbm9Nb3ZlU3RhcnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSwgc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuICBcdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuICBcdFx0fVxyXG4gIFx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuICBcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcbiAgXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcbiAgXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuICBcdFx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcbiAgXHRcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0XHR9XHJcblxyXG4gIFx0XHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLFxyXG4gIFx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG4gIFx0XHRcdHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5waW5jaCkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcbiAgXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmdcclxuICBcdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuICBcdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuICBcdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcbiAgXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuICBcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG4gIFx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuICBcdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG4gIFx0XHR0aGlzLl90YXJnZXRzW3N0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IG9mZiA6IG9uO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG4gIFx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcbiAgXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuICBcdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuICBcdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG4gIFx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcbiAgXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgdGhhdCBwcm9kdWNlcyBhIGNoYXJhY3RlciB2YWx1ZSB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcbiAgXHRcdC8vIEBldmVudCBrZXlkb3duOiBLZXlib2FyZEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuICBcdFx0Ly8gdGhlIGBrZXlkb3duYCBldmVudCBpcyBmaXJlZCBmb3Iga2V5cyB0aGF0IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUgYW5kIGZvciBrZXlzXHJcbiAgXHRcdC8vIHRoYXQgZG8gbm90IHByb2R1Y2UgYSBjaGFyYWN0ZXIgdmFsdWUuXHJcbiAgXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuICBcdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcbiAgXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuICBcdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuICBcdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUoXHJcbiAgXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcbiAgXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG4gIFx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcbiAgXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuICBcdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuICBcdFx0ICAgIHRhcmdldCxcclxuICBcdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG4gIFx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG4gIFx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHdoaWxlIChzcmMpIHtcclxuICBcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3N0YW1wKHNyYyldO1xyXG4gIFx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG4gIFx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcbiAgXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcbiAgXHRcdFx0XHRicmVhaztcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG4gIFx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIWlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG4gIFx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuICBcdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiB0aGlzLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0YXJnZXRzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuICBcdFx0d2hpbGUgKGVsICE9PSB0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHRpZiAoZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG4gIFx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBlbFsnX2xlYWZsZXRfZGlzYWJsZV9ldmVudHMnXSB8fCBlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy5faXNDbGlja0Rpc2FibGVkKGVsKSkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuICBcdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuICBcdFx0XHRwcmV2ZW50T3V0bGluZShlbCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuICBcdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG4gIFx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcbiAgXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuICBcdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuICBcdFx0XHR2YXIgc3ludGggPSBleHRlbmQoe30sIGUpO1xyXG4gIFx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG4gIFx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgY2FudmFzVGFyZ2V0cyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuICBcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpO1xyXG5cclxuICBcdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuICBcdFx0XHR2YXIgZmlsdGVyZWQgPSBbXTsgLy8gcGljayBvbmx5IHRhcmdldHMgd2l0aCBsaXN0ZW5lcnNcclxuICBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc1RhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuICBcdFx0XHRcdFx0ZmlsdGVyZWQucHVzaChjYW52YXNUYXJnZXRzW2ldKTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGFyZ2V0cyA9IGZpbHRlcmVkLmNvbmNhdCh0YXJnZXRzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnKSB7XHJcbiAgXHRcdFx0cHJldmVudERlZmF1bHQoZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnICYmIGUudHlwZSAhPT0gJ2tleWRvd24nICYmIGUudHlwZSAhPT0gJ2tleXVwJykge1xyXG4gIFx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcbiAgXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuICBcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuICBcdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG4gIFx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuICBcdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcbiAgXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIGluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuICBcdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuICBcdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gIFx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcbiAgXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcbiAgXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcblxyXG4gIFx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuICBcdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBnZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG4gIFx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuICBcdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcbiAgXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcbiAgXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG4gIFx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcbiAgXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuICBcdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuICBcdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcbiAgXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuICBcdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcbiAgXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG4gIFx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuICBcdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuICBcdFx0XSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG4gIFx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG4gIFx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcbiAgXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuICBcdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuICBcdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG4gIFx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuICBcdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcbiAgXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuICBcdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcbiAgXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG4gIFx0XHRcdHJldHVybiBjZW50ZXI7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuICBcdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcbiAgXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcbiAgXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG4gIFx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG4gIFx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuICBcdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG4gIFx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcbiAgXHRcdCAgICApLFxyXG4gIFx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG4gIFx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuICBcdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuICBcdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcbiAgXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gIFx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcbiAgXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcbiAgXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuICBcdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG4gIFx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcbiAgXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcbiAgXHRcdGlmIChzbmFwKSB7XHJcbiAgXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuICBcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG4gIFx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX3RydW5jKCk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICBcdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4gIFx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBjcmVhdGUkMSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuICBcdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRcdHZhciBwcm9wID0gVFJBTlNGT1JNLFxyXG4gIFx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcbiAgXHRcdFx0c2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuICBcdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG4gIFx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuICBcdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmUodGhpcy5fcHJveHkpO1xyXG4gIFx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcbiAgXHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuICBcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuICBcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuICBcdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuICBcdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG4gIFx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG4gIFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuICBcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdFx0dGhpc1xyXG4gIFx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBmYWxzZSlcclxuICBcdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG4gIFx0XHR9LCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIHN0YXJ0QW5pbSwgbm9VcGRhdGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXBQYW5lKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG4gIFx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuICBcdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuICBcdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcbiAgXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGF0IGxlYXN0IG9uY2UgcGVyIHpvb20gYW5pbWF0aW9uLiBGb3IgY29udGludW91cyB6b29tLCBsaWtlIHBpbmNoIHpvb21pbmcsIGZpcmVkIG9uY2UgcGVyIGZyYW1lIGR1cmluZyB6b29tLlxyXG4gIFx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG4gIFx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG4gIFx0XHRcdHpvb206IHpvb20sXHJcbiAgXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG4gIFx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcbiAgXHRcdHNldFRpbWVvdXQoYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuICBcdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fdGVtcEZpcmVab29tRXZlbnQpIHtcclxuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5fdGVtcEZpcmVab29tRXZlbnQ7XHJcblxyXG4gIFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBzZWN0aW9uXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgLy9cclxuICAvLyBAYWx0ZXJuYXRpdmVcclxuICAvLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuICAvLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbiAgZnVuY3Rpb24gY3JlYXRlTWFwKGlkLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2xcclxuICAgKiBAYWthIEwuQ29udHJvbFxyXG4gICAqIEBpbmhlcml0cyBDbGFzc1xyXG4gICAqXHJcbiAgICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICAgKiBBbGwgb3RoZXIgY29udHJvbHMgZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cclxuICAgKi9cclxuXHJcbiAgdmFyIENvbnRyb2wgPSBDbGFzcy5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuICBcdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuICBcdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuICBcdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICpcclxuICBcdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG4gIFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcbiAgXHQgKi9cclxuICBcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG4gIFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuICBcdFx0aWYgKG1hcCkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgXHRcdGlmIChtYXApIHtcclxuICBcdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5yZW1vdmUoKTtcclxuICBcdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuICBcdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuICBcdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuICBcdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuICBcdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub24oJ3VubG9hZCcsIHRoaXMucmVtb3ZlLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9uUmVtb3ZlKSB7XHJcbiAgXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAub2ZmKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcbiAgXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiBlICYmIGUuc2NyZWVuWCA+IDAgJiYgZS5zY3JlZW5ZID4gMCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIHZhciBjb250cm9sID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxuICB9O1xyXG5cclxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gICAqIEB1bmluaGVyaXRhYmxlXHJcbiAgICpcclxuICAgKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAgICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAgICpcclxuICAgKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICAgKi9cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAgICovXHJcbiAgTWFwLmluY2x1ZGUoe1xyXG4gIFx0Ly8gQG1ldGhvZCBhZGRDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuICBcdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUNvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcbiAgXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gIFx0XHRjb250cm9sLnJlbW92ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuICBcdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcbiAgXHRcdCAgICAgICAgICAgIGNyZWF0ZSQxKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuICBcdFx0XHR2YXIgY2xhc3NOYW1lID0gbCArIHZTaWRlICsgJyAnICsgbCArIGhTaWRlO1xyXG5cclxuICBcdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG4gIFx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcbiAgXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9jb250cm9sQ29ybmVycykge1xyXG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9jb250cm9sQ29ybmVyc1tpXSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG4gIFx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250cm9sQ29udGFpbmVyO1xyXG4gIFx0fVxyXG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAgICogQGluaGVyaXRzIENvbnRyb2xcclxuICAgKlxyXG4gICAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICAgKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICAgKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICAgKiB9O1xyXG4gICAqXHJcbiAgICogdmFyIG92ZXJsYXlzID0ge1xyXG4gICAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gICAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcclxuICAgKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAgICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIsIHRvdWNoLCBvciBrZXlib2FyZCBhY3RpdmF0aW9uLlxyXG4gIFx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcbiAgXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG4gIFx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcbiAgXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc29ydExheWVyczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcbiAgXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuICBcdFx0c29ydExheWVyczogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcbiAgXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcbiAgXHRcdC8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXllcnMsIHdoZW4gYHNvcnRMYXllcnNgIGlzIGB0cnVlYC5cclxuICBcdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG4gIFx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgaXQgc29ydHMgbGF5ZXJzIGFscGhhYmV0aWNhbGx5IGJ5IHRoZWlyIG5hbWUuXHJcbiAgXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuICBcdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMgPSBbXTtcclxuICBcdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG4gIFx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuICBcdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcbiAgXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcbiAgXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICBcdH0sXHJcblxyXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuICBcdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcbiAgXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuICBcdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG4gIFx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcbiAgXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAobGF5ZXIpKTtcclxuICBcdFx0aWYgKG9iaikge1xyXG4gIFx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcbiAgXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuICBcdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuICBcdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuICBcdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9zZWN0aW9uLmNsaWVudEhlaWdodCkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX3NlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG4gIFx0XHRcdHRoaXMuX3NlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcbiAgXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcbiAgXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG4gIFx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXHJcbiAgXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuICBcdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG4gIFx0XHRkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG4gIFx0XHRkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IGNyZWF0ZSQxKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG4gIFx0XHRpZiAoY29sbGFwc2VkKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuICBcdFx0XHRvbihjb250YWluZXIsIHtcclxuICBcdFx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdFx0b24oc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdFx0XHRvZmYoc2VjdGlvbiwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH0sXHJcbiAgXHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IGNyZWF0ZSQxKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG4gIFx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcbiAgXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblxyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBwcmV2ZW50RGVmYXVsdCk7IC8vIHByZXZlbnQgbGluayBmdW5jdGlvblxyXG4gIFx0XHRvbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG4gIFx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIHNlY3Rpb24pO1xyXG4gIFx0XHR0aGlzLl9zZXBhcmF0b3IgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lICsgJy1zZXBhcmF0b3InLCBzZWN0aW9uKTtcclxuICBcdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcbiAgXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMuX2xheWVyc1tpXSAmJiBzdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdGxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuICBcdFx0XHRsYXllcjogbGF5ZXIsXHJcbiAgXHRcdFx0bmFtZTogbmFtZSxcclxuICBcdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG4gIFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG4gIFx0XHRcdH0sIHRoaXMpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RaSW5kZXgrKztcclxuICBcdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGVtcHR5KHRoaXMuX2Jhc2VMYXllcnNMaXN0KTtcclxuICBcdFx0ZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG4gIFx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuICBcdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcbiAgXHRcdFx0b3ZlcmxheXNQcmVzZW50ID0gb3ZlcmxheXNQcmVzZW50IHx8IG9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG4gIFx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuICBcdFx0XHRiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50ICYmIGJhc2VMYXllcnNDb3VudCA+IDE7XHJcbiAgXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3NlcGFyYXRvci5zdHlsZS5kaXNwbGF5ID0gb3ZlcmxheXNQcmVzZW50ICYmIGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X29uTGF5ZXJDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoc3RhbXAoZS50YXJnZXQpKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgYmFzZWxheWVyY2hhbmdlOiBMYXllcnNDb250cm9sRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVycyBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG4gIFx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBkZXNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBDb250cm9sLkxheWVyc1xyXG4gIFx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuICBcdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG4gIFx0XHRcdChlLnR5cGUgPT09ICdhZGQnID8gJ2Jhc2VsYXllcmNoYW5nZScgOiBudWxsKTtcclxuXHJcbiAgXHRcdGlmICh0eXBlKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwNzkpXHJcbiAgXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuICBcdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG4gIFx0XHRcdFx0bmFtZSArICdcIicgKyAoY2hlY2tlZCA/ICcgY2hlY2tlZD1cImNoZWNrZWRcIicgOiAnJykgKyAnLz4nO1xyXG5cclxuICBcdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBcdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG4gIFx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG4gIFx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG4gIFx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG4gIFx0XHQgICAgaW5wdXQ7XHJcblxyXG4gIFx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuICBcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcbiAgXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcbiAgXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG4gIFx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVyc18nICsgc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcbiAgXHRcdGlucHV0LmxheWVySWQgPSBzdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuICBcdFx0b24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG4gIFx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICBcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcbiAgXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcbiAgXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblxyXG4gIFx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gIFx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuICBcdFx0cmV0dXJuIGxhYmVsO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcbiAgXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcbiAgXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG4gIFx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuICBcdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcbiAgXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuICBcdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuICBcdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG4gIFx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG4gIFx0XHQgICAgaW5wdXQsXHJcbiAgXHRcdCAgICBsYXllcixcclxuICBcdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gIFx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG4gIFx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcbiAgXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuICBcdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuICBcdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBsYXllcnMgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbiAgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgLypcclxuICAgKiBAY2xhc3MgQ29udHJvbC5ab29tXHJcbiAgICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAgICovXHJcblxyXG4gIHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPis8L3NwYW4+J1xyXG4gIFx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcbiAgXHRcdHpvb21JblRleHQ6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4rPC9zcGFuPicsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuICBcdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuICBcdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mI3gyMjEyOzwvc3Bhbj4nXHJcbiAgXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcbiAgXHRcdHpvb21PdXRUZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JiN4MjIxMjs8L3NwYW4+JyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcbiAgXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG4gIFx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuICBcdFx0ICAgIGNvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuICBcdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gIFx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuICBcdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG4gIFx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG4gIFx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuICBcdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuICBcdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcbiAgXHRcdHZhciBsaW5rID0gY3JlYXRlJDEoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcbiAgXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuICBcdFx0bGluay5ocmVmID0gJyMnO1xyXG4gIFx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG4gIFx0XHQgKi9cclxuICBcdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcbiAgXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHN0b3ApO1xyXG4gIFx0XHRvbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcbiAgXHRcdG9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gbGluaztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcbiAgXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcbiAgXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuICBcdFx0dGhpcy5fem9vbU91dEJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuICBcdFx0XHRhZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG4gIFx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbiAgLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuICAvLyBXaGV0aGVyIGEgW3pvb20gY29udHJvbF0oI2NvbnRyb2wtem9vbSkgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0em9vbUNvbnRyb2w6IHRydWVcclxuICB9KTtcclxuXHJcbiAgTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuICBcdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuICBcdFx0Ly8gQHNlY3Rpb24gQ29udHJvbHNcclxuICBcdFx0Ly8gQHByb3BlcnR5IHpvb21Db250cm9sOiBDb250cm9sLlpvb21cclxuICBcdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuICBcdFx0Ly8gW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB3YXMgYHRydWVgIHdoZW4gY3JlYXRpbmcgdGhlIG1hcCkuXHJcbiAgXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG4gIFx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbiAgLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG4gIHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxuICB9O1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gICAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gICAqIEBpbmhlcml0cyBDb250cm9sXG4gICAqXG4gICAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICAgKiBgYGBcbiAgICovXG5cbiAgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDb250cm9sLlNjYWxlIG9wdGlvbnNcbiAgXHRvcHRpb25zOiB7XG4gIFx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAxMDBcbiAgXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuICBcdFx0bWF4V2lkdGg6IDEwMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtZXRyaWM6IEJvb2xlYW4gPSBUcnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cbiAgXHRcdG1ldHJpYzogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBpbXBlcmlhbDogQm9vbGVhbiA9IFRydWVcbiAgXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuICBcdFx0aW1wZXJpYWw6IHRydWVcblxuICBcdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG4gIFx0XHQgICAgY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsIGNsYXNzTmFtZSksXG4gIFx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cbiAgXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuICBcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG4gIFx0XHRyZXR1cm4gY29udGFpbmVyO1xuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICBcdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG4gIFx0XHRcdHRoaXMuX21TY2FsZSA9IGNyZWF0ZSQxKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG4gIFx0XHR9XG4gIFx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuICBcdFx0XHR0aGlzLl9pU2NhbGUgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG4gIFx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuICBcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuICBcdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG4gIFx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG4gIFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcbiAgXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuICBcdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuICBcdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG4gIFx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG4gIFx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuICBcdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG4gIFx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuICBcdH0sXG5cbiAgXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcbiAgXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuICBcdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuICBcdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG4gIFx0XHQgICAgZCA+PSA1ID8gNSA6XG4gIFx0XHQgICAgZCA+PSAzID8gMyA6XG4gIFx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cbiAgXHRcdHJldHVybiBwb3cxMCAqIGQ7XG4gIFx0fVxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciB1a3JhaW5pYW5GbGFnID0gJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCI4XCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICAgKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gICAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAgICpcclxuICAgKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICAgKi9cclxuXHJcbiAgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZ3xmYWxzZSA9ICdMZWFmbGV0J1xyXG4gIFx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHBzOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj4nICsgKEJyb3dzZXIuaW5saW5lU3ZnID8gdWtyYWluaWFuRmxhZyArICcgJyA6ICcnKSArICdMZWFmbGV0PC9hPidcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuICBcdFx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcbiAgXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuICBcdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG4gIFx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0bWFwLm9uKCdsYXllcmFkZCcsIHRoaXMuX2FkZEF0dHJpYnV0aW9uLCB0aGlzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYWRkQXR0cmlidXRpb246IGZ1bmN0aW9uIChldikge1xyXG4gIFx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKGV2LmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG4gIFx0XHRcdGV2LmxheWVyLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICBcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcbiAgXHRcdFx0fSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmd8ZmFsc2UpOiB0aGlzXHJcbiAgXHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICBcdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuICBcdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG4gIFx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG4gIFx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG4gIFx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG4gIFx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuICBcdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG4gIFx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuICBcdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnw8L3NwYW4+ICcpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIC8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4gIC8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4gIC8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuICBNYXAubWVyZ2VPcHRpb25zKHtcclxuICBcdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG4gIH0pO1xyXG5cclxuICBNYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG4gIFx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuICBcdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gIC8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbiAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG4gIHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG4gIH07XG5cbiAgQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG4gIENvbnRyb2wuWm9vbSA9IFpvb207XG4gIENvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbiAgQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG4gIGNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuICBjb250cm9sLnpvb20gPSB6b29tO1xuICBjb250cm9sLnNjYWxlID0gc2NhbGU7XG4gIGNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuICAvKlxuICBcdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG4gIFx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4gICovXG5cbiAgLy8gQGNsYXNzIEhhbmRsZXJcbiAgLy8gQGFrYSBMLkhhbmRsZXJcbiAgLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG4gIHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcbiAgXHQvLyBFbmFibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG4gIFx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuYWRkSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuICBcdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG4gIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGVuYWJsZWQoKTogQm9vbGVhblxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcbiAgXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuICBcdH1cblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gQ2xhc3NlcyBpbmhlcml0aW5nIGZyb20gYEhhbmRsZXJgIG11c3QgaW1wbGVtZW50IHRoZSB0d28gZm9sbG93aW5nIG1ldGhvZHM6XG4gIFx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUhvb2tzKClcbiAgXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gVGhlcmUgaXMgc3RhdGljIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuSGFuZGxlcjpcbiAgLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4gIC8vIEFkZHMgYSBuZXcgSGFuZGxlciB0byB0aGUgZ2l2ZW4gbWFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gIEhhbmRsZXIuYWRkVG8gPSBmdW5jdGlvbiAobWFwLCBuYW1lKSB7XG4gIFx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIE1peGluID0ge0V2ZW50czogRXZlbnRzfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICAgKiBAYWthIEwuRHJhZ2dhYmxlXHJcbiAgICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICAgKlxyXG4gICAqIEEgY2xhc3MgZm9yIG1ha2luZyBET00gZWxlbWVudHMgZHJhZ2dhYmxlIChpbmNsdWRpbmcgdG91Y2ggc3VwcG9ydCkuXHJcbiAgICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICAgKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIHZhciBkcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUoZWxlbWVudFRvRHJhZyk7XHJcbiAgICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuICB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQHNlY3Rpb25cclxuICBcdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcbiAgXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcbiAgXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuICBcdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuICBcdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCwgcHJldmVudE91dGxpbmUsIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gIFx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuICBcdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG4gIFx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG4gIFx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0b24odGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcbiAgXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG4gIFx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuICBcdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG4gIFx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuICBcdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgPT09IHRoaXMpIHtcclxuICBcdFx0XHR0aGlzLmZpbmlzaERyYWcodHJ1ZSk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdG9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuICBcdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gIFx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgXHRcdGlmIChoYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xyXG4gIFx0XHRcdC8vIEZpbmlzaCBkcmFnZ2luZyB0byBhdm9pZCBjb25mbGljdCB3aXRoIHRvdWNoWm9vbVxyXG4gIFx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0cmV0dXJuO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuICBcdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG4gIFx0XHRcdHByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkaXNhYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXHJcbiAgXHRcdCAgICBzaXplZFBhcmVudCA9IGdldFNpemVkUGFyZW50Tm9kZSh0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcbiAgXHRcdHRoaXMuX3N0YXJ0UG9zID0gZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCk7XHJcblxyXG4gIFx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcbiAgXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuICBcdFx0dmFyIG1vdXNlZXZlbnQgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nO1xyXG4gIFx0XHRvbihkb2N1bWVudCwgbW91c2VldmVudCA/ICdtb3VzZW1vdmUnIDogJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcbiAgXHRcdG9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcbiAgXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG4gIFx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuICBcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgKyBNYXRoLmFicyhvZmZzZXQueSkgPCB0aGlzLm9wdGlvbnMuY2xpY2tUb2xlcmFuY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBXZSBhc3N1bWUgdGhhdCB0aGUgcGFyZW50IGNvbnRhaW5lcidzIHBvc2l0aW9uLCBib3JkZXIgYW5kIHNjYWxlIGRvIG5vdCBjaGFuZ2UgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZHJhZy5cclxuICBcdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG4gIFx0XHQvLyBhbmQgd2UgY2FuIHVzZSB0aGUgY2FjaGVkIHZhbHVlIGZvciB0aGUgc2NhbGUuXHJcbiAgXHRcdG9mZnNldC54IC89IHRoaXMuX3BhcmVudFNjYWxlLng7XHJcbiAgXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG4gIFx0XHRwcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuICBcdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG4gIFx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG4gIFx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0YWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcbiAgXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuICBcdFx0XHQvLyBJRSBhbmQgRWRnZSBkbyBub3QgZ2l2ZSB0aGUgPHVzZT4gZWxlbWVudCwgc28gZmV0Y2ggaXRcclxuICBcdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuICBcdFx0XHRpZiAod2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSAmJiB0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IHRoaXMuX2xhc3RUYXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG4gIFx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuICBcdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuICBcdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcbiAgXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcbiAgXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25VcDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG4gIFx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuICBcdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG4gIFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuICBcdH0sXHJcblxyXG4gIFx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKG5vSW5lcnRpYSkge1xyXG4gIFx0XHRyZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG4gIFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuICBcdFx0b2ZmKGRvY3VtZW50LCAnbW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cclxuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XHJcbiAgXHRcdGVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuICBcdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcbiAgXHRcdFx0XHRub0luZXJ0aWE6IG5vSW5lcnRpYSxcclxuICBcdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcbiAgXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuICBcdH1cclxuXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIExpbmVVdGlsXHJcbiAgICpcclxuICAgKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAgICovXHJcblxyXG4gIC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG4gIC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4gIC8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4gIC8vIERyYW1hdGljYWxseSByZWR1Y2VzIHRoZSBudW1iZXIgb2YgcG9pbnRzIGluIGEgcG9seWxpbmUgd2hpbGUgcmV0YWluaW5nXHJcbiAgLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuICAvLyBbUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbiAgLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4gIC8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuICAvLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4gIC8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHBzOi8vbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanMvKS5cclxuICBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG4gIFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuICBcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gIFx0fVxyXG5cclxuICBcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcbiAgXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG4gIFx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG4gIFx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbiAgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuICBcdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuICAvLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuICBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcbiAgXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbiAgfVxyXG5cclxuICAvLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbiAgZnVuY3Rpb24gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuICBcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG4gIFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcbiAgXHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG4gIFx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcbiAgXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG4gIFx0dmFyIGksXHJcbiAgXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdGlmIChtYXJrZXJzW2ldKSB7XHJcbiAgXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBuZXdQb2ludHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGxhc3QpIHtcclxuXHJcbiAgXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuICBcdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG4gIFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuICBcdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcbiAgXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuICBcdFx0XHRpbmRleCA9IGk7XHJcbiAgXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcbiAgXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcbiAgXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG4gIFx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG4gIGZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG4gIFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG4gIFx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG4gIFx0XHRcdHByZXYgPSBpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuICBcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcbiAgXHR9XHJcbiAgXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxuICB9XHJcblxyXG4gIHZhciBfbGFzdENvZGU7XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4gIC8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuICAvLyBbQ29oZW4tU3V0aGVybGFuZCBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuJUUyJTgwJTkzU3V0aGVybGFuZF9hbGdvcml0aG0pXHJcbiAgLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4gIC8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbiAgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuICBcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuICBcdCAgICBjb2RlQiA9IF9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG4gIFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG4gIFx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG4gIFx0ICAgIF9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuICBcdHdoaWxlICh0cnVlKSB7XHJcbiAgXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuICBcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuICBcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG4gIFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gb3RoZXIgY2FzZXNcclxuICBcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG4gIFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZU91dCwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuICBcdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcbiAgXHRcdFx0YSA9IHA7XHJcbiAgXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdGIgPSBwO1xyXG4gIFx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYSwgYiwgY29kZSwgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG4gIFx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG4gIFx0ICAgIG1pbiA9IGJvdW5kcy5taW4sXHJcbiAgXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdCAgICB4LCB5O1xyXG5cclxuICBcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWF4Lnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgNCkgeyAvLyBib3R0b21cclxuICBcdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG4gIFx0XHR5ID0gbWluLnk7XHJcblxyXG4gIFx0fSBlbHNlIGlmIChjb2RlICYgMikgeyAvLyByaWdodFxyXG4gIFx0XHR4ID0gbWF4Lng7XHJcbiAgXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcbiAgXHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuICBcdFx0eCA9IG1pbi54O1xyXG4gIFx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuICBcdHZhciBjb2RlID0gMDtcclxuXHJcbiAgXHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuICBcdFx0Y29kZSB8PSAxO1xyXG4gIFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuICBcdFx0Y29kZSB8PSAyO1xyXG4gIFx0fVxyXG5cclxuICBcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdGNvZGUgfD0gNDtcclxuICBcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG4gIFx0XHRjb2RlIHw9IDg7XHJcbiAgXHR9XHJcblxyXG4gIFx0cmV0dXJuIGNvZGU7XHJcbiAgfVxyXG5cclxuICAvLyBzcXVhcmUgZGlzdGFuY2UgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IE1hdGguc3FydCBjYWxscylcclxuICBmdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG4gIFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuICBcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBjbG9zZXN0IHBvaW50IG9uIHNlZ21lbnQgb3IgZGlzdGFuY2UgdG8gdGhhdCBwb2ludFxyXG4gIGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG4gIFx0dmFyIHggPSBwMS54LFxyXG4gIFx0ICAgIHkgPSBwMS55LFxyXG4gIFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcbiAgXHQgICAgZHkgPSBwMi55IC0geSxcclxuICBcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuICBcdCAgICB0O1xyXG5cclxuICBcdGlmIChkb3QgPiAwKSB7XHJcbiAgXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG4gIFx0XHRpZiAodCA+IDEpIHtcclxuICBcdFx0XHR4ID0gcDIueDtcclxuICBcdFx0XHR5ID0gcDIueTtcclxuICBcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG4gIFx0XHRcdHggKz0gZHggKiB0O1xyXG4gIFx0XHRcdHkgKz0gZHkgKiB0O1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcblxyXG4gIFx0ZHggPSBwLnggLSB4O1xyXG4gIFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuICBcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBQb2ludCh4LCB5KTtcclxuICB9XHJcblxyXG5cclxuICAvLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBgbGF0bG5nc2AgaXMgYSBmbGF0IGFycmF5LCBmYWxzZSBpcyBuZXN0ZWQuXHJcbiAgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuICBcdHJldHVybiAhaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcbiAgXHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuJyk7XHJcbiAgXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG4gIH1cblxuICB2YXIgTGluZVV0aWwgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHNpbXBsaWZ5OiBzaW1wbGlmeSxcbiAgICBwb2ludFRvU2VnbWVudERpc3RhbmNlOiBwb2ludFRvU2VnbWVudERpc3RhbmNlLFxuICAgIGNsb3Nlc3RQb2ludE9uU2VnbWVudDogY2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGNsaXBTZWdtZW50OiBjbGlwU2VnbWVudCxcbiAgICBfZ2V0RWRnZUludGVyc2VjdGlvbjogX2dldEVkZ2VJbnRlcnNlY3Rpb24sXG4gICAgX2dldEJpdENvZGU6IF9nZXRCaXRDb2RlLFxuICAgIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDogX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICAgIGlzRmxhdDogaXNGbGF0LFxuICAgIF9mbGF0OiBfZmxhdFxuICB9O1xuXG4gIC8qXHJcbiAgICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gICAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICAgKi9cclxuXHJcbiAgLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICAgKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gICAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAgICogcGVyZm9ybWFuY2UuIE5vdGUgdGhhdCBwb2x5Z29uIHBvaW50cyBuZWVkcyBkaWZmZXJlbnQgYWxnb3JpdGhtIGZvciBjbGlwcGluZ1xyXG4gICAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG4gIFx0dmFyIGNsaXBwZWRQb2ludHMsXHJcbiAgXHQgICAgZWRnZXMgPSBbMSwgNCwgMiwgOF0sXHJcbiAgXHQgICAgaSwgaiwgayxcclxuICBcdCAgICBhLCBiLFxyXG4gIFx0ICAgIGxlbiwgZWRnZSwgcDtcclxuXHJcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0cG9pbnRzW2ldLl9jb2RlID0gX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG4gIFx0fVxyXG5cclxuICBcdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuICBcdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuICBcdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG4gIFx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG4gIFx0XHRcdGEgPSBwb2ludHNbaV07XHJcbiAgXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcbiAgXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcbiAgXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcbiAgXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuICBcdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG4gIFx0XHRcdFx0XHRwID0gX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzLCByb3VuZCk7XHJcbiAgXHRcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG4gIFx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG4gIFx0XHRcdH0gZWxzZSBpZiAoIShiLl9jb2RlICYgZWRnZSkpIHtcclxuICBcdFx0XHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuICBcdFx0XHRcdHAuX2NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG4gIFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRwb2ludHMgPSBjbGlwcGVkUG9pbnRzO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBwb2ludHM7XHJcbiAgfVxuXG4gIHZhciBQb2x5VXRpbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY2xpcFBvbHlnb246IGNsaXBQb2x5Z29uXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAc2VjdGlvblxyXG4gICAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAgICpcclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAgICpcclxuICAgKiBFcXVpcmVjdGFuZ3VsYXIsIG9yIFBsYXRlIENhcnJlZSBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBzaW1wbGUgcHJvamVjdGlvbixcclxuICAgKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gICAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAgICogYEVQU0c6NDMyNmAgYW5kIGBTaW1wbGVgIENSUy5cclxuICAgKi9cclxuXHJcbiAgdmFyIExvbkxhdCA9IHtcclxuICBcdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuICBcdH0sXHJcblxyXG4gIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuICBcdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG4gIH07XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICAgKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICAgKlxyXG4gICAqIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgbW9yZSBjb21wbGV4IHRoYW4gU3BoZXJpY2FsIE1lcmNhdG9yLiBBc3N1bWVzIHRoYXQgRWFydGggaXMgYW4gZWxsaXBzb2lkLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gICAqL1xyXG5cclxuICB2YXIgTWVyY2F0b3IgPSB7XHJcbiAgXHRSOiA2Mzc4MTM3LFxyXG4gIFx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG4gIFx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcbiAgXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuICBcdFx0ICAgIHIgPSB0aGlzLlIsXHJcbiAgXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcbiAgXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG4gIFx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuICBcdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcbiAgXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuICBcdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gIFx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcbiAgXHRcdCAgICByID0gdGhpcy5SLFxyXG4gIFx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuICBcdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcbiAgXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcbiAgXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcbiAgXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcbiAgXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcbiAgXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcbiAgXHRcdFx0cGhpICs9IGRwaGk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcbiAgXHR9XHJcbiAgfTtcblxuICAvKlxuICAgKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gICAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gICAqIGEgZmxhdCBzdXJmYWNlIChhbmQgYmFjaykuIFNlZSBbTWFwIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICAgKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAgICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICAgKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICAgKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICAgKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICAgKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gICAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXG4gICAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICAgKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cblxuICAgKi9cblxuICB2YXIgaW5kZXggPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIExvbkxhdDogTG9uTGF0LFxuICAgIE1lcmNhdG9yOiBNZXJjYXRvcixcbiAgICBTcGhlcmljYWxNZXJjYXRvcjogU3BoZXJpY2FsTWVyY2F0b3JcbiAgfTtcblxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAgICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gICAqXHJcbiAgICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICAgKi9cclxuICB2YXIgRVBTRzMzOTUgPSBleHRlbmQoe30sIEVhcnRoLCB7XHJcbiAgXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuICBcdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuICBcdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG4gIFx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcbiAgXHR9KCkpXHJcbiAgfSk7XG5cbiAgLypcclxuICAgKiBAbmFtZXNwYWNlIENSU1xyXG4gICAqIEBjcnMgTC5DUlMuRVBTRzQzMjZcclxuICAgKlxyXG4gICAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICAgKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gICAqIHdpdGggdGhpcyBDUlMsIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gMjU2eDI1NiBwaXhlbCB0aWxlcyBjb3ZlcmluZyB0aGVcclxuICAgKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAgICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAgICovXHJcblxyXG4gIHZhciBFUFNHNDMyNiA9IGV4dGVuZCh7fSwgRWFydGgsIHtcclxuICBcdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxyXG4gIFx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxuICB9KTtcblxuICAvKlxuICAgKiBAbmFtZXNwYWNlIENSU1xuICAgKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICAgKlxuICAgKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAgICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICAgKiBheGlzIHNob3VsZCBzdGlsbCBiZSBpbnZlcnRlZCAoZ29pbmcgZnJvbSBib3R0b20gdG8gdG9wKS4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAgICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAgICovXG5cbiAgdmFyIFNpbXBsZSA9IGV4dGVuZCh7fSwgQ1JTLCB7XG4gIFx0cHJvamVjdGlvbjogTG9uTGF0LFxuICBcdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuICBcdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuICBcdH0sXG5cbiAgXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcbiAgXHR9LFxuXG4gIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG4gIFx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuICBcdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuICBcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFx0fSxcblxuICBcdGluZmluaXRlOiB0cnVlXG4gIH0pO1xuXG4gIENSUy5FYXJ0aCA9IEVhcnRoO1xuICBDUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbiAgQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG4gIENSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbiAgQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG4gIENSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbiAgLypcbiAgICogQGNsYXNzIExheWVyXG4gICAqIEBpbmhlcml0cyBFdmVudGVkXG4gICAqIEBha2EgTC5MYXllclxuICAgKiBAYWthIElMYXllclxuICAgKlxuICAgKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICAgKiBJbmhlcml0cyBhbGwgbWV0aG9kcywgb3B0aW9ucyBhbmQgZXZlbnRzIGZyb20gYEwuRXZlbnRlZGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIuYWRkVG8obWFwKTtcbiAgICogbGF5ZXIucmVtb3ZlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnQgYWRkOiBFdmVudFxuICAgKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAgICpcbiAgICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICAgKi9cblxuXG4gIHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuICBcdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuICBcdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBlLmcuIFwiwqkgT3BlblN0cmVldE1hcCBjb250cmlidXRvcnNcIi4gSXQgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhIGFuZCBpcyBvZnRlbiBhIGxlZ2FsIG9ibGlnYXRpb24gdG93YXJkcyBjb3B5cmlnaHQgaG9sZGVycyBhbmQgdGlsZSBwcm92aWRlcnMuXG4gIFx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHQvKiBAc2VjdGlvblxuICBcdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICBcdCAqXG4gIFx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcHxMYXllckdyb3VwKTogdGhpc1xuICBcdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG4gIFx0ICovXG4gIFx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuICBcdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuICBcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG4gIFx0Ly9cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gYExheWVyR3JvdXBgXG4gIFx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuICBcdFx0aWYgKG9iaikge1xuICBcdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcbiAgXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cbiAgXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuICBcdH0sXG5cbiAgXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gIFx0XHR0aGlzLl9tYXAuX3RhcmdldHNbc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICBcdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tzdGFtcCh0YXJnZXRFbCldO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuICBcdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG4gIFx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gIFx0fSxcblxuICBcdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuICBcdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuICBcdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG4gIFx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuICBcdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcbiAgXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuICBcdFx0XHR9LCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vbkFkZChtYXApO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ2FkZCcpO1xuICBcdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG4gIFx0fVxuICB9KTtcblxuICAvKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICAgKiBAdW5pbmhlcml0YWJsZVxuICAgKlxuICAgKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gICAqXG4gICAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gICAqXG4gICAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApOiB0aGlzXG4gICAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRFdmVudHMoKTogT2JqZWN0XG4gICAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbigpOiBTdHJpbmdcbiAgICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBiZWZvcmVBZGQobWFwOiBNYXApOiB0aGlzXG4gICAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFwXG4gICAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICAgKlxuICAgKiBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcbiAgICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gICAqXG4gICAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgICovXG4gIE1hcC5pbmNsdWRlKHtcbiAgXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFsYXllci5fbGF5ZXJBZGQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG4gIFx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG4gIFx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG4gIFx0XHRpZiAobGF5ZXIuYmVmb3JlQWRkKSB7XG4gIFx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy53aGVuUmVhZHkobGF5ZXIuX2xheWVyQWRkLCBsYXllcik7XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcbiAgXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gIFx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGlkID0gc3RhbXAobGF5ZXIpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblxuICBcdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuICBcdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cbiAgXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcbiAgXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG4gIFx0XHR9XG5cbiAgXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG4gIFx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0cmV0dXJuIHN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnM7XG4gIFx0fSxcblxuICBcdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcbiAgXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICBcdCAqIGBgYFxuICBcdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuICBcdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG4gIFx0ICogfSk7XG4gIFx0ICogYGBgXG4gIFx0ICovXG4gIFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdF9hZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgXHRcdGxheWVycyA9IGxheWVycyA/IChpc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgaWQgPSBzdGFtcChsYXllcik7XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuICBcdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG4gIFx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuICBcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG4gIFx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuICBcdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG4gIFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG4gIFx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuICBcdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG4gIFx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cbiAgXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuICBcdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuICBcdFx0fVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcbiAgXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLypcclxuICAgKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gICAqIEBha2EgTC5MYXllckdyb3VwXHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICpcclxuICAgKiBVc2VkIHRvIGdyb3VwIHNldmVyYWwgbGF5ZXJzIGFuZCBoYW5kbGUgdGhlbSBhcyBvbmUuIElmIHlvdSBhZGQgaXQgdG8gdGhlIG1hcCxcclxuICAgKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICAgKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gICAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gICAqIFx0LmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcbiAgXHRcdHZhciBpLCBsZW47XHJcblxyXG4gIFx0XHRpZiAobGF5ZXJzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG4gIFx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG4gIFx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcbiAgXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuICBcdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG4gIFx0Ly8gQGFsdGVybmF0aXZlXHJcbiAgXHQvLyBAbWV0aG9kIGhhc0xheWVyKGlkOiBOdW1iZXIpOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0dmFyIGxheWVySWQgPSB0eXBlb2YgbGF5ZXIgPT09ICdudW1iZXInID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG4gIFx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuICBcdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcbiAgXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcbiAgXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcbiAgXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG4gIFx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gIFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgXHRcdCAgICBpLCBsYXllcjtcclxuXHJcbiAgXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcbiAgXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcbiAgXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0dGhpcy5lYWNoTGF5ZXIobWFwLmFkZExheWVyLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihtYXAucmVtb3ZlTGF5ZXIsIG1hcCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuICBcdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuICBcdC8vIGBgYGpzXHJcbiAgXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuICBcdC8vIH0pO1xyXG4gIFx0Ly8gYGBgXHJcbiAgXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuICBcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcbiAgXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcbiAgXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuICBcdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgbGF5ZXJzID0gW107XHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGxheWVycy5wdXNoLCBsYXllcnMpO1xyXG4gIFx0XHRyZXR1cm4gbGF5ZXJzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuICBcdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG4gIFx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuICBcdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRyZXR1cm4gc3RhbXAobGF5ZXIpO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG4gIHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICAgKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAgICogQGluaGVyaXRzIExheWVyR3JvdXBcclxuICAgKlxyXG4gICAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAgICogICogW2BiaW5kUG9wdXBgXSgjbGF5ZXItYmluZHBvcHVwKSBiaW5kcyBhIHBvcHVwIHRvIGFsbCBvZiB0aGUgbGF5ZXJzIGF0IG9uY2UgKGxpa2V3aXNlIHdpdGggW2BiaW5kVG9vbHRpcGBdKCNsYXllci1iaW5kdG9vbHRpcCkpXHJcbiAgICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gICAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gICAqIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC5mZWF0dXJlR3JvdXAoW21hcmtlcjEsIG1hcmtlcjIsIHBvbHlsaW5lXSlcclxuICAgKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAgICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICAgKiBcdC5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuICBcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuICBcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuICBcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuICBcdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbGF5ZXJyZW1vdmU6IExheWVyRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9Gcm9udCcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGUgbGF5ZXIgZ3JvdXAgdG8gdGhlIGJhY2sgb2YgYWxsIG90aGVyIGxheWVyc1xyXG4gIFx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuICBcdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuICBcdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuICBcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBib3VuZHM7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbiAgLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbiAgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMsIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBJY29uXHJcbiAgICogQGFrYSBMLkljb25cclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYW4gaWNvbiB0byBwcm92aWRlIHdoZW4gY3JlYXRpbmcgYSBtYXJrZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICAgKiAgICAgaWNvblVybDogJ215LWljb24ucG5nJyxcclxuICAgKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICAgKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gICAqICAgICBpY29uQW5jaG9yOiBbMjIsIDk0XSxcclxuICAgKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICAgKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICAgKiAgICAgc2hhZG93UmV0aW5hVXJsOiAnbXktaWNvbi1zaGFkb3dAMngucG5nJyxcclxuICAgKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAgICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKi9cclxuXHJcbiAgdmFyIEljb24gPSBDbGFzcy5leHRlbmQoe1xyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcbiAgXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuICBcdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuICBcdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcbiAgXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcbiAgXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG4gIFx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHRvb2x0aXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG4gIFx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG4gIFx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcbiAgXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcbiAgXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG4gIFx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG4gIFx0ICovXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHRwb3B1cEFuY2hvcjogWzAsIDBdLFxyXG4gIFx0XHR0b29sdGlwQW5jaG9yOiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byB0aGUgU3RyaW5nIHByb3ZpZGVkLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG4gIFx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG4gIFx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbiAgXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcbiAgXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuICBcdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcbiAgXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuICBcdFx0aWYgKCFzcmMpIHtcclxuICBcdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiBudWxsO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG4gIFx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuICBcdFx0XHRpbWcuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIGltZztcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgXHRcdHZhciBzaXplT3B0aW9uID0gb3B0aW9uc1tuYW1lICsgJ1NpemUnXTtcclxuXHJcbiAgXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuICBcdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgc2l6ZSA9IHRvUG9pbnQoc2l6ZU9wdGlvbiksXHJcbiAgXHRcdCAgICBhbmNob3IgPSB0b1BvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG4gIFx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuICBcdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG4gIFx0XHRpZiAoYW5jaG9yKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChzaXplKSB7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuICBcdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICBcdFx0ZWwuc3JjID0gc3JjO1xyXG4gIFx0XHRyZXR1cm4gZWw7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFx0XHRyZXR1cm4gQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG4gIGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAbWluaWNsYXNzIEljb24uRGVmYXVsdCAoSWNvbilcbiAgICogQGFrYSBMLkljb24uRGVmYXVsdFxuICAgKiBAc2VjdGlvblxuICAgKlxuICAgKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICAgKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAgICogcmVsZWFzZXMuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gICAqICh3aGljaCBpcyBhIHNldCBvZiBgSWNvbiBvcHRpb25zYCkuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICAgKiBgTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMuaWNvbmAgd2l0aCB5b3VyIG93biBpY29uIGluc3RlYWQuXG4gICAqL1xuXG4gIHZhciBJY29uRGVmYXVsdCA9IEljb24uZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuICBcdFx0aWNvblJldGluYVVybDogJ21hcmtlci1pY29uLTJ4LnBuZycsXG4gIFx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuICBcdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuICBcdFx0aWNvbkFuY2hvcjogIFsxMiwgNDFdLFxuICBcdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuICBcdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuICBcdFx0c2hhZG93U2l6ZTogIFs0MSwgNDFdXG4gIFx0fSxcblxuICBcdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHR5cGVvZiBJY29uRGVmYXVsdC5pbWFnZVBhdGggIT09ICdzdHJpbmcnKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG4gIFx0XHRcdEljb25EZWZhdWx0LmltYWdlUGF0aCA9IHRoaXMuX2RldGVjdEljb25QYXRoKCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcbiAgXHRcdC8vIGBJY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcbiAgXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBwYXRoLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEljb25EZWZhdWx0LmltYWdlUGF0aCkgKyBJY29uLnByb3RvdHlwZS5fZ2V0SWNvblVybC5jYWxsKHRoaXMsIG5hbWUpO1xuICBcdH0sXG5cbiAgXHRfc3RyaXBVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XHQvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byB1c2UgaW4gdGVzdHNcbiAgXHRcdHZhciBzdHJpcCA9IGZ1bmN0aW9uIChzdHIsIHJlLCBpZHgpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbaWR4XTtcbiAgXHRcdH07XG4gIFx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG4gIFx0XHRyZXR1cm4gcGF0aCAmJiBzdHJpcChwYXRoLCAvXiguKiltYXJrZXItaWNvblxcLnBuZyQvLCAxKTtcbiAgXHR9LFxuXG4gIFx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWwgPSBjcmVhdGUkMSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG4gIFx0XHR2YXIgcGF0aCA9IGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG4gIFx0XHQgICAgICAgICAgIGdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuICBcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gIFx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG4gIFx0XHRpZiAocGF0aCkgeyByZXR1cm4gcGF0aDsgfVxuICBcdFx0dmFyIGxpbmsgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWYkPVwibGVhZmxldC5jc3NcIl0nKTtcbiAgXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cbiAgXHRcdHJldHVybiBsaW5rLmhyZWYuc3Vic3RyaW5nKDAsIGxpbmsuaHJlZi5sZW5ndGggLSAnbGVhZmxldC5jc3MnLmxlbmd0aCAtIDEpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICAgKi9cblxuXG4gIC8qIEBuYW1lc3BhY2UgTWFya2VyXG4gICAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gICAqXG4gICAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICAgKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAgICovXG5cbiAgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuICBcdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuICBcdH0sXG5cbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cbiAgXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG4gIFx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcbiAgXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuICBcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcbiAgXHRcdH0sIHRoaXMpLmVuYWJsZSgpO1xuXG4gIFx0XHRhZGRDbGFzcyhpY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG4gIFx0fSxcblxuICBcdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUub2ZmKHtcbiAgXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuICBcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICBcdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLl9pY29uKSB7XG4gIFx0XHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuICBcdH0sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcbiAgXHRcdCAgICBtYXAgPSBtYXJrZXIuX21hcCxcbiAgXHRcdCAgICBzcGVlZCA9IHRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxcbiAgXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG4gIFx0XHQgICAgb3JpZ2luID0gbWFwLmdldFBpeGVsT3JpZ2luKCk7XG5cbiAgXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcbiAgXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG4gIFx0XHRcdGJvdW5kcy5tYXguX3N1YnRyYWN0KG9yaWdpbikuc3VidHJhY3QocGFkZGluZylcbiAgXHRcdCk7XG5cbiAgXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG4gIFx0XHRcdC8vIENvbXB1dGUgaW5jcmVtZW50YWwgbW92ZW1lbnRcbiAgXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcbiAgXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cbiAgXHRcdFx0XHQoTWF0aC5taW4ocGFuQm91bmRzLm1pbi54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1pbi54KSAvIChib3VuZHMubWluLnggLSBwYW5Cb3VuZHMubWluLngpLFxuXG4gIFx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG4gIFx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuICBcdFx0XHQpLm11bHRpcGx5Qnkoc3BlZWQpO1xuXG4gIFx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cbiAgXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuX2FkZChtb3ZlbWVudCk7XG5cbiAgXHRcdFx0c2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG4gIFx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuICBcdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuICBcdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXG4gIFx0XHQvLyBXaGVuIHVzaW5nIEVTNiBpbXBvcnRzIGl0IGNvdWxkIG5vdCBiZSBzZXQgd2hlbiBgUG9wdXBgIHdhcyBub3QgaW1wb3J0ZWQgYXMgd2VsbFxuICBcdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuICBcdFx0dGhpcy5fbWFya2VyXG4gIFx0XHRcdC5maXJlKCdtb3Zlc3RhcnQnKVxuICBcdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuICBcdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG4gIFx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG4gIFx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG4gIFx0XHQgICAgaWNvblBvcyA9IGdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG4gIFx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG4gIFx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG4gIFx0XHRpZiAoc2hhZG93KSB7XG4gIFx0XHRcdHNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG4gIFx0XHR9XG5cbiAgXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuICBcdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG4gIFx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuICBcdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG4gIFx0XHRtYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuICBcdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuICBcdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cbiAgXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG4gIFx0XHR0aGlzLl9tYXJrZXJcbiAgXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIE1hcmtlclxyXG4gICAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gICAqIEBha2EgTC5NYXJrZXJcclxuICAgKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBNYXJrZXIgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcbiAgXHRvcHRpb25zOiB7XHJcbiAgXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuICBcdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG4gIFx0XHQvLyBTZWUgW0ljb24gZG9jdW1lbnRhdGlvbl0oI0wuSWNvbikgZm9yIGRldGFpbHMgb24gaG93IHRvIGN1c3RvbWl6ZSB0aGUgbWFya2VyIGljb24uXHJcbiAgXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuICBcdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG4gIFx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG4gIFx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG4gIFx0XHQvLyBbVXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5XShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvYWNjZXNzaWJpbGl0eS8jbWFya2Vycy1tdXN0LWJlLWxhYmVsbGVkKS5cclxuICBcdFx0dGl0bGU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICdNYXJrZXInXHJcbiAgXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UuXHJcbiAgXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG4gIFx0XHRhbHQ6ICdNYXJrZXInLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuICBcdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcbiAgXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcbiAgXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcbiAgXHRcdG9wYWNpdHk6IDEsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcbiAgXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcbiAgXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG4gIFx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG4gIFx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBzaGFkb3dQYW5lOiBTdHJpbmcgPSAnc2hhZG93UGFuZSdcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuICBcdFx0c2hhZG93UGFuZTogJ3NoYWRvd1BhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuICBcdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcbiAgXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXAgd2lsbCBwYW4gd2hlbmV2ZXIgdGhlIG1hcmtlciBpcyBmb2N1c2VkICh2aWFcclxuICBcdFx0Ly8gZS5nLiBwcmVzc2luZyBgdGFiYCBvbiB0aGUga2V5Ym9hcmQpIHRvIGVuc3VyZSB0aGUgbWFya2VyIGlzXHJcbiAgXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuICBcdFx0YXV0b1Bhbk9uRm9jdXM6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAc2VjdGlvbiBEcmFnZ2FibGUgbWFya2VyIG9wdGlvbnNcclxuICBcdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG4gIFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0byBwYW4gdGhlIG1hcCB3aGVuIGRyYWdnaW5nIHRoaXMgbWFya2VyIG5lYXIgaXRzIGVkZ2Ugb3Igbm90LlxyXG4gIFx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG4gIFx0XHQvLyBEaXN0YW5jZSAoaW4gcGl4ZWxzIHRvIHRoZSBsZWZ0L3JpZ2h0IGFuZCB0byB0aGUgdG9wL2JvdHRvbSkgb2YgdGhlXHJcbiAgXHRcdC8vIG1hcCBlZGdlIHRvIHN0YXJ0IHBhbm5pbmcgdGhlIG1hcC5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuU3BlZWQ6IE51bWJlciA9IDEwXHJcbiAgXHRcdC8vIE51bWJlciBvZiBwaXhlbHMgdGhlIG1hcCBzaG91bGQgcGFuIGJ5LlxyXG4gIFx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcbiAgXHR9LFxyXG5cclxuICBcdC8qIEBzZWN0aW9uXHJcbiAgXHQgKlxyXG4gIFx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG4gIFx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gIFx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuICBcdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG4gIFx0XHR9O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcbiAgXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEljb246IEljb25cclxuICBcdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgaWNvbiB1c2VkIGJ5IHRoZSBtYXJrZXJcclxuICBcdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG4gIFx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcbiAgXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcbiAgXHR9LFxyXG5cclxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG4gIFx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gIFx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcbiAgXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcbiAgXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG4gIFx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuICBcdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcbiAgXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICBcdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0aWYgKGljb24udGFnTmFtZSA9PT0gJ0lNRycpIHtcclxuICBcdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRhZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcbiAgXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuICBcdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG4gIFx0XHRcdHRoaXMub24oe1xyXG4gIFx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcbiAgXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuICBcdFx0XHR9KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvUGFuT25Gb2N1cykge1xyXG4gIFx0XHRcdG9uKGljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG4gIFx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuICBcdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAobmV3U2hhZG93KSB7XHJcbiAgXHRcdFx0YWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuICBcdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG5cclxuICBcdFx0aWYgKGFkZEljb24pIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuICBcdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuICBcdFx0XHR0aGlzLmdldFBhbmUob3B0aW9ucy5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuICBcdFx0XHR0aGlzLm9mZih7XHJcbiAgXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuICBcdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmF1dG9QYW5PbkZvY3VzKSB7XHJcbiAgXHRcdFx0b2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZW1vdmUodGhpcy5faWNvbik7XHJcbiAgXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcbiAgXHRcdH1cclxuICBcdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fc2hhZG93LCBwb3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG4gIFx0XHR0aGlzLl9yZXNldFpJbmRleCgpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuICBcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0YWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcbiAgXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG4gIFx0XHRpZiAoTWFya2VyRHJhZykge1xyXG4gIFx0XHRcdHZhciBkcmFnZ2FibGUgPSB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlO1xyXG4gIFx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcbiAgXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuICBcdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZGlzYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuXHJcbiAgXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuICBcdFx0XHRpZiAoZHJhZ2dhYmxlKSB7XHJcbiAgXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gQ2hhbmdlcyB0aGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG4gIFx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9wYW5PbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcbiAgXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIGljb25PcHRzID0gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuICBcdFx0dmFyIHNpemUgPSBpY29uT3B0cy5pY29uU2l6ZSA/IHRvUG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogdG9Qb2ludCgwLCAwKTtcclxuICBcdFx0dmFyIGFuY2hvciA9IGljb25PcHRzLmljb25BbmNob3IgPyB0b1BvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogdG9Qb2ludCgwLCAwKTtcclxuXHJcbiAgXHRcdG1hcC5wYW5JbnNpZGUodGhpcy5fbGF0bG5nLCB7XHJcbiAgXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuICBcdFx0XHRwYWRkaW5nQm90dG9tUmlnaHQ6IHNpemUuc3VidHJhY3QoYW5jaG9yKVxyXG4gIFx0XHR9KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgTWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuICBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IE1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG4gIH1cblxuICAvKlxuICAgKiBAY2xhc3MgUGF0aFxuICAgKiBAYWthIEwuUGF0aFxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAgICpcbiAgICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gICAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICAgKi9cblxuICB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUGF0aCBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdHN0cm9rZTogdHJ1ZSxcblxuICBcdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG4gIFx0XHQvLyBTdHJva2UgY29sb3JcbiAgXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cbiAgXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG4gIFx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG4gIFx0XHR3ZWlnaHQ6IDMsXG5cbiAgXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG4gIFx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuICBcdFx0b3BhY2l0eTogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuICBcdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cbiAgXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuICBcdFx0ZGFzaEFycmF5OiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cbiAgXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcbiAgXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cbiAgXHRcdGZpbGw6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuICBcdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuICBcdFx0ZmlsbENvbG9yOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRcdC8vIEZpbGwgb3BhY2l0eS5cbiAgXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cbiAgXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuICBcdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cbiAgXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cbiAgXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cbiAgXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcbiAgXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcbiAgXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuICBcdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuICBcdH0sXG5cbiAgXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuICBcdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuICBcdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG4gIFx0XHR0aGlzLl9yZXNldCgpO1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuICBcdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuICBcdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zdHJva2UgJiYgc3R5bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0eWxlLCAnd2VpZ2h0JykpIHtcbiAgXHRcdFx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gIFx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcbiAgXHRcdHRoaXMuX3Byb2plY3QoKTtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG4gIFx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcbiAgXHRcdCAgKHRoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlIHx8IDApO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIENpcmNsZU1hcmtlclxuICAgKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gICAqIEBpbmhlcml0cyBQYXRoXG4gICAqXG4gICAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAgICovXG5cbiAgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuICBcdC8vIEBzZWN0aW9uXG4gIFx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWUsXG5cbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuICBcdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcbiAgXHRcdHJhZGl1czogMTBcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG4gIFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcbiAgXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG4gIFx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdHRoaXMucmVkcmF3KCk7XG5cbiAgXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNjaXJjbGVtYXJrZXItc2V0bGF0bG5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXG4gIFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldExhdExuZygpOiBMYXRMbmdcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuICBcdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlIG1hcmtlci4gVW5pdHMgYXJlIGluIHBpeGVscy5cbiAgXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG4gIFx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICBcdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgXHR9LFxuXG4gIFx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuICBcdFx0UGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuICBcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuICBcdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuICBcdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG4gIFx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZUNpcmNsZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fcmFkaXVzICYmICF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG4gIFx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG4gIFx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICBcdH1cbiAgfSk7XG5cblxuICAvLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBDaXJjbGVcbiAgICogQGFrYSBMLkNpcmNsZVxuICAgKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICAgKlxuICAgKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gIFx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuICBcdFx0XHRvcHRpb25zID0gZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG4gIFx0XHR9XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuICBcdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcbiAgXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG4gIFx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG4gIFx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuICBcdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuICBcdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcbiAgXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcbiAgXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cbiAgXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcbiAgXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cbiAgXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG4gIFx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcbiAgXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG4gIFx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG4gIFx0fSxcblxuICBcdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuICBcdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuICBcdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcbiAgXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuICBcdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuICBcdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuICBcdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcbiAgXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcbiAgXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG4gIFx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuICBcdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuICBcdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuICBcdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLng7XG4gIFx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cbiAgXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG4gIFx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbiAgLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4gIC8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuICAvLyBAYWx0ZXJuYXRpdmVcbiAgLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4gIC8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4gIC8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuICBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBQb2x5bGluZVxuICAgKiBAYWthIEwuUG9seWxpbmVcbiAgICogQGluaGVyaXRzIFBhdGhcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAgICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdFszNC4wNCwgLTExOC4yXVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICAgKlxuICAgKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gICAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gICAqIHZhciBsYXRsbmdzID0gW1xuICAgKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICAgKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICAgKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICAgKiBcdFtbNDAuNzgsIC03My45MV0sXG4gICAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAgICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICAgKiBdO1xuICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcbiAgXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cbiAgXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuICBcdFx0bm9DbGlwOiBmYWxzZVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuICBcdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cbiAgXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuICBcdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQocDogUG9pbnQpOiBQb2ludFxuICBcdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cbiAgXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcbiAgXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuICBcdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcbiAgXHRcdCAgICBjbG9zZXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuICBcdFx0ICAgIHAxLCBwMjtcblxuICBcdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG4gIFx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG4gIFx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cbiAgXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gIFx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcbiAgXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0aWYgKG1pblBvaW50KSB7XG4gIFx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBtaW5Qb2ludDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuICBcdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuICBcdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cbiAgXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG4gIFx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG4gIFx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgXHRcdFx0cDEgPSBwb2ludHNbaV07XG4gIFx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cbiAgXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuICBcdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuICBcdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcbiAgXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG4gIFx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG4gIFx0XHRcdFx0XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG4gIFx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz86IExhdExuZ1tdKTogdGhpc1xuICBcdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2ZcbiAgXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuICBcdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cbiAgXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuICBcdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcbiAgXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuICBcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICBcdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG4gIFx0fSxcblxuICBcdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuICBcdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG4gIFx0fSxcblxuICBcdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcbiAgXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHQgICAgZmxhdCA9IGlzRmxhdChsYXRsbmdzKTtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0aWYgKGZsYXQpIHtcbiAgXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcbiAgXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9LFxuXG4gIFx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgXHRcdHRoaXMuX3JpbmdzID0gW107XG4gIFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG4gIFx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMgPSBweEJvdW5kcztcbiAgXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcbiAgXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcbiAgXHRcdFx0dGhpcy5fcmF3UHhCb3VuZHMubWluLnN1YnRyYWN0KHApLFxuICBcdFx0XHR0aGlzLl9yYXdQeEJvdW5kcy5tYXguYWRkKHApXG4gIFx0XHRdKTtcbiAgXHR9LFxuXG4gIFx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcbiAgXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcbiAgXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcbiAgXHRcdCAgICBpLCByaW5nO1xuXG4gIFx0XHRpZiAoZmxhdCkge1xuICBcdFx0XHRyaW5nID0gW107XG4gIFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuICBcdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuICBcdFx0dGhpcy5fcGFydHMgPSBbXTtcbiAgXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG4gIFx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG4gIFx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcbiAgXHRcdFx0XHRzZWdtZW50ID0gY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG4gIFx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuICBcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cbiAgXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG4gIFx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG4gIFx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuICBcdFx0XHRcdFx0aysrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG4gIFx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcbiAgXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydHNbaV0gPSBzaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcbiAgXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG4gIFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG4gIFx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuICBcdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cbiAgXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gIFx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cbiAgXHRcdFx0XHRpZiAocG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbiAgLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4gIC8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuICBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cbiAgUG9seWxpbmUuX2ZsYXQgPSBfZmxhdDtcblxuICAvKlxuICAgKiBAY2xhc3MgUG9seWdvblxuICAgKiBAYWthIEwuUG9seWdvblxuICAgKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAgICpcbiAgICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICAgKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAgICpcbiAgICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICAgKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxhdGxuZ3MgPSBbXG4gICAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gICAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogXTtcbiAgICogYGBgXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgbGF0bG5ncyA9IFtcbiAgICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAgICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICAgKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAgICogICBdLFxuICAgKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAgICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICAgKiAgIF1cbiAgICogXTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuICBcdG9wdGlvbnM6IHtcbiAgXHRcdGZpbGw6IHRydWVcbiAgXHR9LFxuXG4gIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG4gIFx0fSxcblxuICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuICBcdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuICBcdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cbiAgXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cbiAgXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cbiAgXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gIFx0XHRcdHAxID0gcG9pbnRzW2ldO1xuICBcdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuICBcdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcbiAgXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcbiAgXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcbiAgXHRcdFx0YXJlYSArPSBmICogMztcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFyZWEgPT09IDApIHtcbiAgXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG4gIFx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcbiAgXHR9LFxuXG4gIFx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICBcdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcbiAgXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG4gIFx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG4gIFx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuICBcdFx0XHRyZXN1bHQucG9wKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH0sXG5cbiAgXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuICBcdFx0aWYgKGlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuICBcdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG4gIFx0fSxcblxuICBcdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cbiAgXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuICBcdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuICBcdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cbiAgXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcbiAgXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG4gIFx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuICBcdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcbiAgXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0Y2xpcHBlZCA9IGNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuICBcdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcbiAgXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuICBcdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuICBcdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuICBcdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG4gIFx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBcdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG4gIFx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICBcdFx0XHRcdHAxID0gcGFydFtqXTtcbiAgXHRcdFx0XHRwMiA9IHBhcnRba107XG5cbiAgXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuICBcdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG4gIFx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuICBcdH1cblxuICB9KTtcblxuXG4gIC8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4gIGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIEdlb0pTT05cclxuICAgKiBAYWthIEwuR2VvSlNPTlxyXG4gICAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICAgKlxyXG4gICAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICAgKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAgICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICAgKiBcdH1cclxuICAgKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gICAqIH0pLmFkZFRvKG1hcCk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG4gIFx0LyogQHNlY3Rpb25cclxuICBcdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG4gIFx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuICBcdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcbiAgXHQgKiB9XHJcbiAgXHQgKiBgYGBcclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcbiAgXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcbiAgXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4ge31cclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICpcclxuICBcdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcbiAgXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuICBcdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcbiAgXHQgKiBgYGBqc1xyXG4gIFx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG4gIFx0ICogYGBgXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG4gIFx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG4gIFx0ICogYGBganNcclxuICBcdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG4gIFx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuICBcdCAqIH1cclxuICBcdCAqIGBgYFxyXG4gIFx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuICBcdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuICBcdCAqXHJcbiAgXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuICBcdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuICBcdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcbiAgXHQgKlxyXG4gIFx0ICogQG9wdGlvbiBtYXJrZXJzSW5oZXJpdE9wdGlvbnM6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG4gIFx0ICovXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuICBcdFx0aWYgKGdlb2pzb24pIHtcclxuICBcdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcbiAgXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG4gIFx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuICBcdFx0dmFyIGZlYXR1cmVzID0gaXNBcnJheShnZW9qc29uKSA/IGdlb2pzb24gOiBnZW9qc29uLmZlYXR1cmVzLFxyXG4gIFx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuICBcdFx0aWYgKGZlYXR1cmVzKSB7XHJcbiAgXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG4gIFx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG4gIFx0XHRcdFx0aWYgKGZlYXR1cmUuZ2VvbWV0cmllcyB8fCBmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZmVhdHVyZXMgfHwgZmVhdHVyZS5jb29yZGluYXRlcykge1xyXG4gIFx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcbiAgXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuICBcdFx0aWYgKCFsYXllcikge1xyXG4gIFx0XHRcdHJldHVybiB0aGlzO1xyXG4gIFx0XHR9XHJcbiAgXHRcdGxheWVyLmZlYXR1cmUgPSBhc0ZlYXR1cmUoZ2VvanNvbik7XHJcblxyXG4gIFx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcbiAgXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG4gIFx0XHRpZiAob3B0aW9ucy5vbkVhY2hGZWF0dXJlKSB7XHJcbiAgXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG4gIFx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG4gIFx0Ly8gSWYgYGxheWVyYCBpcyBvbWl0dGVkLCB0aGUgc3R5bGUgb2YgYWxsIGZlYXR1cmVzIGluIHRoZSBjdXJyZW50IGxheWVyIGlzIHJlc2V0LlxyXG4gIFx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuICBcdFx0bGF5ZXIub3B0aW9ucyA9IGV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG4gIFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCB0aGlzLm9wdGlvbnMuc3R5bGUpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRTdHlsZSggPEZ1bmN0aW9uPiBzdHlsZSApOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcbiAgXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcbiAgXHRcdH0sIHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG4gIFx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuICBcdFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRsYXllci5zZXRTdHlsZShzdHlsZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQHNlY3Rpb25cclxuICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihmZWF0dXJlRGF0YTogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKTogTGF5ZXJcclxuICAvLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbiAgLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbiAgLy8gZnVuY3Rpb25zIGlmIHByb3ZpZGVkIGFzIG9wdGlvbnMuXHJcbiAgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcbiAgXHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG4gIFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG4gIFx0ICAgIGxheWVycyA9IFtdLFxyXG4gIFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcbiAgXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG4gIFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuICBcdGlmICghY29vcmRzICYmICFnZW9tZXRyeSkge1xyXG4gIFx0XHRyZXR1cm4gbnVsbDtcclxuICBcdH1cclxuXHJcbiAgXHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuICBcdGNhc2UgJ1BvaW50JzpcclxuICBcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiBfcG9pbnRUb0xheWVyKHBvaW50VG9MYXllciwgZ2VvanNvbiwgbGF0bG5nLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdNdWx0aVBvaW50JzpcclxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcbiAgXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcblxyXG4gIFx0Y2FzZSAnTGluZVN0cmluZyc6XHJcbiAgXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnID8gMCA6IDEsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG4gIFx0Y2FzZSAnUG9seWdvbic6XHJcbiAgXHRjYXNlICdNdWx0aVBvbHlnb24nOlxyXG4gIFx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcbiAgXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG4gIFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuICBcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG4gIFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG4gIFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcbiAgXHRcdFx0fSwgb3B0aW9ucyk7XHJcblxyXG4gIFx0XHRcdGlmIChsYXllcikge1xyXG4gIFx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuICBcdGRlZmF1bHQ6XHJcbiAgXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuICBcdH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIHBvaW50VG9MYXllckZuID9cclxuICBcdFx0cG9pbnRUb0xheWVyRm4oZ2VvanNvbiwgbGF0bG5nKSA6XHJcbiAgXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuICAvLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4gIC8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG4gIFx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4gIC8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuICAvLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbiAgLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG4gIGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG4gIFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuICBcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcbiAgXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG4gIFx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG4gIFx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcclxuICBcdH1cclxuXHJcbiAgXHRyZXR1cm4gbGF0bG5ncztcclxuICB9XHJcblxyXG4gIC8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuICAvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24uXHJcbiAgZnVuY3Rpb24gbGF0TG5nVG9Db29yZHMobGF0bG5nLCBwcmVjaXNpb24pIHtcclxuICBcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcbiAgXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuICBcdFx0W2Zvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBmb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuLCBwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBBcnJheVxyXG4gIC8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbiAgLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuICBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuICBcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gIFx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuICBcdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcbiAgXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcbiAgXHR9XHJcblxyXG4gIFx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG4gIFx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiBjb29yZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG4gIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG4gIFx0XHRleHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcbiAgXHRcdGFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcbiAgfVxyXG5cclxuICAvLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4gIC8vIE5vcm1hbGl6ZSBHZW9KU09OIGdlb21ldHJpZXMvZmVhdHVyZXMgaW50byBHZW9KU09OIGZlYXR1cmVzLlxyXG4gIGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcbiAgXHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgfHwgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgXHRcdHJldHVybiBnZW9qc29uO1xyXG4gIFx0fVxyXG5cclxuICBcdHJldHVybiB7XHJcbiAgXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuICBcdFx0cHJvcGVydGllczoge30sXHJcbiAgXHRcdGdlb21ldHJ5OiBnZW9qc29uXHJcbiAgXHR9O1xyXG4gIH1cclxuXHJcbiAgdmFyIFBvaW50VG9HZW9KU09OID0ge1xyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcbiAgXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuICBcdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG4gIFx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH07XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbiAgLy8gQHNlY3Rpb24gT3RoZXIgbWV0aG9kc1xyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbiAgLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbiAgLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbiAgLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuICBDaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbiAgQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4gIC8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4gIC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWxpbmUgKGFzIGEgR2VvSlNPTiBgTGluZVN0cmluZ2Agb3IgYE11bHRpTGluZVN0cmluZ2AgRmVhdHVyZSkuXHJcbiAgUG9seWxpbmUuaW5jbHVkZSh7XHJcbiAgXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuICBcdFx0dmFyIG11bHRpID0gIWlzRmxhdCh0aGlzLl9sYXRsbmdzKTtcclxuXHJcbiAgXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdMaW5lU3RyaW5nJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuICAvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICAvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuICAvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcbiAgUG9seWdvbi5pbmNsdWRlKHtcclxuICBcdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgaG9sZXMgPSAhaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG4gIFx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuICBcdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuICBcdFx0aWYgKCFob2xlcykge1xyXG4gIFx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcbiAgXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbiAgTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuICBcdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG4gIFx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG4gIFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuICBcdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuICBcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcbiAgXHRcdH0pO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuICBcdC8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4gIFx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG4gIFx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG4gIFx0XHR2YXIgdHlwZSA9IHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5LnR5cGU7XHJcblxyXG4gIFx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG4gIFx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcbiAgXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG4gIFx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuICBcdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcbiAgXHRcdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuICBcdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuICBcdFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRcdHZhciBmZWF0dXJlID0gYXNGZWF0dXJlKGpzb24pO1xyXG4gIFx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuICBcdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2guYXBwbHkoanNvbnMsIGZlYXR1cmUuZmVhdHVyZXMpO1xyXG4gIFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcbiAgXHRcdFx0XHRcdH1cclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH0pO1xyXG5cclxuICBcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcbiAgXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG4gIFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcbiAgXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4ge1xyXG4gIFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcbiAgXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcbiAgXHRcdH07XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4gIC8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4gIC8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbiAgLy8gW0dlb0pTT04gZm9ybWF0XShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzk0NikgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbiAgLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuICBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuICBcdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xuXG4gIC8qXHJcbiAgICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gICAqIEBha2EgTC5JbWFnZU92ZXJsYXlcclxuICAgKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICAgKlxyXG4gICAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHNpbmdsZSBpbWFnZSBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cHM6Ly9tYXBzLmxpYi51dGV4YXMuZWR1L21hcHMvaGlzdG9yaWNhbC9uZXdhcmtfbmpfMTkyMi5qcGcnLFxyXG4gICAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAgICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgSW1hZ2VPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG4gIFx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuICBcdFx0b3BhY2l0eTogMSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuICBcdFx0YWx0OiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG4gIFx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuICBcdFx0Ly8gSWYgYSBTdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgb3ZlcmxheSBsYXllci5cclxuICBcdFx0ekluZGV4OiAxLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgTGF0TG5nQm91bmRzLCBPYmplY3QpXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0SW1hZ2UoKTtcclxuXHJcbiAgXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG4gIFx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdHRoaXMuX3Jlc2V0KCk7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcbiAgXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuICBcdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcbiAgXHRcdFx0dGhpcy5zZXRPcGFjaXR5KHN0eWxlT3B0cy5vcGFjaXR5KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBvdmVybGF5cy5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5faW1hZ2UpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuICBcdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcbiAgXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcbiAgXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuICBcdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcbiAgXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICBcdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLl9yZXNldCgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIGV2ZW50cyA9IHtcclxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuICBcdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcbiAgXHRcdH07XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcbiAgXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcbiAgXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG4gIFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICBcdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcbiAgXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IGNyZWF0ZSQxKCdpbWcnKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKGltZywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyhpbWcsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyhpbWcsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHRpbWcub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdGltZy5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcbiAgXHRcdGltZy5vbmxvYWQgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuICBcdFx0aW1nLm9uZXJyb3IgPSBiaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLnpJbmRleCkge1xyXG4gIFx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcbiAgXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuICBcdFx0ICAgIG9mZnNldCA9IHRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsIGUuem9vbSwgZS5jZW50ZXIpLm1pbjtcclxuXHJcbiAgXHRcdHNldFRyYW5zZm9ybSh0aGlzLl9pbWFnZSwgb2Zmc2V0LCBzY2FsZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcclxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG4gIFx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcbiAgXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcbiAgXHRcdHNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcbiAgXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcbiAgXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuICBcdFx0XHR0aGlzLl9pbWFnZS5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vdmVybGF5T25FcnJvcjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBmYWlscyB0byBsb2FkIGl0cyBpbWFnZVxyXG4gIFx0XHR0aGlzLmZpcmUoJ2Vycm9yJyk7XHJcblxyXG4gIFx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG4gIFx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG4gIFx0XHRcdHRoaXMuX3VybCA9IGVycm9yVXJsO1xyXG4gIFx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBJbWFnZU92ZXJsYXkuXHJcbiAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcbiAgLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4gIC8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuICB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcbiAgXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICAgKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gICAqXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAgICpcclxuICAgKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gICAqIEhUTUw1IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gICAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICAgKiBMLnZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG5cclxuICB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuICBcdG9wdGlvbnM6IHtcclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuICBcdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuICBcdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcbiAgXHRcdGxvb3A6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBBc3BlY3RSYXRpbzogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuICBcdFx0Ly8gUmVsZXZhbnQgZm9yIHN1cHBvcnRlZCBicm93c2Vycy4gU2VlIFticm93c2VyIGNvbXBhdGliaWxpdHldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vYmplY3QtZml0KVxyXG4gIFx0XHRrZWVwQXNwZWN0UmF0aW86IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIG9uIG11dGUgd2hlbiBsb2FkZWQuXHJcbiAgXHRcdG11dGVkOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIE1vYmlsZSBicm93c2VycyB3aWxsIHBsYXkgdGhlIHZpZGVvIHJpZ2h0IHdoZXJlIGl0IGlzIGluc3RlYWQgb2Ygb3BlbiBpdCB1cCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcbiAgXHRcdHBsYXlzSW5saW5lOiB0cnVlXHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG4gIFx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBjcmVhdGUkMSgndmlkZW8nKTtcclxuXHJcbiAgXHRcdGFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBhZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBhZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG4gIFx0XHR2aWQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XHJcbiAgXHRcdHZpZC5vbm1vdXNlbW92ZSA9IGZhbHNlRm47XHJcblxyXG4gIFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuICBcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcbiAgXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBiaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcbiAgXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuICBcdFx0XHR2YXIgc291cmNlRWxlbWVudHMgPSB2aWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG4gIFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZUVsZW1lbnRzW2pdLnNyYyk7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKCFpc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuICBcdFx0XHR2aWQuc3R5bGVbJ29iamVjdEZpdCddID0gJ2ZpbGwnO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG4gIFx0XHR2aWQubG9vcCA9ICEhdGhpcy5vcHRpb25zLmxvb3A7XHJcbiAgXHRcdHZpZC5tdXRlZCA9ICEhdGhpcy5vcHRpb25zLm11dGVkO1xyXG4gIFx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuICBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuICBcdFx0XHR2YXIgc291cmNlID0gY3JlYXRlJDEoJ3NvdXJjZScpO1xyXG4gIFx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcbiAgXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHJcbiAgXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MVmlkZW9FbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxWaWRlb0VsZW1lbnQpXHJcbiAgXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudmlkZW9PdmVybGF5KHZpZGVvOiBTdHJpbmd8QXJyYXl8SFRNTFZpZGVvRWxlbWVudCwgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBWaWRlb092ZXJsYXkgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbiAgLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuICBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbiAgfVxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdPdmVybGF5XG4gICAqIEBha2EgTC5TVkdPdmVybGF5XG4gICAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcbiAgICpcbiAgICogVXNlZCB0byBsb2FkLCBkaXNwbGF5IGFuZCBwcm92aWRlIERPTSBhY2Nlc3MgdG8gYW4gU1ZHIGZpbGUgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cbiAgICpcbiAgICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBcIjAgMCAyMDAgMjAwXCIpO1xuICAgKiBzdmdFbGVtZW50LmlubmVySFRNTCA9ICc8cmVjdCB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiLz48cmVjdCB4PVwiNzVcIiB5PVwiMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6cmVkXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIxMjNcIiB3aWR0aD1cIjUwXCIgaGVpZ2h0PVwiNTBcIiBzdHlsZT1cImZpbGw6IzAwMTNmZlwiLz4nO1xuICAgKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAgICogTC5zdmdPdmVybGF5KHN2Z0VsZW1lbnQsIHN2Z0VsZW1lbnRCb3VuZHMpLmFkZFRvKG1hcCk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xuICBcdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBlbCA9IHRoaXMuX2ltYWdlID0gdGhpcy5fdXJsO1xuXG4gIFx0XHRhZGRDbGFzcyhlbCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgYWRkQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XG5cbiAgXHRcdGVsLm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICBcdFx0ZWwub25tb3VzZW1vdmUgPSBmYWxzZUZuO1xuICBcdH1cblxuICBcdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BTVkdFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpXG4gIFx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5zdmdPdmVybGF5KHN2ZzogU3RyaW5nfFNWR0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogU1ZHT3ZlcmxheSBvcHRpb25zKVxuICAvLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gYW4gU1ZHIGVsZW1lbnQgYW5kIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXG4gIC8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuICBmdW5jdGlvbiBzdmdPdmVybGF5KGVsLCBib3VuZHMsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKlxyXG4gICAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAgICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAgICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICAgKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICAgKi9cclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgdmFyIERpdk92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuICBcdC8vIEBzZWN0aW9uXHJcbiAgXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuICBcdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuICBcdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSB1bmRlZmluZWRcclxuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG4gIFx0XHRwYW5lOiB1bmRlZmluZWRcclxuICBcdH0sXHJcblxyXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICBcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAvYC5vcGVuVG9vbHRpcCh0b29sdGlwKWAuXHJcbiAgXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7XHJcbiAgXHRcdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgb3ZlcmxheS5cclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAuY2xvc2VQb3B1cChwb3B1cClgL2AuY2xvc2VUb29sdGlwKHRvb2x0aXApYFxyXG4gIFx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG4gIFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKHRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGUobGF5ZXI/OiBMYXllcik6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgb3ZlcmxheSBib3VuZCB0byBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG4gIFx0Ly8gQWx0ZXJuYXRpdmUgdG8gYGxheWVyLnRvZ2dsZVBvcHVwKClgL2AudG9nZ2xlVG9vbHRpcCgpYC5cclxuICBcdHRvZ2dsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0aGlzLmNsb3NlKCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICBcdFx0XHRcdHRoaXMuX3NvdXJjZSA9IGxheWVyO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0dGhpcy5fcHJlcGFyZU9wZW4oKTtcclxuXHJcbiAgXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcbiAgXHRcdFx0dGhpcy5vcGVuT24obGF5ZXIuX21hcCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuICBcdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICBcdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG4gIFx0XHRcdHNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG4gIFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuICBcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuICBcdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQocmVtb3ZlLCB1bmRlZmluZWQsIHRoaXMuX2NvbnRhaW5lciksIDIwMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcbiAgXHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBuYW1lc3BhY2UgRGl2T3ZlcmxheVxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG4gIFx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG4gIFx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuICBcdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG4gIFx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuICBcdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIG92ZXJsYXkuXHJcbiAgXHRnZXRDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHNldENvbnRlbnQoaHRtbENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbik6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcbiAgXHQvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgb3ZlcmxheS5cclxuICBcdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuICBcdC8vIFJldHVybnMgdGhlIEhUTUwgY29udGFpbmVyIG9mIHRoZSBvdmVybGF5LlxyXG4gIFx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG4gIFx0Ly8gVXBkYXRlcyB0aGUgb3ZlcmxheSBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBvdmVybGF5IGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuICBcdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG4gIFx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuICBcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG4gIFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBldmVudHMgPSB7XHJcbiAgXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG4gIFx0XHR9O1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG4gIFx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBvdmVybGF5IGlzIHZpc2libGUgb24gdGhlIG1hcC5cclxuICBcdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG4gIFx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuICBcdC8vIEJyaW5ncyB0aGlzIG92ZXJsYXkgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgb3ZlcmxheXMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuICBcdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9tYXApIHtcclxuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gcHJlcGFyZSBib3VuZCBvdmVybGF5IHRvIG9wZW46IHVwZGF0ZSBsYXRsbmcgcG9zIC8gY29udGVudCBzb3VyY2UgKGZvciBGZWF0dXJlR3JvdXApXHJcbiAgXHRfcHJlcGFyZU9wZW46IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuICBcdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuICBcdFx0aWYgKCFzb3VyY2UuX21hcCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcbiAgXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuICBcdFx0XHRzb3VyY2UgPSBudWxsO1xyXG4gIFx0XHRcdHZhciBsYXllcnMgPSB0aGlzLl9zb3VyY2UuX2xheWVycztcclxuICBcdFx0XHRmb3IgKHZhciBpZCBpbiBsYXllcnMpIHtcclxuICBcdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuICBcdFx0XHRcdFx0c291cmNlID0gbGF5ZXJzW2lkXTtcclxuICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgXHRcdFx0XHR9XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdGlmICghc291cmNlKSB7IHJldHVybiBmYWxzZTsgfSAvLyBVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllci5cclxuXHJcbiAgXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdGlmICghbGF0bG5nKSB7XHJcbiAgXHRcdFx0aWYgKHNvdXJjZS5nZXRDZW50ZXIpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRMYXRMbmcoKTtcclxuICBcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRCb3VuZHMpIHtcclxuICBcdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuICBcdFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IHNvdXJjZSBsYXllciBMYXRMbmcuJyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHRcdHRoaXMuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XHJcbiAgXHRcdFx0Ly8gdXBkYXRlIHRoZSBvdmVybGF5IChjb250ZW50LCBsYXlvdXQsIGV0Yy4uLilcclxuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLl9jb250ZW50Tm9kZTtcclxuICBcdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuICBcdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG4gIFx0XHRcdG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICBcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbiAgXHRcdC8vIEBzZWN0aW9uIERpdk92ZXJsYXkgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBjb250ZW50dXBkYXRlOiBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuICBcdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcbiAgXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcbiAgXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG4gIFx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcbiAgXHRcdFx0c2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG4gIFx0XHR9IGVsc2Uge1xyXG4gIFx0XHRcdG9mZnNldCA9IG9mZnNldC5hZGQocG9zKS5hZGQoYW5jaG9yKTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuICBcdFx0ICAgIGxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ID0gLU1hdGgucm91bmQodGhpcy5fY29udGFpbmVyV2lkdGggLyAyKSArIG9mZnNldC54O1xyXG5cclxuICBcdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBvdmVybGF5IGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgb3ZlcmxheSBjaGFuZ2VzIChpbWFnZXMgbG9hZGluZyBldGMpXHJcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG4gIFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHJldHVybiBbMCwgMF07XHJcbiAgXHR9XHJcblxyXG4gIH0pO1xyXG5cclxuICBNYXAuaW5jbHVkZSh7XHJcbiAgXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIGNvbnRlbnQsIGxhdGxuZywgb3B0aW9ucykge1xyXG4gIFx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcbiAgXHRcdGlmICghKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpKSB7XHJcbiAgXHRcdFx0b3ZlcmxheSA9IG5ldyBPdmVybGF5Q2xhc3Mob3B0aW9ucykuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRpZiAobGF0bG5nKSB7XHJcbiAgXHRcdFx0b3ZlcmxheS5zZXRMYXRMbmcobGF0bG5nKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIExheWVyLmluY2x1ZGUoe1xyXG4gIFx0X2luaXRPdmVybGF5OiBmdW5jdGlvbiAoT3ZlcmxheUNsYXNzLCBvbGQsIGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuICBcdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG4gIFx0XHRpZiAob3ZlcmxheSBpbnN0YW5jZW9mIE92ZXJsYXlDbGFzcykge1xyXG4gIFx0XHRcdHNldE9wdGlvbnMob3ZlcmxheSwgb3B0aW9ucyk7XHJcbiAgXHRcdFx0b3ZlcmxheS5fc291cmNlID0gdGhpcztcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRvdmVybGF5ID0gKG9sZCAmJiAhb3B0aW9ucykgPyBvbGQgOiBuZXcgT3ZlcmxheUNsYXNzKG9wdGlvbnMsIHRoaXMpO1xyXG4gIFx0XHRcdG92ZXJsYXkuc2V0Q29udGVudChjb250ZW50KTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gb3ZlcmxheTtcclxuICBcdH1cclxuICB9KTtcblxuICAvKlxyXG4gICAqIEBjbGFzcyBQb3B1cFxyXG4gICAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAgICogQGFrYSBMLlBvcHVwXHJcbiAgICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gICAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gICAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gICAqIGBgYFxyXG4gICAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gICAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAgICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICAgKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICAgKiBcdC5vcGVuT24obWFwKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuICB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG4gIFx0Ly8gQHNlY3Rpb25cclxuICBcdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcbiAgXHRcdHBhbmU6ICdwb3B1cFBhbmUnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuICBcdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcbiAgXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcbiAgXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWF4V2lkdGg6IDMwMCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcbiAgXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuICBcdFx0bWluV2lkdGg6IDUwLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuICBcdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG4gIFx0XHQvLyBpbnNpZGUgYSBwb3B1cCBpZiBpdHMgY29udGVudCBleGNlZWRzIGl0LlxyXG4gIFx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgZmFsc2VgIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb25cclxuICBcdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcbiAgXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG4gIFx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcbiAgXHRcdGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcbiAgXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuICBcdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG4gIFx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG4gIFx0XHQvLyBFcXVpdmFsZW50IG9mIHNldHRpbmcgYm90aCB0b3AgbGVmdCBhbmQgYm90dG9tIHJpZ2h0IGF1dG9wYW4gcGFkZGluZyB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICBcdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIFNldCBpdCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gcHJldmVudCB1c2VycyBmcm9tIHBhbm5pbmcgdGhlIHBvcHVwXHJcbiAgXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcbiAgXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZUJ1dHRvbjogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGF1dG9DbG9zZTogQm9vbGVhbiA9IHRydWVcclxuICBcdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuICBcdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICBcdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG4gIFx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG4gIFx0XHQvLyB0aGUgRVNDIGtleSBmb3IgY2xvc2luZyBvZiB0aGUgcG9wdXAuXHJcbiAgXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuICBcdFx0Ly8gU2V0IGl0IGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3NcclxuICBcdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuICBcdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuICBcdFx0Y2xhc3NOYW1lOiAnJ1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuICBcdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcbiAgXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS5cclxuICBcdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcbiAgXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG4gIFx0XHRcdG1hcC5yZW1vdmVMYXllcihtYXAuX3BvcHVwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRtYXAuX3BvcHVwID0gdGhpcztcclxuXHJcbiAgXHRcdHJldHVybiBEaXZPdmVybGF5LnByb3RvdHlwZS5vcGVuT24uY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gIFx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG4gIFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG4gIFx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuICBcdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuICBcdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcbiAgXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG4gIFx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuICBcdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcbiAgXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcbiAgXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG4gIFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuICBcdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcbiAgXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG4gIFx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcbiAgXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG4gIFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcbiAgXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcbiAgXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBldmVudHM7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcbiAgXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JyxcclxuICBcdFx0XHRwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgK1xyXG4gIFx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG4gIFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcbiAgXHRcdGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcbiAgXHRcdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ2NvbnRleHRtZW51Jywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcbiAgXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG4gIFx0XHR0aGlzLl90aXAgPSBjcmVhdGUkMSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuICBcdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG4gIFx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gY3JlYXRlJDEoJ2EnLCBwcmVmaXggKyAnLWNsb3NlLWJ1dHRvbicsIGNvbnRhaW5lcik7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnQ2xvc2UgcG9wdXAnKTtcclxuICBcdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcbiAgXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuICBcdFx0XHRvbihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgdGhpcy5jbG9zZSwgdGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGVudE5vZGUsXHJcbiAgXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcbiAgXHRcdHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcclxuXHJcbiAgXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuICBcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcclxuXHJcbiAgXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG4gIFx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG4gIFx0XHRzdHlsZS5oZWlnaHQgPSAnJztcclxuXHJcbiAgXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG4gIFx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuICBcdFx0ICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCc7XHJcblxyXG4gIFx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG4gIFx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcbiAgXHRcdFx0YWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuICBcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuICBcdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG4gIFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4pIHsgcmV0dXJuOyB9XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAuX3BhbkFuaW0pIHsgdGhpcy5fbWFwLl9wYW5BbmltLnN0b3AoKTsgfVxyXG5cclxuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuICBcdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KGdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuICBcdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcbiAgXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG4gIFx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG4gIFx0XHRsYXllclBvcy5fYWRkKGdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuICBcdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcbiAgXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG4gIFx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuICBcdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG4gIFx0XHQgICAgZHggPSAwLFxyXG4gIFx0XHQgICAgZHkgPSAwO1xyXG5cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG4gIFx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuICBcdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcbiAgXHRcdH1cclxuICBcdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcbiAgXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG4gIFx0XHR9XHJcbiAgXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG4gIFx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuICBcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcbiAgXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcbiAgXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcbiAgXHRcdGlmIChkeCB8fCBkeSkge1xyXG4gIFx0XHRcdG1hcFxyXG4gIFx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuICBcdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldLCB7YW5pbWF0ZTogZSAmJiBlLnR5cGUgPT09ICdtb3ZlZW5kJ30pO1xyXG4gIFx0XHR9XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuICBcdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG4gIFx0fVxyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4gIC8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4gIC8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG4gIHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuICBcdHJldHVybiBuZXcgUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyogQG5hbWVzcGFjZSBNYXBcclxuICAgKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcbiAgICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICAgKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gICAqL1xyXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xyXG4gIFx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBuYW1lc3BhY2UgTWFwXHJcbiAgLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gIE1hcC5pbmNsdWRlKHtcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcbiAgXHQvLyBAYWx0ZXJuYXRpdmVcclxuICBcdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG4gIFx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcbiAgXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG4gIFx0XHQgIC5vcGVuT24odGhpcyk7XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcbiAgXHQvLyBDbG9zZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgb3BlbmVkIHdpdGggW29wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIChvciB0aGUgZ2l2ZW4gb25lKS5cclxuICBcdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gIFx0XHRwb3B1cCA9IGFyZ3VtZW50cy5sZW5ndGggPyBwb3B1cCA6IHRoaXMuX3BvcHVwO1xyXG4gIFx0XHRpZiAocG9wdXApIHtcclxuICBcdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fVxyXG4gIH0pO1xyXG5cclxuICAvKlxyXG4gICAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICAgKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICAgKlxyXG4gICAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICAgKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICAgKiBsYXllci5jbG9zZVBvcHVwKCk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBQb3B1cHMgd2lsbCBhbHNvIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIHdoZW4gdGhlIGxheWVyIGlzIGNsaWNrZWQgb24gYW5kIGNsb3NlZCB3aGVuIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCBvciBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuICAgKi9cclxuXHJcbiAgLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG4gIExheWVyLmluY2x1ZGUoe1xyXG5cclxuICBcdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcbiAgXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG4gIFx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcclxuICBcdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG4gIFx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG4gIFx0XHR0aGlzLl9wb3B1cCA9IHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCB0aGlzLl9wb3B1cCwgY29udGVudCwgb3B0aW9ucyk7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcbiAgXHRcdFx0dGhpcy5vbih7XHJcbiAgXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG4gIFx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcbiAgXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuICBcdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG4gIFx0XHRcdH0pO1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuICBcdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuICBcdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMub2ZmKHtcclxuICBcdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcbiAgXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuICBcdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG4gIFx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcbiAgXHRcdFx0fSk7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcbiAgXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcbiAgXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG4gIFx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xyXG4gIFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuICBcdFx0fVxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG4gIFx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC5jbG9zZSgpO1xyXG4gIFx0XHR9XHJcbiAgXHRcdHJldHVybiB0aGlzO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuICBcdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcbiAgXHR0b2dnbGVQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuICBcdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG4gIFx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgZ2V0UG9wdXAoKTogUG9wdXBcclxuICBcdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcbiAgXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG4gIFx0XHRyZXR1cm4gdGhpcy5fcG9wdXA7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fcG9wdXAgfHwgIXRoaXMuX21hcCkge1xyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG4gIFx0XHRzdG9wKGUpO1xyXG5cclxuICBcdFx0dmFyIHRhcmdldCA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XHJcbiAgXHRcdGlmICh0aGlzLl9wb3B1cC5fc291cmNlID09PSB0YXJnZXQgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gIFx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuICBcdFx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcbiAgXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuICBcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG4gIFx0XHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHRcdHJldHVybjtcclxuICBcdFx0fVxyXG4gIFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG4gIFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcbiAgXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcbiAgXHRcdFx0dGhpcy5fb3BlblBvcHVwKGUpO1xyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgfSk7XG5cbiAgLypcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAgICogQGFrYSBMLlRvb2x0aXBcbiAgICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICAgKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0dGluZzpcbiAgICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gICAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gICAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gICAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAgICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gICAqL1xuXG5cbiAgLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4gIHZhciBUb29sdGlwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuICBcdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuICBcdFx0cGFuZTogJ3Rvb2x0aXBQYW5lJyxcblxuICBcdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcbiAgXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cbiAgXHRcdG9mZnNldDogWzAsIDBdLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG4gIFx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuICBcdFx0Ly8gYHRvcGAsIGBib3R0b21gLCBgY2VudGVyYCwgYGF1dG9gLlxuICBcdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuICBcdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cbiAgXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG4gIFx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG4gIFx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG4gIFx0XHRzdGlja3k6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuICBcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cbiAgXHRcdG9wYWNpdHk6IDAuOVxuICBcdH0sXG5cbiAgXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICBcdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXBcbiAgXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG4gIFx0XHRpZiAodGhpcy5fc291cmNlKSB7XG4gIFx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuICBcdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG4gIFx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG4gIFx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuICBcdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG4gIFx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuICBcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcbiAgXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuICBcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG4gIFx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuICBcdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuICBcdFx0XHR0aGlzLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMuX3NvdXJjZSk7XG5cbiAgXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuICBcdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuICBcdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcbiAgXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG4gIFx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG4gIFx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG4gIFx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuICBcdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBjcmVhdGUkMSgnZGl2JywgY2xhc3NOYW1lKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cbiAgXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0dmFyIHN1YlgsIHN1YlksXG4gIFx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG4gIFx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG4gIFx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcbiAgXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG4gIFx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG4gIFx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcbiAgXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuICBcdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0O1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG4gIFx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuICBcdFx0XHRzdWJZID0gMDtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuICBcdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcbiAgXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICBcdFx0fSBlbHNlIGlmICh0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcbiAgXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgXHRcdFx0c3ViWCA9IDA7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCArIChvZmZzZXQueCArIGFuY2hvci54KSAqIDI7XG4gIFx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcbiAgXHRcdH1cblxuICBcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQoc3ViWCwgc3ViWSwgdHJ1ZSkpLmFkZChvZmZzZXQpLmFkZChhbmNob3IpO1xuXG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcbiAgXHRcdHJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG4gIFx0XHRzZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcbiAgXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG4gIFx0fSxcblxuICBcdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cbiAgXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG4gIFx0fVxuXG4gIH0pO1xuXG4gIC8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuICAvLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4gIC8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG4gIHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICBcdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xuICB9O1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbiAgTWFwLmluY2x1ZGUoe1xuXG4gIFx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cbiAgXHQvLyBAYWx0ZXJuYXRpdmVcbiAgXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG4gIFx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcbiAgXHRcdCAgLm9wZW5Pbih0aGlzKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG4gIFx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gIFx0XHR0b29sdGlwLmNsb3NlKCk7XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9XG5cbiAgfSk7XG5cbiAgLypcbiAgICogQG5hbWVzcGFjZSBMYXllclxuICAgKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICAgKlxuICAgKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICAgKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICAgKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIC8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuICBMYXllci5pbmNsdWRlKHtcblxuICBcdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG4gIFx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuICBcdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG4gIFx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG4gIFx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kVG9vbHRpcCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG4gIFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG4gIFx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG4gIFx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cbiAgXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuICBcdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcbiAgXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gIFx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcbiAgXHRcdCAgICBldmVudHMgPSB7XG4gIFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG4gIFx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG4gIFx0XHQgICAgfTtcbiAgXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuICBcdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuICBcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG4gIFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcbiAgXHRcdH1cbiAgXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG4gIFx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuICBcdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgdG9vbHRpcCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuICBcdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gIFx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl90b29sdGlwLl9wcmVwYXJlT3BlbihsYXRsbmcpKSB7XG4gIFx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuICBcdFx0XHR0aGlzLl90b29sdGlwLm9wZW5Pbih0aGlzLl9tYXApO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuICBcdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuY2xvc2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcbiAgXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gIFx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcbiAgXHRcdFx0dGhpcy5fdG9vbHRpcC50b2dnbGUodGhpcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cbiAgXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuICBcdGlzVG9vbHRpcE9wZW46IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIHNldFRvb2x0aXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxUb29sdGlwKTogdGhpc1xuICBcdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG4gIFx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuICBcdC8vIFJldHVybnMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cbiAgXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcbiAgXHR9LFxuXG4gIFx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8ICF0aGlzLl9tYXAgfHwgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cbiAgXHRcdHRoaXMub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSA/IGUubGF0bG5nIDogdW5kZWZpbmVkKTtcbiAgXHR9LFxuXG4gIFx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nLCBjb250YWluZXJQb2ludCwgbGF5ZXJQb2ludDtcbiAgXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuICBcdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuICBcdFx0XHRsYXllclBvaW50ID0gdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KTtcbiAgXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG4gIFx0fVxuICB9KTtcblxuICAvKlxuICAgKiBAY2xhc3MgRGl2SWNvblxuICAgKiBAYWthIEwuRGl2SWNvblxuICAgKiBAaW5oZXJpdHMgSWNvblxuICAgKlxuICAgKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICAgKiBlbGVtZW50IGluc3RlYWQgb2YgYW4gaW1hZ2UuIEluaGVyaXRzIGZyb20gYEljb25gIGJ1dCBpZ25vcmVzIHRoZSBgaWNvblVybGAgYW5kIHNoYWRvdyBvcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAgICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAgICpcbiAgICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAgICovXG5cbiAgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQHNlY3Rpb25cbiAgXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG4gIFx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG4gIFx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuICBcdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cbiAgXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcbiAgXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuIEFsdGVybmF0aXZlbHksXG4gIFx0XHQvLyBhbiBpbnN0YW5jZSBvZiBgSFRNTEVsZW1lbnRgLlxuICBcdFx0aHRtbDogZmFsc2UsXG5cbiAgXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG4gIFx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG4gIFx0XHRiZ1BvczogbnVsbCxcblxuICBcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcbiAgXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICBcdFx0XHRlbXB0eShkaXYpO1xuICBcdFx0XHRkaXYuYXBwZW5kQ2hpbGQob3B0aW9ucy5odG1sKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG4gIFx0XHRcdHZhciBiZ1BvcyA9IHRvUG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG4gIFx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4JztcbiAgXHRcdH1cbiAgXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG4gIFx0XHRyZXR1cm4gZGl2O1xuICBcdH0sXG5cbiAgXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIGBEaXZJY29uYCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IERpdkljb24ob3B0aW9ucyk7XG4gIH1cblxuICBJY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcblxuICAvKlxuICAgKiBAY2xhc3MgR3JpZExheWVyXG4gICAqIEBpbmhlcml0cyBMYXllclxuICAgKiBAYWthIEwuR3JpZExheWVyXG4gICAqXG4gICAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAgICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICAgKlxuICAgKlxuICAgKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAgICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gICAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICpcbiAgICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICAgKiAgICAgICAgIHJldHVybiB0aWxlO1xuICAgKiAgICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICAgKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAgICogICAgICAgICB2YXIgZXJyb3I7XG4gICAqXG4gICAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICAgKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICAgKlxuICAgKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAgICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICAgKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICAgKlxuICAgKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAgICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAgICogICAgICAgICB9LCAxMDAwKTtcbiAgICpcbiAgICogICAgICAgICByZXR1cm4gdGlsZTtcbiAgICogICAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VjdGlvblxuICAgKi9cblxuXG4gIHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG4gIFx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG4gIFx0XHR0aWxlU2l6ZTogMjU2LFxuXG4gIFx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuICBcdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cbiAgXHRcdG9wYWNpdHk6IDEsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcbiAgXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG4gIFx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuICBcdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcbiAgXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG4gIFx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cbiAgXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cbiAgXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcbiAgXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG4gIFx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuICBcdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cbiAgXHRcdHpJbmRleDogMSxcblxuICBcdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuICBcdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuICBcdFx0Ym91bmRzOiBudWxsLFxuXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcbiAgXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuICBcdFx0bWluWm9vbTogMCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cbiAgXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuICBcdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcbiAgXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcbiAgXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG4gIFx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG4gIFx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG4gIFx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG4gIFx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cbiAgXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG4gIFx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG4gIFx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuICBcdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3RpbmdcbiAgXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG4gIFx0XHRub1dyYXA6IGZhbHNlLFxuXG4gIFx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcbiAgXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cbiAgXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cbiAgXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuICBcdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG4gIFx0XHRjbGFzc05hbWU6ICcnLFxuXG4gIFx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcbiAgXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cbiAgXHRcdGtlZXBCdWZmZXI6IDJcbiAgXHR9LFxuXG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cbiAgXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuICBcdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuICBcdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG4gIFx0fSxcblxuICBcdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuICBcdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG4gIFx0fSxcblxuICBcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcbiAgXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG4gIFx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuICBcdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cbiAgXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcCkge1xuICBcdFx0XHR0b0JhY2sodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG4gIFx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHRpbGVzIGZvciB0aGlzIGxheWVyLlxuICBcdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcbiAgXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuICBcdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICBcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuICBcdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNncmlkbGF5ZXItemluZGV4KSBvZiB0aGUgZ3JpZCBsYXllci5cbiAgXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG4gIFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgaXNMb2FkaW5nOiBCb29sZWFuXG4gIFx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuICBcdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gIFx0fSxcblxuICBcdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG4gIFx0Ly8gQ2F1c2VzIHRoZSBsYXllciB0byBjbGVhciBhbGwgdGhlIHRpbGVzIGFuZCByZXF1ZXN0IHRoZW0gYWdhaW4uXG4gIFx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHZhciB0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0ge1xuICBcdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gIFx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRWaWV3LFxuICBcdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG4gIFx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICBcdFx0fTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcbiAgXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG4gIFx0XHRcdGlmICghdGhpcy5fb25Nb3ZlKSB7XG4gIFx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gdGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gIFx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cbiAgXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG4gIFx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuICBcdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcbiAgXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG4gIFx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBcdH0sXG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG4gIFx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG4gIFx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuICBcdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcbiAgXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuICBcdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cbiAgXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcbiAgXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cbiAgXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG4gIFx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cbiAgXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuICBcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuICBcdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuICBcdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG4gIFx0XHRzZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG4gIFx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG4gIFx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG4gIFx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG4gIFx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcbiAgXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG4gIFx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cbiAgXHRcdGlmIChuZXh0RnJhbWUpIHtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9vbk9wYXF1ZVRpbGU6IGZhbHNlRm4sXG5cbiAgXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICBcdFx0dGhpcy5fY29udGFpbmVyID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuICBcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcbiAgXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG4gIFx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG4gIFx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBcdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcbiAgXHRcdFx0eiA9IE51bWJlcih6KTtcbiAgXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuICBcdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuICBcdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG4gIFx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG4gIFx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcbiAgXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcbiAgXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdGlmICghbGV2ZWwpIHtcbiAgXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuICBcdFx0XHRsZXZlbC5lbCA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuICBcdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG4gIFx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuICBcdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG4gIFx0XHRcdGZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG4gIFx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG4gIFx0XHRyZXR1cm4gbGV2ZWw7XG4gIFx0fSxcblxuICBcdF9vblVwZGF0ZUxldmVsOiBmYWxzZUZuLFxuXG4gIFx0X29uUmVtb3ZlTGV2ZWw6IGZhbHNlRm4sXG5cbiAgXHRfb25DcmVhdGVMZXZlbDogZmFsc2VGbixcblxuICBcdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXksIHRpbGU7XG5cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcbiAgXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuICBcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcbiAgXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG4gIFx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuICBcdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuICBcdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcbiAgXHRcdFx0XHRjb250aW51ZTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG4gIFx0XHRcdHJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuICBcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih6KSk7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG4gIFx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcbiAgXHR9LFxuXG4gIFx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcbiAgXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuICBcdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG4gIFx0XHQgICAgejIgPSB6IC0gMSxcbiAgXHRcdCAgICBjb29yZHMyID0gbmV3IFBvaW50KCt4MiwgK3kyKTtcbiAgXHRcdGNvb3JkczIueiA9ICt6MjtcblxuICBcdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcbiAgXHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuICBcdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcbiAgXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICBcdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gIFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHoyID4gbWluWm9vbSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9yZXRhaW5DaGlsZHJlbjogZnVuY3Rpb24gKHgsIHksIHosIG1heFpvb20pIHtcblxuICBcdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcbiAgXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuICBcdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG4gIFx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuICBcdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcbiAgXHRcdFx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuICBcdFx0XHRcdFx0Y29udGludWU7XG5cbiAgXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcbiAgXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG4gIFx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcbiAgXHRcdHRoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpLCBhbmltYXRpbmcsIGFuaW1hdGluZyk7XG4gIFx0fSxcblxuICBcdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHRoaXMuX3NldFZpZXcoZS5jZW50ZXIsIGUuem9vbSwgdHJ1ZSwgZS5ub1VwZGF0ZSk7XG4gIFx0fSxcblxuICBcdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHpvb207XG4gIFx0fSxcblxuICBcdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuICBcdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcbiAgXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuICBcdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG4gIFx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20odGlsZVpvb20pO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG4gIFx0XHRpZiAoIW5vVXBkYXRlIHx8IHRpbGVab29tQ2hhbmdlZCkge1xuXG4gIFx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cbiAgXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuICBcdFx0XHRcdHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0R3JpZCgpO1xuXG4gIFx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIW5vUHJ1bmUpIHtcbiAgXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuICBcdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcbiAgXHRcdFx0dGhpcy5fbm9QcnVuZSA9ICEhbm9QcnVuZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG4gIFx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuICBcdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tpXSwgY2VudGVyLCB6b29tKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3NldFpvb21UcmFuc2Zvcm06IGZ1bmN0aW9uIChsZXZlbCwgY2VudGVyLCB6b29tKSB7XG4gIFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuICBcdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuICBcdFx0ICAgICAgICAuc3VidHJhY3QodGhpcy5fbWFwLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pKS5yb3VuZCgpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuICBcdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG4gIFx0XHQgICAgdGlsZVpvb20gPSB0aGlzLl90aWxlWm9vbTtcblxuICBcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dGhpcy5fZ2xvYmFsVGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShib3VuZHMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcbiAgXHRcdFx0TWF0aC5mbG9vcihtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMF1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLngpLFxuICBcdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuICBcdFx0XTtcbiAgXHRcdHRoaXMuX3dyYXBZID0gY3JzLndyYXBMYXQgJiYgIXRoaXMub3B0aW9ucy5ub1dyYXAgJiYgW1xuICBcdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG4gIFx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG4gIFx0XHRdO1xuICBcdH0sXG5cbiAgXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHRfZ2V0VGlsZWRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlcikge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKG1hcFpvb20sIHRoaXMuX3RpbGVab29tKSxcbiAgXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG4gIFx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cbiAgXHRcdHJldHVybiBuZXcgQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG4gIFx0fSxcblxuICBcdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuICBcdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIFx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cbiAgXHRcdHZhciB6b29tID0gdGhpcy5fY2xhbXBab29tKG1hcC5nZXRab29tKCkpO1xuXG4gIFx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG4gIFx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuICBcdFx0dmFyIHBpeGVsQm91bmRzID0gdGhpcy5fZ2V0VGlsZWRQaXhlbEJvdW5kcyhjZW50ZXIpLFxuICBcdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuICBcdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG4gIFx0XHQgICAgcXVldWUgPSBbXSxcbiAgXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcbiAgXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuICBcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cbiAgXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuICBcdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1pbi55KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuICBcdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcbiAgXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3JkcztcbiAgXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuICBcdFx0XHRcdHRoaXMuX3RpbGVzW2tleV0uY3VycmVudCA9IGZhbHNlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIF91cGRhdGUganVzdCBsb2FkcyBtb3JlIHRpbGVzLiBJZiB0aGUgdGlsZSB6b29tIGxldmVsIGRpZmZlcnMgdG9vIG11Y2hcbiAgXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG4gIFx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuICBcdFx0Ly8gY3JlYXRlIGEgcXVldWUgb2YgY29vcmRpbmF0ZXMgdG8gbG9hZCB0aWxlcyBmcm9tXG4gIFx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG4gIFx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcbiAgXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuICBcdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cbiAgXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuICBcdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuICBcdFx0XHRcdGlmICh0aWxlKSB7XG4gIFx0XHRcdFx0XHR0aWxlLmN1cnJlbnQgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuICBcdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuICBcdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcbiAgXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcbiAgXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuICBcdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG4gIFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuICBcdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcbiAgXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcbiAgXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcbiAgXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuICBcdFx0cmV0dXJuIHRvTGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuICBcdH0sXG5cbiAgXHRfa2V5VG9Cb3VuZHM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuICBcdH0sXG5cbiAgXHRfdGlsZUNvb3Jkc1RvTndTZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcbiAgXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuICBcdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG4gIFx0XHQgICAgbncgPSBtYXAudW5wcm9qZWN0KG53UG9pbnQsIGNvb3Jkcy56KSxcbiAgXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuICBcdFx0cmV0dXJuIFtudywgc2VdO1xuICBcdH0sXG5cbiAgXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGl0cyBnZW9ncmFwaGljYWwgYm91bmRzXG4gIFx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0dmFyIGJwID0gdGhpcy5fdGlsZUNvb3Jkc1RvTndTZShjb29yZHMpLFxuICBcdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoYnBbMF0sIGJwWzFdKTtcblxuICBcdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG4gIFx0XHRcdGJvdW5kcyA9IHRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gYm91bmRzO1xuICBcdH0sXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBrZXkgZm9yIHRoZSB0aWxlIGNhY2hlXG4gIFx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICBcdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcbiAgXHR9LFxuXG4gIFx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcbiAgXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgayA9IGtleS5zcGxpdCgnOicpLFxuICBcdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuICBcdFx0Y29vcmRzLnogPSAra1syXTtcbiAgXHRcdHJldHVybiBjb29yZHM7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHJlbW92ZSh0aWxlLmVsKTtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cbiAgXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcbiAgXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG4gIFx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG4gIFx0XHRcdHRpbGU6IHRpbGUuZWwsXG4gIFx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG4gIFx0XHRhZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cbiAgXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAgXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4JztcbiAgXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cbiAgXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gIFx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gZmFsc2VGbjtcblxuICBcdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcbiAgXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuICBcdFx0XHRzZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuICBcdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG4gIFx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cbiAgXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG4gIFx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuICBcdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcbiAgXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2VcbiAgXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuICBcdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuICBcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKGJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcbiAgXHRcdH1cblxuICBcdFx0c2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cbiAgXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuICBcdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcbiAgXHRcdFx0ZWw6IHRpbGUsXG4gIFx0XHRcdGNvb3JkczogY29vcmRzLFxuICBcdFx0XHRjdXJyZW50OiB0cnVlXG4gIFx0XHR9O1xuXG4gIFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG4gIFx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG4gIFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuICBcdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuICBcdFx0XHR0aWxlOiB0aWxlLFxuICBcdFx0XHRjb29yZHM6IGNvb3Jkc1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuICBcdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcbiAgXHRcdFx0XHRlcnJvcjogZXJyLFxuICBcdFx0XHRcdHRpbGU6IHRpbGUsXG4gIFx0XHRcdFx0Y29vcmRzOiBjb29yZHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuICBcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0c2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcbiAgXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG4gIFx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG4gIFx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFlcnIpIHtcbiAgXHRcdFx0YWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuICBcdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuICBcdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cbiAgXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcbiAgXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuICBcdFx0XHRcdGNvb3JkczogY29vcmRzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG4gIFx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG4gIFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuICBcdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuICBcdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcbiAgXHRcdFx0XHRyZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcbiAgXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cbiAgXHRcdFx0XHRzZXRUaW1lb3V0KGJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG4gIFx0fSxcblxuICBcdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gIFx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuICBcdFx0XHR0aGlzLl93cmFwWCA/IHdyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuICBcdFx0XHR0aGlzLl93cmFwWSA/IHdyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcbiAgXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG4gIFx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuICBcdH0sXG5cbiAgXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICBcdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG4gIFx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuICBcdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuICBcdH0sXG5cbiAgXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG4gIFx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbiAgLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbiAgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qXHJcbiAgICogQGNsYXNzIFRpbGVMYXllclxyXG4gICAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyXHJcbiAgICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIE5vdGUgdGhhdCBtb3N0IHRpbGUgc2VydmVycyByZXF1aXJlIGF0dHJpYnV0aW9uLCB3aGljaCB5b3UgY2FuIHNldCB1bmRlciBgTGF5ZXJgLiBFeHRlbmRzIGBHcmlkTGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2JhcicsIGF0dHJpYnV0aW9uOiAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnfSkuYWRkVG8obWFwKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICpcclxuICAgKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gICAqXHJcbiAgICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAgICpcclxuICAgKiBgYGBcclxuICAgKiBMLnRpbGVMYXllcignaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20ve2Zvb30ve3p9L3t4fS97eX0ucG5nJywge2ZvbzogJ2Jhcid9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuXHJcblxyXG4gIHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIgb3B0aW9uc1xyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuICBcdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcbiAgXHRcdG1pblpvb206IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcbiAgXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuICBcdFx0bWF4Wm9vbTogMTgsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcbiAgXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gIFx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG4gIFx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcbiAgXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcbiAgXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG4gIFx0XHR0bXM6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcbiAgXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuICBcdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuICBcdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtDT1JTIFNldHRpbmdzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlcykgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuICBcdFx0Ly8gV2hldGhlciB0aGUgcmVmZXJyZXJQb2xpY3kgYXR0cmlidXRlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRpbGVzLlxyXG4gIFx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciByZWZlcnJlclBvbGljeSBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuXHJcbiAgXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcbiAgXHRcdC8vIChlLmcuIHRvIHZhbGlkYXRlIGFuIEFQSSB0b2tlbikuXHJcbiAgXHRcdC8vIFJlZmVyIHRvIFtIVE1MSW1hZ2VFbGVtZW50LnJlZmVycmVyUG9saWN5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudC9yZWZlcnJlclBvbGljeSkgZm9yIHZhbGlkIFN0cmluZyB2YWx1ZXMuXHJcbiAgXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG4gIFx0fSxcclxuXHJcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gIFx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuICBcdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hICYmIG9wdGlvbnMubWF4Wm9vbSA+IDApIHtcclxuXHJcbiAgXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuICBcdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldCsrO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcbiAgXHRcdFx0fSBlbHNlIHtcclxuICBcdFx0XHRcdG9wdGlvbnMuem9vbU9mZnNldC0tO1xyXG4gIFx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcbiAgXHRcdFx0fVxyXG5cclxuICBcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuICBcdFx0XHRvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuICBcdC8vIElmIHRoZSBVUkwgZG9lcyBub3QgY2hhbmdlLCB0aGUgbGF5ZXIgd2lsbCBub3QgYmUgcmVkcmF3biB1bmxlc3NcclxuICBcdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG4gIFx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG4gIFx0XHRpZiAodGhpcy5fdXJsID09PSB1cmwgJiYgbm9SZWRyYXcgPT09IHVuZGVmaW5lZCkge1xyXG4gIFx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICBcdFx0aWYgKCFub1JlZHJhdykge1xyXG4gIFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcbiAgXHRcdH1cclxuICBcdFx0cmV0dXJuIHRoaXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuICBcdC8vIHRvIHJldHVybiBhbiBgPGltZz5gIEhUTUwgZWxlbWVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuICBcdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuICBcdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuICBcdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcbiAgXHRcdG9uKHRpbGUsICdsb2FkJywgYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcbiAgXHRcdG9uKHRpbGUsICdlcnJvcicsIGJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcbiAgXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gfHwgdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAnJykge1xyXG4gIFx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0Ly8gZm9yIHRoaXMgbmV3IG9wdGlvbiB3ZSBmb2xsb3cgdGhlIGRvY3VtZW50ZWQgYmVoYXZpb3JcclxuICBcdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuICBcdFx0aWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXJyZXJQb2xpY3kgPT09ICdzdHJpbmcnKSB7XHJcbiAgXHRcdFx0dGlsZS5yZWZlcnJlclBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWZlcnJlclBvbGljeTtcclxuICBcdFx0fVxyXG5cclxuICBcdFx0LypcclxuICBcdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuICBcdFx0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcbiAgXHRcdCovXHJcbiAgXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG4gIFx0XHQvKlxyXG4gIFx0XHQgU2V0IHJvbGU9XCJwcmVzZW50YXRpb25cIiB0byBmb3JjZSBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhpc1xyXG4gIFx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcbiAgXHRcdCovXHJcbiAgXHRcdHRpbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cclxuICBcdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcbiAgXHRcdHJldHVybiB0aWxlO1xyXG4gIFx0fSxcclxuXHJcbiAgXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gIFx0Ly8gQHVuaW5oZXJpdGFibGVcclxuICBcdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcbiAgXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuICBcdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuICBcdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG4gIFx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG4gIFx0XHR2YXIgZGF0YSA9IHtcclxuICBcdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcbiAgXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcbiAgXHRcdFx0eDogY29vcmRzLngsXHJcbiAgXHRcdFx0eTogY29vcmRzLnksXHJcbiAgXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcbiAgXHRcdH07XHJcbiAgXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG4gIFx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuICBcdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG4gIFx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHRcdH1cclxuICBcdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGVtcGxhdGUodGhpcy5fdXJsLCBleHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcbiAgXHR9LFxyXG5cclxuICBcdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG4gIFx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG4gIFx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG4gIFx0XHRcdHNldFRpbWVvdXQoYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcbiAgXHRcdH0gZWxzZSB7XHJcbiAgXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuICBcdFx0fVxyXG4gIFx0fSxcclxuXHJcbiAgXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcbiAgXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcbiAgXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgIT09IGVycm9yVXJsKSB7XHJcbiAgXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuICBcdFx0fVxyXG4gIFx0XHRkb25lKGUsIHRpbGUpO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG4gIFx0XHRlLnRpbGUub25sb2FkID0gbnVsbDtcclxuICBcdH0sXHJcblxyXG4gIFx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuICBcdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcclxuICBcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG4gIFx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuICBcdFx0em9vbU9mZnNldCA9IHRoaXMub3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuICBcdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcbiAgXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcbiAgXHR9LFxyXG5cclxuICBcdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuICBcdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcbiAgXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcbiAgXHR9LFxyXG5cclxuICBcdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcbiAgXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgXHRcdHZhciBpLCB0aWxlO1xyXG4gIFx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuICBcdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcbiAgXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG4gIFx0XHRcdFx0dGlsZS5vbmxvYWQgPSBmYWxzZUZuO1xyXG4gIFx0XHRcdFx0dGlsZS5vbmVycm9yID0gZmFsc2VGbjtcclxuXHJcbiAgXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuICBcdFx0XHRcdFx0dGlsZS5zcmMgPSBlbXB0eUltYWdlVXJsO1xyXG4gIFx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG4gIFx0XHRcdFx0XHRyZW1vdmUodGlsZSk7XHJcbiAgXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuICBcdFx0XHRcdFx0Ly8gQGV2ZW50IHRpbGVhYm9ydDogVGlsZUV2ZW50XHJcbiAgXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuICBcdFx0XHRcdFx0dGhpcy5maXJlKCd0aWxlYWJvcnQnLCB7XHJcbiAgXHRcdFx0XHRcdFx0dGlsZTogdGlsZSxcclxuICBcdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG4gIFx0XHRcdFx0XHR9KTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdH1cclxuICBcdH0sXHJcblxyXG4gIFx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuICBcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xyXG4gIFx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XHJcblxyXG4gIFx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcbiAgXHRcdHRpbGUuZWwuc2V0QXR0cmlidXRlKCdzcmMnLCBlbXB0eUltYWdlVXJsKTtcclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcywga2V5KTtcclxuICBcdH0sXHJcblxyXG4gIFx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcbiAgXHRcdGlmICghdGhpcy5fbWFwIHx8ICh0aWxlICYmIHRpbGUuZ2V0QXR0cmlidXRlKCdzcmMnKSA9PT0gZW1wdHlJbWFnZVVybCkpIHtcclxuICBcdFx0XHRyZXR1cm47XHJcbiAgXHRcdH1cclxuXHJcbiAgXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcbiAgXHR9XHJcbiAgfSk7XHJcblxyXG5cclxuICAvLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbiAgLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgLypcclxuICAgKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gICAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICAgKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gICAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gICAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gICAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICAgKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcblxyXG4gIHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcbiAgXHQvLyBAc2VjdGlvblxyXG4gIFx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuICBcdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuICBcdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcbiAgXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cHM6Ly9kb2NzLmdlb3NlcnZlci5vcmcvc3RhYmxlL2VuL3VzZXIvc2VydmljZXMvd21zL3ZlbmRvci5odG1sKS5cclxuICBcdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuICBcdFx0c2VydmljZTogJ1dNUycsXHJcbiAgXHRcdHJlcXVlc3Q6ICdHZXRNYXAnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcbiAgXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuICBcdFx0bGF5ZXJzOiAnJyxcclxuXHJcbiAgXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG4gIFx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG4gIFx0XHRzdHlsZXM6ICcnLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG4gIFx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuICBcdFx0Zm9ybWF0OiAnaW1hZ2UvanBlZycsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuICBcdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG4gIFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXHJcblxyXG4gIFx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuICBcdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcbiAgXHRcdHZlcnNpb246ICcxLjEuMSdcclxuICBcdH0sXHJcblxyXG4gIFx0b3B0aW9uczoge1xyXG4gIFx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gbnVsbFxyXG4gIFx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG4gIFx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuICBcdFx0Y3JzOiBudWxsLFxyXG5cclxuICBcdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG4gIFx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG4gIFx0XHR1cHBlcmNhc2U6IGZhbHNlXHJcbiAgXHR9LFxyXG5cclxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcbiAgXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG4gIFx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG4gIFx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuICBcdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuICBcdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgXHRcdHZhciByZWFsUmV0aW5hID0gb3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcclxuICBcdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG4gIFx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuICBcdFx0d21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplLnkgKiByZWFsUmV0aW5hO1xyXG5cclxuICBcdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcbiAgXHR9LFxyXG5cclxuICBcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG4gIFx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuICBcdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG4gIFx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuICBcdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcbiAgXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG4gIFx0fSxcclxuXHJcbiAgXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG4gIFx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuICBcdFx0ICAgIGNycyA9IHRoaXMuX2NycyxcclxuICBcdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcbiAgXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG4gIFx0XHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuICBcdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcbiAgXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuICBcdFx0ICAgIFttaW4ueCwgbWluLnksIG1heC54LCBtYXgueV0pLmpvaW4oJywnKSxcclxuICBcdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcbiAgXHRcdHJldHVybiB1cmwgK1xyXG4gIFx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuICBcdFx0XHQodGhpcy5vcHRpb25zLnVwcGVyY2FzZSA/ICcmQkJPWD0nIDogJyZiYm94PScpICsgYmJveDtcclxuICBcdH0sXHJcblxyXG4gIFx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuICBcdC8vIE1lcmdlcyBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IHBhcmFtZXRlcnMgYW5kIHJlLXJlcXVlc3RzIHRpbGVzIG9uIHRoZSBjdXJyZW50IHNjcmVlbiAodW5sZXNzIGBub1JlZHJhd2Agd2FzIHNldCB0byB0cnVlKS5cclxuICBcdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcbiAgXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcbiAgXHRcdGlmICghbm9SZWRyYXcpIHtcclxuICBcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG4gIFx0XHR9XHJcblxyXG4gIFx0XHRyZXR1cm4gdGhpcztcclxuICBcdH1cclxuICB9KTtcclxuXHJcblxyXG4gIC8vIEBmYWN0b3J5IEwudGlsZUxheWVyLndtcyhiYXNlVXJsOiBTdHJpbmcsIG9wdGlvbnM6IFRpbGVMYXllci5XTVMgb3B0aW9ucylcclxuICAvLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbiAgZnVuY3Rpb24gdGlsZUxheWVyV01TKHVybCwgb3B0aW9ucykge1xyXG4gIFx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxuICB9XG5cbiAgVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbiAgdGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcblxuICAvKlxuICAgKiBAY2xhc3MgUmVuZGVyZXJcbiAgICogQGluaGVyaXRzIExheWVyXG4gICAqIEBha2EgTC5SZW5kZXJlclxuICAgKlxuICAgKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICAgKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICAgKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAgICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICAgKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gICAqXG4gICAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gICAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cbiAgXHQvLyBAc2VjdGlvblxuICBcdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuICBcdG9wdGlvbnM6IHtcbiAgXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG4gIFx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcbiAgXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuICBcdFx0cGFkZGluZzogMC4xXG4gIFx0fSxcblxuICBcdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICBcdFx0c3RhbXAodGhpcyk7XG4gIFx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICBcdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cbiAgXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICBcdFx0XHRcdGFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHR0aGlzLl91cGRhdGUoKTtcbiAgXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG4gIFx0XHR0aGlzLl9kZXN0cm95Q29udGFpbmVyKCk7XG4gIFx0fSxcblxuICBcdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50cyA9IHtcbiAgXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcbiAgXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuICBcdFx0XHRtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gIFx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcbiAgXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiBldmVudHM7XG4gIFx0fSxcblxuICBcdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybShldi5jZW50ZXIsIGV2Lnpvb20pO1xuICBcdH0sXG5cbiAgXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fbWFwLmdldENlbnRlcigpLCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuICBcdFx0dmFyIHNjYWxlID0gdGhpcy5fbWFwLmdldFpvb21TY2FsZSh6b29tLCB0aGlzLl96b29tKSxcbiAgXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG4gIFx0XHQgICAgY3VycmVudENlbnRlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLCB6b29tKSxcblxuICBcdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKGN1cnJlbnRDZW50ZXJQb2ludClcbiAgXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG4gIFx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuICBcdFx0XHRzZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRzZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHRvcExlZnRPZmZzZXQpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZSgpO1xuICBcdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fcHJvamVjdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICBcdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVXBkYXRlIHBpeGVsIGJvdW5kcyBvZiByZW5kZXJlciBjb250YWluZXIgKGZvciBwb3NpdGlvbmluZy9zaXppbmcvY2xpcHBpbmcgbGF0ZXIpXG4gIFx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICBcdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcbiAgXHRcdCAgICBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKSxcbiAgXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuICBcdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG4gIFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gIFx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8qXG4gICAqIEBjbGFzcyBDYW52YXNcbiAgICogQGluaGVyaXRzIFJlbmRlcmVyXG4gICAqIEBha2EgTC5DYW52YXNcbiAgICpcbiAgICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAgICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAgICpcbiAgICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vY2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICAgKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gICAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAgICpcbiAgICogYGBganNcbiAgICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAgICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAgICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAgICogYGBgXG4gICAqL1xuXG4gIHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXG4gIFx0Ly8gQHNlY3Rpb25cbiAgXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG4gIFx0b3B0aW9uczoge1xuICBcdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcbiAgXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG4gIFx0XHR0b2xlcmFuY2U6IDBcbiAgXHR9LFxuXG4gIFx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuICBcdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuICBcdFx0cmV0dXJuIGV2ZW50cztcbiAgXHR9LFxuXG4gIFx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuICBcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG4gIFx0fSxcblxuICBcdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuICBcdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuICBcdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cbiAgXHRcdHRoaXMuX2RyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBcdFx0b24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuICBcdFx0b24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgXHRcdG9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuICBcdFx0Y29udGFpbmVyWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcmVkcmF3UmVxdWVzdCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fY3R4O1xuICBcdFx0cmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRvZmYodGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBsYXllcjtcbiAgXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG4gIFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICBcdFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0XHR0aGlzLl9yZWRyYXcoKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcbiAgXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG4gIFx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cbiAgXHRcdHNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG4gIFx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG4gIFx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuICBcdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG4gIFx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICBcdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cbiAgXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuICBcdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuICBcdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG4gIFx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcbiAgXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcbiAgXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcbiAgXHRcdFx0bGF5ZXI6IGxheWVyLFxuICBcdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcbiAgXHRcdFx0bmV4dDogbnVsbFxuICBcdFx0fTtcbiAgXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG4gIFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG4gIFx0fSxcblxuICBcdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG4gIFx0XHRpZiAocHJldikge1xuICBcdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuICBcdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcbiAgXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0bGF5ZXIuX3Byb2plY3QoKTtcbiAgXHRcdGxheWVyLl91cGRhdGUoKTtcbiAgXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcbiAgXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuICBcdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxcbiAgXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuICBcdFx0XHQgICAgZGFzaFZhbHVlLFxuICBcdFx0XHQgICAgaTtcbiAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcbiAgXHRcdFx0XHQvLyBJZ25vcmUgZGFzaCBhcnJheSBjb250YWluaW5nIGludmFsaWQgbGVuZ3Roc1xuICBcdFx0XHRcdGlmIChpc05hTihkYXNoVmFsdWUpKSB7IHJldHVybjsgfVxuICBcdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuICBcdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcbiAgXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuICBcdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG4gIFx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG4gIFx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcbiAgXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuICBcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcbiAgXHR9LFxuXG4gIFx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0aWYgKGJvdW5kcykge1xuICBcdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX2N0eC5zYXZlKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcbiAgXHRcdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuICBcdFx0dGhpcy5fY3R4LnNhdmUoKTtcbiAgXHRcdGlmIChib3VuZHMpIHtcbiAgXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuICBcdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG4gIFx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG4gIFx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG4gIFx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuICBcdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuICBcdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG4gIFx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cbiAgXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuICBcdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuICBcdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cbiAgXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG4gIFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gIFx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuICBcdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGlmIChjbG9zZWQpIHtcbiAgXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuICBcdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG4gIFx0fSxcblxuICBcdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG4gIFx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuICBcdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcyA9IChNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcikgLyByO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHguc2F2ZSgpO1xuICBcdFx0XHRjdHguc2NhbGUoMSwgcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGN0eC5iZWdpblBhdGgoKTtcbiAgXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG4gIFx0XHRpZiAocyAhPT0gMSkge1xuICBcdFx0XHRjdHgucmVzdG9yZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuICBcdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuICBcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuICBcdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcbiAgXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICBcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuICBcdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG4gIFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuICBcdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuICBcdFx0XHRjdHguc3Ryb2tlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuICBcdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG4gIFx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG4gIFx0XHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdHRoaXMuX2ZpcmVFdmVudChjbGlja2VkTGF5ZXIgPyBbY2xpY2tlZExheWVyXSA6IGZhbHNlLCBlKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG4gIFx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcbiAgXHR9LFxuXG5cbiAgXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG4gIFx0XHRpZiAobGF5ZXIpIHtcbiAgXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG4gIFx0XHRcdHRoaXMuX2hvdmVyZWRMYXllciA9IG51bGw7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICBcdFx0aWYgKHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGF5ZXIsIGNhbmRpZGF0ZUhvdmVyZWRMYXllcjtcblxuICBcdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcbiAgXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcbiAgXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gIFx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG4gIFx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG4gIFx0XHRcdGlmIChjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIpIHtcbiAgXHRcdFx0XHRhZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3JcbiAgXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcbiAgXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG4gIFx0XHR0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkID0gdHJ1ZTtcbiAgXHRcdHNldFRpbWVvdXQoYmluZChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcbiAgXHRcdH0sIHRoaXMpLCAzMik7XG4gIFx0fSxcblxuICBcdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcbiAgXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuICBcdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuICBcdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuICBcdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG4gIFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gQWxyZWFkeSBsYXN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2UgaWYgKG5leHQpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGZpcnN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuICBcdFx0XHQvLyBzaW5nbGUgZW50cnlcbiAgXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcbiAgXHRcdH1cblxuICBcdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuICBcdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gbnVsbDtcbiAgXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cbiAgXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG4gIFx0XHRpZiAoIW9yZGVyKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG4gIFx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cbiAgXHRcdGlmIChwcmV2KSB7XG4gIFx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBBbHJlYWR5IGZpcnN0XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdG5leHQucHJldiA9IHByZXY7XG4gIFx0XHR9IGVsc2UgaWYgKHByZXYpIHtcbiAgXHRcdFx0Ly8gVXBkYXRlIGxhc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG4gIFx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuICBcdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG4gIFx0XHR9XG5cbiAgXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG4gIFx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuICBcdFx0dGhpcy5fZHJhd0ZpcnN0LnByZXYgPSBvcmRlcjtcbiAgXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG4gIFx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuY2FudmFzID8gbmV3IENhbnZhcyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICAvKlxuICAgKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICAgKi9cblxuXG4gIHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdHRyeSB7XG4gIFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0XHR9O1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gIFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzcyNzlcbiAgXHR9XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG4gIFx0fTtcbiAgfSkoKTtcblxuXG4gIC8qXG4gICAqIEBjbGFzcyBTVkdcbiAgICpcbiAgICpcbiAgICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICovXG5cbiAgLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbiAgdmFyIHZtbE1peGluID0ge1xuXG4gIFx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSQxKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG4gIFx0fSxcblxuICBcdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG4gIFx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcbiAgXHR9LFxuXG4gIFx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG4gIFx0XHRhZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuICBcdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG4gIFx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuICBcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuICBcdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuICBcdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcbiAgXHR9LFxuXG4gIFx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICBcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG4gIFx0XHRyZW1vdmUoY29udGFpbmVyKTtcbiAgXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcbiAgXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG4gIFx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG4gIFx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuICBcdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuICBcdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcbiAgXHRcdFx0aWYgKCFzdHJva2UpIHtcbiAgXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcbiAgXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4JztcbiAgXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG4gIFx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IGlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcbiAgXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuICBcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICBcdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcbiAgXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG4gIFx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdGlmICghZmlsbCkge1xuICBcdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcbiAgXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG4gIFx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cbiAgXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuICBcdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG4gIFx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuICBcdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuICBcdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuICBcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fSxcblxuICBcdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR0b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuICAvKlxuICAgKiBAY2xhc3MgU1ZHXG4gICAqIEBpbmhlcml0cyBSZW5kZXJlclxuICAgKiBAYWthIEwuU1ZHXG4gICAqXG4gICAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gICAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gICAqXG4gICAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL3N2ZyksIFNWRyBpcyBub3RcbiAgICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAgICpcbiAgICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAgICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAgICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICAgKiB0aGlzIGNhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICAgKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gICAqXG4gICAqIGBgYGpzXG4gICAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gICAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gICAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICAgKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gICAqIGBgYFxuICAgKi9cblxuICB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuICBcdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG4gIFx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcbiAgXHRcdHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICBcdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG4gIFx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcbiAgXHR9LFxuXG4gIFx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICBcdFx0b2ZmKHRoaXMuX2NvbnRhaW5lcik7XG4gIFx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuICBcdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcbiAgXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuICBcdH0sXG5cbiAgXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuICBcdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG4gIFx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuICBcdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuICBcdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG4gIFx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG4gIFx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuICBcdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG4gIFx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuICBcdFx0c2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG4gIFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG4gIFx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuICBcdH0sXG5cbiAgXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuICBcdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cbiAgXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuICBcdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcbiAgXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgXHRcdFx0YWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuICBcdFx0XHRhZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG4gIFx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuICBcdH0sXG5cbiAgXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cbiAgXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0fSxcblxuICBcdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHJlbW92ZShsYXllci5fcGF0aCk7XG4gIFx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG4gIFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG4gIFx0fSxcblxuICBcdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdGxheWVyLl9wcm9qZWN0KCk7XG4gIFx0XHRsYXllci5fdXBkYXRlKCk7XG4gIFx0fSxcblxuICBcdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuICBcdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG4gIFx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuICBcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuICBcdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcbiAgXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuICBcdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcbiAgXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gIFx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcbiAgXHR9LFxuXG4gIFx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG4gIFx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcbiAgXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG4gIFx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcbiAgXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cbiAgXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG4gIFx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcbiAgXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcbiAgXHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcbiAgXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuICBcdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG4gIFx0fSxcblxuICBcdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcbiAgXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuICBcdH0sXG5cbiAgXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcbiAgXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgXHRcdHRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuICBcdH0sXG5cbiAgXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0dG9CYWNrKGxheWVyLl9wYXRoKTtcbiAgXHR9XG4gIH0pO1xuXG4gIGlmIChCcm93c2VyLnZtbCkge1xuICBcdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbiAgfVxuXG4gIC8vIEBuYW1lc3BhY2UgU1ZHXG4gIC8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuICAvLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG4gIFx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG4gIH1cblxuICBNYXAuaW5jbHVkZSh7XG4gIFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuICBcdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG4gIFx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcbiAgXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG4gIFx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuICBcdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuICBcdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG4gIFx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuICBcdFx0aWYgKCFyZW5kZXJlcikge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLmhhc0xheWVyKHJlbmRlcmVyKSkge1xuICBcdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmIChuYW1lID09PSAnb3ZlcmxheVBhbmUnIHx8IG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciByZW5kZXJlciA9IHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV07XG4gIFx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG4gIFx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcbiAgXHRcdH1cbiAgXHRcdHJldHVybiByZW5kZXJlcjtcbiAgXHR9LFxuXG4gIFx0X2NyZWF0ZVJlbmRlcmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2VcbiAgXHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cbiAgXHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuICBcdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuICBcdH1cbiAgfSk7XG5cbiAgLypcbiAgICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAgICovXG5cbiAgLypcbiAgICogQGNsYXNzIFJlY3RhbmdsZVxuICAgKiBAYWthIEwuUmVjdGFuZ2xlXG4gICAqIEBpbmhlcml0cyBQb2x5Z29uXG4gICAqXG4gICAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICAgKlxuICAgKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICAgKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gICAqXG4gICAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICAgKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKi9cblxuXG4gIHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG4gIFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuICBcdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG4gIFx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG4gIFx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcbiAgXHR9LFxuXG4gIFx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuICBcdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcbiAgXHRcdHJldHVybiBbXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcbiAgXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuICBcdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG4gIFx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuICBcdFx0XTtcbiAgXHR9XG4gIH0pO1xuXG5cbiAgLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuICBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFNWRy5jcmVhdGUgPSBjcmVhdGU7XG4gIFNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5cbiAgR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG4gIEdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbiAgR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG4gIEdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3JkcztcbiAgR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG4gIEdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG4gIEdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gICAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG4gIFx0Ly8gZHJhZ2dpbmcgdGhlIG1vdXNlIHdoaWxlIHByZXNzaW5nIHRoZSBzaGlmdCBrZXkuXG4gIFx0Ym94Wm9vbTogdHJ1ZVxuICB9KTtcblxuICB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG4gIFx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcbiAgXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuICBcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuICBcdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG4gIFx0fSxcblxuICBcdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG4gIFx0fSxcblxuICBcdF9kZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmUodGhpcy5fcGFuZSk7XG4gIFx0XHRkZWxldGUgdGhpcy5fcGFuZTtcbiAgXHR9LFxuXG4gIFx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG4gIFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZXNldFN0YXRlVGltZW91dCk7XG4gIFx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgXHRcdC8vIENsZWFyIHRoZSBkZWZlcnJlZCByZXNldFN0YXRlIGlmIGl0IGhhc24ndCBleGVjdXRlZCB5ZXQsIG90aGVyd2lzZSBpdFxuICBcdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuICBcdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcbiAgXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuICBcdFx0ZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgXHRcdGRpc2FibGVJbWFnZURyYWcoKTtcblxuICBcdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuICBcdFx0b24oZG9jdW1lbnQsIHtcbiAgXHRcdFx0Y29udGV4dG1lbnU6IHN0b3AsXG4gIFx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG4gIFx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcbiAgXHRcdFx0a2V5ZG93bjogdGhpcy5fb25LZXlEb3duXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cbiAgXHRcdFx0dGhpcy5fYm94ID0gY3JlYXRlJDEoJ2RpdicsICdsZWFmbGV0LXpvb20tYm94JywgdGhpcy5fY29udGFpbmVyKTtcbiAgXHRcdFx0YWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuICBcdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG4gIFx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG4gIFx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cbiAgXHRcdHNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cbiAgXHRcdHRoaXMuX2JveC5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xuICBcdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG4gIFx0fSxcblxuICBcdF9maW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuICBcdFx0XHRyZW1vdmUodGhpcy5fYm94KTtcbiAgXHRcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcbiAgXHRcdH1cblxuICBcdFx0ZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuICBcdFx0ZW5hYmxlSW1hZ2VEcmFnKCk7XG5cbiAgXHRcdG9mZihkb2N1bWVudCwge1xuICBcdFx0XHRjb250ZXh0bWVudTogc3RvcCxcbiAgXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcbiAgXHRcdFx0bW91c2V1cDogdGhpcy5fb25Nb3VzZVVwLFxuICBcdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG4gIFx0XHR0aGlzLl9maW5pc2goKTtcblxuICBcdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cbiAgXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuICBcdFx0Ly8gc3RpbGwgc2VlIGl0IGFzIFwibW92ZWRcIi5cbiAgXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG4gIFx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cbiAgXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuICBcdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSxcbiAgXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuICBcdFx0dGhpcy5fbWFwXG4gIFx0XHRcdC5maXRCb3VuZHMoYm91bmRzKVxuICBcdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gIFx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuICBcdFx0XHR0aGlzLl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSgpO1xuICBcdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuICAvLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG4gIC8qXG4gICAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuICBcdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGluIGJ5IGRvdWJsZSBjbGlja2luZyBvbiBpdCBhbmRcbiAgXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcbiAgXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAgXHQvLyAgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcbiAgXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcbiAgXHRcdCAgICB6b29tID0gZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gb2xkWm9vbSAtIGRlbHRhIDogb2xkWm9vbSArIGRlbHRhO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy9cbiAgLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4gIC8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbiAgLy8gYXMgZHJhZ2dpbmcgb3IgdG91Y2ggem9vbSAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIGBgYGpzXG4gIC8vIG1hcC5kb3VibGVDbGlja1pvb20uZGlzYWJsZSgpO1xuICAvLyBgYGBcbiAgLy9cbiAgLy8gQHByb3BlcnR5IGRvdWJsZUNsaWNrWm9vbTogSGFuZGxlclxuICAvLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuICAvKlxuICAgKiBMLkhhbmRsZXIuTWFwRHJhZyBpcyB1c2VkIHRvIG1ha2UgdGhlIG1hcCBkcmFnZ2FibGUgKHdpdGggcGFubmluZyBpbmVydGlhKSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cbiAgXHRkcmFnZ2luZzogdHJ1ZSxcblxuICBcdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG4gIFx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuICBcdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcbiAgXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuICBcdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcbiAgXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gIFx0aW5lcnRpYTogdHJ1ZSxcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuICBcdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cbiAgXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcblxuICBcdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuICBcdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG4gIFx0aW5lcnRpYU1heFNwZWVkOiBJbmZpbml0eSwgLy8gcHgvc1xuXG4gIFx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcbiAgXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cbiAgXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xuICBcdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG4gIFx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuICBcdC8vIG9mIHRoZSB3b3JsZCBhbmQgc2VhbWxlc3NseSBqdW1wcyB0byB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgYWxsIG92ZXJsYXlzXG4gIFx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuICBcdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG4gIFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHNWaXNjb3NpdHk6IE51bWJlciA9IDAuMFxuICBcdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG4gIFx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcbiAgXHQvLyB1c2VyIHRvIGRyYWcgb3V0c2lkZSB0aGUgYm91bmRzIGF0IG5vcm1hbCBzcGVlZCwgaGlnaGVyIHZhbHVlcyB3aWxsXG4gIFx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcbiAgXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cbiAgXHRtYXhCb3VuZHNWaXNjb3NpdHk6IDAuMFxuICB9KTtcblxuICB2YXIgRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcbiAgXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICBcdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG4gIFx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG4gIFx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG4gIFx0XHRcdH0sIHRoaXMpO1xuXG4gIFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcbiAgXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcbiAgXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcbiAgXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG4gIFx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHRhZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcbiAgXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcbiAgXHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiJyk7XG4gIFx0XHRyZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuICBcdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcbiAgXHR9LFxuXG4gIFx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcbiAgXHR9LFxuXG4gIFx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuICBcdH0sXG5cbiAgXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpO1xuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyAmJiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpIHtcbiAgXHRcdFx0dmFyIGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cbiAgXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSB0b0JvdW5kcyhcbiAgXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuICBcdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcbiAgXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG4gIFx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0bWFwXG4gIFx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcbiAgXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gIFx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcbiAgXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuICBcdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl9tYXBcbiAgXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG4gIFx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcbiAgXHR9LFxuXG4gIFx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuICBcdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG4gIFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuICBcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuICBcdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cbiAgXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG4gIFx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcbiAgXHR9LFxuXG4gIFx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcbiAgXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cbiAgXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuICBcdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuICBcdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuICBcdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG4gIFx0fSxcblxuICBcdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cbiAgXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcbiAgXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcbiAgXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcbiAgXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcbiAgXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuICBcdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG4gIFx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG4gIFx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcbiAgXHR9LFxuXG4gIFx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG4gIFx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG4gIFx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG4gIFx0XHRpZiAobm9JbmVydGlhKSB7XG4gIFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuICBcdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuICBcdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuICBcdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuICBcdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuICBcdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cbiAgXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG4gIFx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuICBcdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG4gIFx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG4gIFx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG4gIFx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG4gIFx0XHRcdFx0cmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG4gIFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcbiAgXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG4gIFx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAgLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbiAgTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cbiAgLypcbiAgICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuICBNYXAubWVyZ2VPcHRpb25zKHtcbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuICBcdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG4gIFx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG4gIFx0a2V5Ym9hcmQ6IHRydWUsXG5cbiAgXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG4gIFx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG4gIFx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbiAgfSk7XG5cbiAgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG4gIFx0a2V5Q29kZXM6IHtcbiAgXHRcdGxlZnQ6ICAgIFszN10sXG4gIFx0XHRyaWdodDogICBbMzldLFxuICBcdFx0ZG93bjogICAgWzQwXSxcbiAgXHRcdHVwOiAgICAgIFszOF0sXG4gIFx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuICBcdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuICBcdH0sXG5cbiAgXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gIFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cbiAgXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuICBcdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG4gIFx0fSxcblxuICBcdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cbiAgXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuICBcdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG4gIFx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcbiAgXHRcdH1cblxuICBcdFx0b24oY29udGFpbmVyLCB7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuICBcdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG4gIFx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cbiAgXHRcdH0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLl9tYXAub24oe1xuICBcdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG4gIFx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG4gIFx0XHR9LCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuICBcdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuICBcdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG4gIFx0XHR9LCB0aGlzKTtcblxuICBcdFx0dGhpcy5fbWFwLm9mZih7XG4gIFx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcbiAgXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3NcbiAgXHRcdH0sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gIFx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIFx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuICBcdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuICBcdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuICBcdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG4gIFx0fSxcblxuICBcdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuICBcdH0sXG5cbiAgXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gIFx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuICBcdH0sXG5cbiAgXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuICBcdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuICBcdFx0fVxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBcdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG4gIFx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG4gIFx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuICBcdFx0ICAgIGksIGxlbjtcblxuICBcdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcbiAgXHRcdH1cbiAgXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuICBcdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcbiAgXHRcdCAgICBvZmZzZXQ7XG5cbiAgXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuICBcdFx0XHRpZiAoIW1hcC5fcGFuQW5pbSB8fCAhbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7XG4gIFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuICBcdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG4gIFx0XHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuICBcdFx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcbiAgXHRcdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG4gIFx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG4gIFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCAmJiBtYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkVzY2FwZUtleSkge1xuICBcdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHN0b3AoZSk7XG4gIFx0fVxuICB9KTtcblxuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAc2VjdGlvbiBIYW5kbGVyc1xuICAvLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbiAgLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICAgKi9cblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG4gIFx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcbiAgXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG4gIFx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG4gIFx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcbiAgXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuICBcdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuICBcdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuICBcdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcbiAgXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG4gIFx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuICBcdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuICBcdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG4gIH0pO1xuXG4gIHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuICBcdFx0dGhpcy5fZGVsdGEgPSAwO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHR2YXIgZGVsdGEgPSBnZXRXaGVlbERlbHRhKGUpO1xuXG4gIFx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuICBcdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG4gIFx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cbiAgXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG4gIFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cbiAgXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIFx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG4gIFx0XHRzdG9wKGUpO1xuICBcdH0sXG5cbiAgXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG4gIFx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG4gIFx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cbiAgXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG4gIFx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcbiAgXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcbiAgXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG4gIFx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG4gIFx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG4gIFx0XHR0aGlzLl9kZWx0YSA9IDA7XG4gIFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG4gIFx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuICAvLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcblxuICAvKlxuICAgKiBMLk1hcC5UYXBIb2xkIGlzIHVzZWQgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCBvbiBsb25nIGhvbGQsXG4gICAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAgICovXG5cbiAgdmFyIHRhcEhvbGREZWxheSA9IDYwMDtcblxuICAvLyBAbmFtZXNwYWNlIE1hcFxuICAvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG4gIE1hcC5tZXJnZU9wdGlvbnMoe1xuICBcdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcbiAgXHQvLyBAb3B0aW9uIHRhcEhvbGQ6IEJvb2xlYW5cbiAgXHQvLyBFbmFibGVzIHNpbXVsYXRpb24gb2YgYGNvbnRleHRtZW51YCBldmVudCwgZGVmYXVsdCBpcyBgdHJ1ZWAgZm9yIG1vYmlsZSBTYWZhcmkuXG4gIFx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuICBcdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuICBcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG4gIFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG4gIFx0dGFwVG9sZXJhbmNlOiAxNVxuICB9KTtcblxuICB2YXIgVGFwSG9sZCA9IEhhbmRsZXIuZXh0ZW5kKHtcbiAgXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0b24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICBcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcbiAgXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG4gIFx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICBcdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGJpbmQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLl9jYW5jZWwoKTtcbiAgXHRcdFx0aWYgKCF0aGlzLl9pc1RhcFZhbGlkKCkpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fY2FuY2VsQ2xpY2tQcmV2ZW50KTtcbiAgXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG4gIFx0XHR9LCB0aGlzKSwgdGFwSG9sZERlbGF5KTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdF9jYW5jZWxDbGlja1ByZXZlbnQ6IGZ1bmN0aW9uIGNhbmNlbENsaWNrUHJldmVudCgpIHtcbiAgXHRcdG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBjYW5jZWxDbGlja1ByZXZlbnQpO1xuICBcdH0sXG5cbiAgXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgY29udGV4dG1lbnUnLCB0aGlzLl9jYW5jZWwsIHRoaXMpO1xuICBcdFx0b2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcbiAgXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcbiAgXHR9LFxuXG4gIFx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuICBcdH0sXG5cbiAgXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIHtcbiAgXHRcdFx0YnViYmxlczogdHJ1ZSxcbiAgXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcbiAgXHRcdFx0dmlldzogd2luZG93LFxuICBcdFx0XHQvLyBkZXRhaWw6IDEsXG4gIFx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgXHRcdFx0c2NyZWVuWTogZS5zY3JlZW5ZLFxuICBcdFx0XHRjbGllbnRYOiBlLmNsaWVudFgsXG4gIFx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcbiAgXHRcdFx0Ly8gYnV0dG9uOiAyLFxuICBcdFx0XHQvLyBidXR0b25zOiAyXG4gIFx0XHR9KTtcblxuICBcdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cbiAgXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICBcdH1cbiAgfSk7XG5cbiAgLy8gQHNlY3Rpb24gSGFuZGxlcnNcbiAgLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbiAgLy8gTG9uZyB0YXAgaGFuZGxlciB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50ICh1c2VmdWwgaW4gbW9iaWxlIFNhZmFyaSkuXG4gIE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXBIb2xkJywgVGFwSG9sZCk7XG5cbiAgLypcbiAgICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gICAqL1xuXG4gIC8vIEBuYW1lc3BhY2UgTWFwXG4gIC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbiAgTWFwLm1lcmdlT3B0aW9ucyh7XG4gIFx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuICBcdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcbiAgXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuICBcdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG4gIFx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcbiAgXHQvLyBicm93c2Vycy5cbiAgXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cbiAgXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcbiAgXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cbiAgXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG4gIFx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG4gIFx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG4gIFx0XHRvbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcbiAgXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICBcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuICBcdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cbiAgXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG4gIFx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcbiAgXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG4gIFx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuICBcdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuICBcdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcbiAgXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG4gIFx0XHRtYXAuX3N0b3AoKTtcblxuICBcdFx0b24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cbiAgXHRcdHByZXZlbnREZWZhdWx0KGUpO1xuICBcdH0sXG5cbiAgXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gIFx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG4gIFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuICBcdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG4gIFx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcbiAgXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG4gIFx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuICBcdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuICBcdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuICBcdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcbiAgXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcbiAgXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG4gIFx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuICBcdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuICBcdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcbiAgXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSwgZmFsc2UpO1xuICBcdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cbiAgXHRcdHZhciBtb3ZlRm4gPSBiaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG4gIFx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuICBcdFx0cHJldmVudERlZmF1bHQoZSk7XG4gIFx0fSxcblxuICBcdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG4gIFx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG4gIFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG4gIFx0XHRvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG4gIFx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuICBcdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcbiAgXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIC8vIEBzZWN0aW9uIEhhbmRsZXJzXG4gIC8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbiAgLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuICBNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcblxuICBNYXAuQm94Wm9vbSA9IEJveFpvb207XG4gIE1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG4gIE1hcC5EcmFnID0gRHJhZztcbiAgTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gIE1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG4gIE1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbiAgTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuICBleHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcbiAgZXhwb3J0cy5Ccm93c2VyID0gQnJvd3NlcjtcbiAgZXhwb3J0cy5DUlMgPSBDUlM7XG4gIGV4cG9ydHMuQ2FudmFzID0gQ2FudmFzO1xuICBleHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiAgZXhwb3J0cy5DaXJjbGVNYXJrZXIgPSBDaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgZXhwb3J0cy5Db250cm9sID0gQ29udHJvbDtcbiAgZXhwb3J0cy5EaXZJY29uID0gRGl2SWNvbjtcbiAgZXhwb3J0cy5EaXZPdmVybGF5ID0gRGl2T3ZlcmxheTtcbiAgZXhwb3J0cy5Eb21FdmVudCA9IERvbUV2ZW50O1xuICBleHBvcnRzLkRvbVV0aWwgPSBEb21VdGlsO1xuICBleHBvcnRzLkRyYWdnYWJsZSA9IERyYWdnYWJsZTtcbiAgZXhwb3J0cy5FdmVudGVkID0gRXZlbnRlZDtcbiAgZXhwb3J0cy5GZWF0dXJlR3JvdXAgPSBGZWF0dXJlR3JvdXA7XG4gIGV4cG9ydHMuR2VvSlNPTiA9IEdlb0pTT047XG4gIGV4cG9ydHMuR3JpZExheWVyID0gR3JpZExheWVyO1xuICBleHBvcnRzLkhhbmRsZXIgPSBIYW5kbGVyO1xuICBleHBvcnRzLkljb24gPSBJY29uO1xuICBleHBvcnRzLkltYWdlT3ZlcmxheSA9IEltYWdlT3ZlcmxheTtcbiAgZXhwb3J0cy5MYXRMbmcgPSBMYXRMbmc7XG4gIGV4cG9ydHMuTGF0TG5nQm91bmRzID0gTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLkxheWVyID0gTGF5ZXI7XG4gIGV4cG9ydHMuTGF5ZXJHcm91cCA9IExheWVyR3JvdXA7XG4gIGV4cG9ydHMuTGluZVV0aWwgPSBMaW5lVXRpbDtcbiAgZXhwb3J0cy5NYXAgPSBNYXA7XG4gIGV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuICBleHBvcnRzLk1peGluID0gTWl4aW47XG4gIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gIGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiAgZXhwb3J0cy5Qb2x5VXRpbCA9IFBvbHlVdGlsO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLlBvbHlsaW5lID0gUG9seWxpbmU7XG4gIGV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcbiAgZXhwb3J0cy5Qb3NBbmltYXRpb24gPSBQb3NBbmltYXRpb247XG4gIGV4cG9ydHMuUHJvamVjdGlvbiA9IGluZGV4O1xuICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICBleHBvcnRzLlNWRyA9IFNWRztcbiAgZXhwb3J0cy5TVkdPdmVybGF5ID0gU1ZHT3ZlcmxheTtcbiAgZXhwb3J0cy5UaWxlTGF5ZXIgPSBUaWxlTGF5ZXI7XG4gIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG4gIGV4cG9ydHMuVHJhbnNmb3JtYXRpb24gPSBUcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy5VdGlsID0gVXRpbDtcbiAgZXhwb3J0cy5WaWRlb092ZXJsYXkgPSBWaWRlb092ZXJsYXk7XG4gIGV4cG9ydHMuYmluZCA9IGJpbmQ7XG4gIGV4cG9ydHMuYm91bmRzID0gdG9Cb3VuZHM7XG4gIGV4cG9ydHMuY2FudmFzID0gY2FudmFzO1xuICBleHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcbiAgZXhwb3J0cy5jaXJjbGVNYXJrZXIgPSBjaXJjbGVNYXJrZXI7XG4gIGV4cG9ydHMuY29udHJvbCA9IGNvbnRyb2w7XG4gIGV4cG9ydHMuZGl2SWNvbiA9IGRpdkljb247XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmZlYXR1cmVHcm91cCA9IGZlYXR1cmVHcm91cDtcbiAgZXhwb3J0cy5nZW9KU09OID0gZ2VvSlNPTjtcbiAgZXhwb3J0cy5nZW9Kc29uID0gZ2VvSnNvbjtcbiAgZXhwb3J0cy5ncmlkTGF5ZXIgPSBncmlkTGF5ZXI7XG4gIGV4cG9ydHMuaWNvbiA9IGljb247XG4gIGV4cG9ydHMuaW1hZ2VPdmVybGF5ID0gaW1hZ2VPdmVybGF5O1xuICBleHBvcnRzLmxhdExuZyA9IHRvTGF0TG5nO1xuICBleHBvcnRzLmxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzO1xuICBleHBvcnRzLmxheWVyR3JvdXAgPSBsYXllckdyb3VwO1xuICBleHBvcnRzLm1hcCA9IGNyZWF0ZU1hcDtcbiAgZXhwb3J0cy5tYXJrZXIgPSBtYXJrZXI7XG4gIGV4cG9ydHMucG9pbnQgPSB0b1BvaW50O1xuICBleHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xuICBleHBvcnRzLnBvbHlsaW5lID0gcG9seWxpbmU7XG4gIGV4cG9ydHMucG9wdXAgPSBwb3B1cDtcbiAgZXhwb3J0cy5yZWN0YW5nbGUgPSByZWN0YW5nbGU7XG4gIGV4cG9ydHMuc2V0T3B0aW9ucyA9IHNldE9wdGlvbnM7XG4gIGV4cG9ydHMuc3RhbXAgPSBzdGFtcDtcbiAgZXhwb3J0cy5zdmcgPSBzdmc7XG4gIGV4cG9ydHMuc3ZnT3ZlcmxheSA9IHN2Z092ZXJsYXk7XG4gIGV4cG9ydHMudGlsZUxheWVyID0gdGlsZUxheWVyO1xuICBleHBvcnRzLnRvb2x0aXAgPSB0b29sdGlwO1xuICBleHBvcnRzLnRyYW5zZm9ybWF0aW9uID0gdG9UcmFuc2Zvcm1hdGlvbjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy52aWRlb092ZXJsYXkgPSB2aWRlb092ZXJsYXk7XG5cbiAgdmFyIG9sZEwgPSB3aW5kb3cuTDtcbiAgZXhwb3J0cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIFx0d2luZG93LkwgPSBvbGRMO1xuICBcdHJldHVybiB0aGlzO1xuICB9XG4gIC8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxuICB3aW5kb3cuTCA9IGV4cG9ydHM7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYWZsZXQtc3JjLmpzLm1hcFxuIiwiaW1wb3J0IHsgVGVycmFEcmF3IH0gZnJvbSBcIi4uL3NyYy90ZXJyYS1kcmF3XCI7XG5cbmV4cG9ydCBjb25zdCBhZGRNb2RlQ2hhbmdlSGFuZGxlciA9IChcbiAgZHJhdzogVGVycmFEcmF3LFxuICBjdXJyZW50U2VsZWN0ZWQ6IHsgYnV0dG9uOiB1bmRlZmluZWQgfCBIVE1MQnV0dG9uRWxlbWVudDsgbW9kZTogc3RyaW5nIH1cbikgPT4ge1xuICBbXCJzZWxlY3RcIiwgXCJwb2ludFwiLCBcImxpbmVzdHJpbmdcIiwgXCJwb2x5Z29uXCIsIFwiZnJlZWhhbmRcIiwgXCJjaXJjbGVcIl0uZm9yRWFjaChcbiAgICAobW9kZSkgPT4ge1xuICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGUpIGFzIEhUTUxCdXR0b25FbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBjdXJyZW50U2VsZWN0ZWQubW9kZSA9IG1vZGU7XG4gICAgICAgICAgZHJhdy5jaGFuZ2VNb2RlKGN1cnJlbnRTZWxlY3RlZC5tb2RlKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0ZWQuYnV0dG9uKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0ZWQuYnV0dG9uLnN0eWxlLmNvbG9yID0gXCI1NjU2NTZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFNlbGVjdGVkLmJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgbW9kZVxuICAgICAgICAgICkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgICAgICAgY3VycmVudFNlbGVjdGVkLmJ1dHRvbi5zdHlsZS5jb2xvciA9IFwiIzI3Y2NmZlwiO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn07XG4iLCJpbXBvcnQge1xuICAgIFRlcnJhRHJhd0NhbGxiYWNrcyxcbiAgICBUZXJyYURyYXdBZGFwdGVyLFxuICAgIFRlcnJhRHJhd01vZGVSZWdpc3RlckNvbmZpZyxcbiAgICBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyxcbiAgICBUZXJyYURyYXdDaGFuZ2VzLFxuICAgIFRlcnJhRHJhd01vdXNlRXZlbnQsXG4gICAgU0VMRUNUX1BST1BFUlRJRVMsXG59IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IEdlb0pzb25PYmplY3QgfSBmcm9tIFwiZ2VvanNvblwiO1xuXG5pbXBvcnQgeyBsaW1pdFByZWNpc2lvbiB9IGZyb20gXCIuLi9nZW9tZXRyeS9saW1pdC1kZWNpbWFsLXByZWNpc2lvblwiO1xuXG5leHBvcnQgY2xhc3MgVGVycmFEcmF3R29vZ2xlTWFwc0FkYXB0ZXIgaW1wbGVtZW50cyBUZXJyYURyYXdBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICAgICAgbGliOiB0eXBlb2YgZ29vZ2xlLm1hcHM7XG4gICAgICAgIG1hcDogZ29vZ2xlLm1hcHMuTWFwO1xuICAgICAgICBjb29yZGluYXRlUHJlY2lzaW9uPzogbnVtYmVyO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5fbGliID0gY29uZmlnLmxpYjtcbiAgICAgICAgdGhpcy5fbWFwID0gY29uZmlnLm1hcDtcbiAgICAgICAgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiA9XG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLmNvb3JkaW5hdGVQcmVjaXNpb24gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICA/IGNvbmZpZy5jb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgOiA5O1xuXG4gICAgICAgIHRoaXMuZ2V0TWFwQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXREaXYoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnByb2plY3QgPSAobG5nLCBsYXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcblxuICAgICAgICAgICAgaWYgKGJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCBib3VuZHNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcnRoV2VzdCA9IG5ldyB0aGlzLl9saWIuTGF0TG5nKFxuICAgICAgICAgICAgICAgIGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sYXQoKSxcbiAgICAgICAgICAgICAgICBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLl9tYXAuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgcHJvamVjdGlvblwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvamVjdGVkTm9ydGhXZXN0ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Qb2ludChub3J0aFdlc3QpO1xuICAgICAgICAgICAgaWYgKHByb2plY3RlZE5vcnRoV2VzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgcHJvamVjdGVkTm9ydGhXZXN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWQgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb1BvaW50KHsgbG5nLCBsYXQgfSk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCBwcm9qZWN0ZWQgbG5nIGxhdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB6b29tXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKChwcm9qZWN0ZWQueCAtIHByb2plY3RlZE5vcnRoV2VzdC54KSAqIHNjYWxlKSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLmZsb29yKChwcm9qZWN0ZWQueSAtIHByb2plY3RlZE5vcnRoV2VzdC55KSAqIHNjYWxlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bnByb2plY3QgPSAoeCwgeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuX21hcC5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCBwcm9qZWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9tYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBpZiAoYm91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IGJvdW5kc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb1BvaW50KGJvdW5kcy5nZXROb3J0aEVhc3QoKSk7XG4gICAgICAgICAgICBpZiAodG9wUmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHRvcFJpZ2h0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Qb2ludChib3VuZHMuZ2V0U291dGhXZXN0KCkpO1xuICAgICAgICAgICAgaWYgKGJvdHRvbUxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IGJvdHRvbUxlZnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInpvb20gZ2V0IGJvdW5kc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tKTtcblxuICAgICAgICAgICAgY29uc3Qgd29ybGRQb2ludCA9IG5ldyBnb29nbGUubWFwcy5Qb2ludChcbiAgICAgICAgICAgICAgICB4IC8gc2NhbGUgKyBib3R0b21MZWZ0LngsXG4gICAgICAgICAgICAgICAgeSAvIHNjYWxlICsgdG9wUmlnaHQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGxuZ0xhdCA9IHByb2plY3Rpb24uZnJvbVBvaW50VG9MYXRMbmcod29ybGRQb2ludCk7XG5cbiAgICAgICAgICAgIGlmIChsbmdMYXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6b29tIGdldCBib3VuZHNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IGxuZzogbG5nTGF0LmxuZygpLCBsYXQ6IGxuZ0xhdC5sYXQoKSB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yID0gKGN1cnNvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gdGhpcy5fY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yU3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvclN0eWxlU2hlZXQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yU3R5bGVTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gXCJ1bnNldFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgY2FjaGUgdGhlc2UgaW5kaXZpZHVhbGx5IHBlciBjdXJzb3JcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuZ2V0TWFwQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICAgICAgc3R5bGUudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGAjJHtkaXYuaWR9IFthcmlhLWxhYmVsPVwiTWFwXCJdYDtcbiAgICAgICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBgJHtzZWxlY3Rvcn0geyBjdXJzb3I6ICR7Y3Vyc29yfSAhaW1wb3J0YW50OyB9YDtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvclN0eWxlU2hlZXQgPSBzdHlsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hlbGRLZXlzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICBwcml2YXRlIF9jdXJzb3I6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9jdXJzb3JTdHlsZVNoZWV0OiBIVE1MU3R5bGVFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX2Nvb3JkaW5hdGVQcmVjaXNpb246IG51bWJlcjtcbiAgICBwcml2YXRlIF9saWI6IHR5cGVvZiBnb29nbGUubWFwcztcbiAgICBwcml2YXRlIF9tYXA6IGdvb2dsZS5tYXBzLk1hcDtcbiAgICBwcml2YXRlIF9vbk1vdXNlTW92ZUxpc3RlbmVyOiBnb29nbGUubWFwcy5NYXBzRXZlbnRMaXN0ZW5lciB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbk1vdXNlTW92ZUNhbGxiYWNrOlxuICAgICAgICB8ICgoXG4gICAgICAgICAgICBldmVudDogZ29vZ2xlLm1hcHMuTWFwTW91c2VFdmVudCAmIHtcbiAgICAgICAgICAgICAgICBkb21FdmVudDogTW91c2VFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkNsaWNrTGlzdGVuZXI6IGdvb2dsZS5tYXBzLk1hcHNFdmVudExpc3RlbmVyIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX29uUmlnaHRDbGlja0xpc3RlbmVyOiBnb29nbGUubWFwcy5NYXBzRXZlbnRMaXN0ZW5lciB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkNsaWNrQ2FsbGJhY2s6XG4gICAgICAgIHwgKChcbiAgICAgICAgICAgIGV2ZW50OiBnb29nbGUubWFwcy5NYXBNb3VzZUV2ZW50ICYge1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50OiBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICApID0+IHZvaWQpXG4gICAgICAgIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX29uS2V5VXBMaXN0ZW5lcjogYW55O1xuICAgIHByaXZhdGUgX29uRHJhZ1N0YXJ0TGlzdGVuZXI6ICgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX29uRHJhZ0xpc3RlbmVyOiAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkRyYWdFbmRMaXN0ZW5lcjogKChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfbGF5ZXJzID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgZ2V0TWFwQ29udGFpbmVyOiAoKSA9PiBIVE1MRWxlbWVudDtcblxuICAgIHB1YmxpYyB1bnByb2plY3Q6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4geyBsbmc6IG51bWJlcjsgbGF0OiBudW1iZXIgfTtcbiAgICBwdWJsaWMgcHJvamVjdDogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnW1wicHJvamVjdFwiXTtcbiAgICBwdWJsaWMgc2V0Q3Vyc29yOiBUZXJyYURyYXdNb2RlUmVnaXN0ZXJDb25maWdbXCJzZXRDdXJzb3JcIl07XG5cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjc5MDUyNjgvMTM2MzQ4NFxuICAgIHByaXZhdGUgY2lyY2xlUGF0aChjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiTSBcIiArXG4gICAgICAgICAgICBjeCArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBjeSArXG4gICAgICAgICAgICBcIiBtIC1cIiArXG4gICAgICAgICAgICByICtcbiAgICAgICAgICAgIFwiLCAwIGEgXCIgK1xuICAgICAgICAgICAgciArXG4gICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICByICtcbiAgICAgICAgICAgIFwiIDAgMSwwIFwiICtcbiAgICAgICAgICAgIHIgKiAyICtcbiAgICAgICAgICAgIFwiLDAgYSBcIiArXG4gICAgICAgICAgICByICtcbiAgICAgICAgICAgIFwiLFwiICtcbiAgICAgICAgICAgIHIgK1xuICAgICAgICAgICAgXCIgMCAxLDAgLVwiICtcbiAgICAgICAgICAgIHIgKiAyICtcbiAgICAgICAgICAgIFwiLDBcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyKGNhbGxiYWNrczogVGVycmFEcmF3Q2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuX29uQ2xpY2tDYWxsYmFjayA9IChcbiAgICAgICAgICAgIGV2ZW50OiBnb29nbGUubWFwcy5NYXBNb3VzZUV2ZW50ICYge1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50OiBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQubGF0TG5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tzLm9uQ2xpY2soe1xuICAgICAgICAgICAgICAgIGxuZzogbGltaXRQcmVjaXNpb24oZXZlbnQubGF0TG5nLmxuZygpLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICBsYXQ6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxhdExuZy5sYXQoKSwgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWDogZXZlbnQuZG9tRXZlbnQuY2xpZW50WCAtIHRoaXMuZ2V0TWFwQ29udGFpbmVyKCkub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJZOiBldmVudC5kb21FdmVudC5jbGllbnRZIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5kb21FdmVudC5idXR0b24gPT09IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICBoZWxkS2V5czogWy4uLnRoaXMuX2hlbGRLZXlzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vbkNsaWNrTGlzdGVuZXIgPSB0aGlzLl9tYXAuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrQ2FsbGJhY2tcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9vblJpZ2h0Q2xpY2tMaXN0ZW5lciA9IHRoaXMuX21hcC5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwicmlnaHRjbGlja1wiLFxuICAgICAgICAgICAgdGhpcy5fb25DbGlja0NhbGxiYWNrXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVDYWxsYmFjayA9IChcbiAgICAgICAgICAgIGV2ZW50OiBnb29nbGUubWFwcy5NYXBNb3VzZUV2ZW50ICYge1xuICAgICAgICAgICAgICAgIGRvbUV2ZW50OiBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQubGF0TG5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tzLm9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgICAgICBsbmc6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxhdExuZy5sbmcoKSwgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgbGF0OiBsaW1pdFByZWNpc2lvbihldmVudC5sYXRMbmcubGF0KCksIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6IGV2ZW50LmRvbUV2ZW50LmNsaWVudFggLSB0aGlzLmdldE1hcENvbnRhaW5lcigpLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWTogZXZlbnQuZG9tRXZlbnQuY2xpZW50WSAtIHRoaXMuZ2V0TWFwQ29udGFpbmVyKCkub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjogZXZlbnQuZG9tRXZlbnQuYnV0dG9uID09PSAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgaGVsZEtleXM6IFsuLi50aGlzLl9oZWxkS2V5c10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMuX21hcC5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZUNhbGxiYWNrXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fb25LZXlVcExpc3RlbmVyID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFja3Mub25LZXlVcCh7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE1hcENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9vbktleVVwTGlzdGVuZXIpO1xuXG4gICAgICAgIGxldCBkcmFnU3RhdGU6IFwibm90LWRyYWdnaW5nXCIgfCBcInByZS1kcmFnZ2luZ1wiIHwgXCJkcmFnZ2luZ1wiID1cbiAgICAgICAgICAgIFwibm90LWRyYWdnaW5nXCI7XG5cbiAgICAgICAgdGhpcy5fb25EcmFnU3RhcnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZHJhZ1N0YXRlID0gXCJwcmUtZHJhZ2dpbmdcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldE1hcENvbnRhaW5lcigpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uRHJhZ1N0YXJ0TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uRHJhZ0xpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICAgICAgICB9IGFzIEwuUG9pbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgbG5nLCBsYXQgfSA9IHRoaXMudW5wcm9qZWN0KHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgICAgICAgICBjb25zdCBkcmF3RXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgbG5nOiBsaW1pdFByZWNpc2lvbihsbmcsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGxhdDogbGltaXRQcmVjaXNpb24obGF0LCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXJYOiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWTogZXZlbnQuY2xpZW50WSAtIGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5idXR0b24gPT09IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICBoZWxkS2V5czogWy4uLnRoaXMuX2hlbGRLZXlzXSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkcmFnU3RhdGUgPT09IFwicHJlLWRyYWdnaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkcmFnU3RhdGUgPSBcImRyYWdnaW5nXCI7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRHJhZ1N0YXJ0KGRyYXdFdmVudCwgKGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLnNldE9wdGlvbnMoeyBkcmFnZ2FibGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnU3RhdGUgPT09IFwiZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkRyYWcoZHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkRyYWdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25EcmFnRW5kTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChkcmFnU3RhdGUgPT09IFwiZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIH0gYXMgTC5Qb2ludDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbG5nLCBsYXQgfSA9IHRoaXMudW5wcm9qZWN0KHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRHJhZ0VuZChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG5nOiBsaW1pdFByZWNpc2lvbihsbmcsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0OiBsaW1pdFByZWNpc2lvbihsYXQsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyWDogZXZlbnQuY2xpZW50WCAtIGNvbnRhaW5lci5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyWTogZXZlbnQuY2xpZW50WSAtIGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IGV2ZW50LmJ1dHRvbiA9PT0gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVsZEtleXM6IFsuLi50aGlzLl9oZWxkS2V5c10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlbmFibGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuc2V0T3B0aW9ucyh7IGRyYWdnYWJsZTogZW5hYmxlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYWdTdGF0ZSA9IFwibm90LWRyYWdnaW5nXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uRHJhZ0VuZExpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fb25DbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrTGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29uUmlnaHRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9vblJpZ2h0Q2xpY2tMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX29uUmlnaHRDbGlja0xpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vbk1vdXNlTW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVMaXN0ZW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VNb3ZlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25LZXlVcExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldE1hcENvbnRhaW5lcigpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJrZXl1cFwiLFxuICAgICAgICAgICAgICAgIHRoaXMuX29uS2V5VXBMaXN0ZW5lclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX29uS2V5VXBMaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihcbiAgICAgICAgY2hhbmdlczogVGVycmFEcmF3Q2hhbmdlcyxcbiAgICAgICAgc3R5bGluZzogeyBbbW9kZTogc3RyaW5nXTogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcgfVxuICAgICkge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLmRlbGV0ZWRJZHMuZm9yRWFjaCgoZGVsZXRlZElkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZVRvRGVsZXRlID0gdGhpcy5fbWFwLmRhdGEuZ2V0RmVhdHVyZUJ5SWQoZGVsZXRlZElkKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlVG9EZWxldGUgJiYgdGhpcy5fbWFwLmRhdGEucmVtb3ZlKGZlYXR1cmVUb0RlbGV0ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2hhbmdlcy51cGRhdGVkLmZvckVhY2goKHVwZGF0ZWRGZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkRmVhdHVyZSB8fCAhdXBkYXRlZEZlYXR1cmUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBpcyBub3QgdmFsaWRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZVRvVXBkYXRlID0gdGhpcy5fbWFwLmRhdGEuZ2V0RmVhdHVyZUJ5SWQoXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRGZWF0dXJlLmlkXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZVRvVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZlYXR1cmUgY291bGQgbm90IGJlIGZvdW5kIGJ5IEdvb2dsZSBNYXBzIEFQSVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGtleXNcbiAgICAgICAgICAgICAgICBmZWF0dXJlVG9VcGRhdGUuZm9yRWFjaFByb3BlcnR5KChwcm9wZXJ0eSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlVG9VcGRhdGUuc2V0UHJvcGVydHkobmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwga2V5c1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHVwZGF0ZWRGZWF0dXJlLnByb3BlcnRpZXMpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVUb1VwZGF0ZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEZlYXR1cmUucHJvcGVydGllc1twcm9wZXJ0eV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodXBkYXRlZEZlYXR1cmUuZ2VvbWV0cnkudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IHVwZGF0ZWRGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlVG9VcGRhdGUuc2V0R2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGdvb2dsZS5tYXBzLkRhdGEuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoY29vcmRpbmF0ZXNbMV0sIGNvb3JkaW5hdGVzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB1cGRhdGVkRmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobGF0TG5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVRvVXBkYXRlLnNldEdlb21ldHJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBnb29nbGUubWFwcy5EYXRhLkxpbmVTdHJpbmcocGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB1cGRhdGVkRmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXNbaV1bal1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlc1tpXVtqXVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobGF0TG5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVRvVXBkYXRlLnNldEdlb21ldHJ5KG5ldyBnb29nbGUubWFwcy5EYXRhLlBvbHlnb24ocGF0aHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGZlYXR1cmVzXG4gICAgICAgICAgICBjaGFuZ2VzLmNyZWF0ZWQuZm9yRWFjaCgoY3JlYXRlZEZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZGF0YS5hZGRHZW9Kc29uKGNyZWF0ZWRGZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xpY2tpbmcgb24gZGF0YSBnZW9tZXRyaWVzIHRyaWdnZXJzXG4gICAgICAgICAgICAvLyBzd2FsbG93cyB0aGUgbWFwIG9uY2xpY2sgZXZlbnQsXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGZvcndhcmQgaXQgdG8gdGhlIGNsaWNrIGNhbGxiYWNrIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuX21hcC5kYXRhLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBnb29nbGUubWFwcy5NYXBNb3VzZUV2ZW50ICYge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQ6IE1vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DbGlja0NhbGxiYWNrICYmIHRoaXMuX29uQ2xpY2tDYWxsYmFjayhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5fbWFwLmRhdGEuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBnb29nbGUubWFwcy5NYXBNb3VzZUV2ZW50ICYge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQ6IE1vdXNlRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVDYWxsYmFjayAmJiB0aGlzLl9vbk1vdXNlTW92ZUNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmVhdHVyZUNvbGxlY3Rpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgICAgICAgICBmZWF0dXJlczogWy4uLmNoYW5nZXMuY3JlYXRlZF0sXG4gICAgICAgIH0gYXMgR2VvSnNvbk9iamVjdDtcblxuICAgICAgICB0aGlzLl9tYXAuZGF0YS5hZGRHZW9Kc29uKGZlYXR1cmVDb2xsZWN0aW9uKTtcblxuICAgICAgICB0aGlzLl9tYXAuZGF0YS5zZXRTdHlsZSgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IGZlYXR1cmUuZ2V0UHJvcGVydHkoXCJtb2RlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ21HZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGlmICghZ21HZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdvb2dsZSBNYXBzIGdlb21ldHJ5IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnbUdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gZmVhdHVyZS5nZXRQcm9wZXJ0eShTRUxFQ1RfUFJPUEVSVElFUy5TRUxFQ1RFRCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblBvaW50ID0gQm9vbGVhbihcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmdldFByb3BlcnR5KFNFTEVDVF9QUk9QRVJUSUVTLlNFTEVDVElPTl9QT0lOVClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBtaWRQb2ludCA9IEJvb2xlYW4oXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5nZXRQcm9wZXJ0eShTRUxFQ1RfUFJPUEVSVElFUy5NSURfUE9JTlQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0aW9uID0gc2VsZWN0ZWQgfHwgc2VsZWN0aW9uUG9pbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNaWRwb2ludCA9IG1pZFBvaW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuY2lyY2xlUGF0aChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsaW5nW21vZGVdLnNlbGVjdGlvblBvaW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc01pZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxpbmdbbW9kZV0ubWlkUG9pbnRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdHlsaW5nW21vZGVdLnBvaW50V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGlzU2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsaW5nW21vZGVdLnNlbGVjdGVkQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGlzTWlkcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsaW5nW21vZGVdLm1pZFBvaW50Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdHlsaW5nW21vZGVdLnBvaW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBpc1NlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGluZ1ttb2RlXS5zZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc01pZHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGluZ1ttb2RlXS5taWRQb2ludE91dGxpbmVDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogaXNTZWxlY3Rpb24gfHwgaXNNaWRwb2ludCA/IDIgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsaW5nW21vZGVdLnNlbGVjdGVkQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3R5bGluZ1ttb2RlXS5saW5lU3RyaW5nQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogc3R5bGluZ1ttb2RlXS5saW5lU3RyaW5nV2lkdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxpbmdbbW9kZV0uc2VsZWN0ZWRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdHlsaW5nW21vZGVdLnBvbHlnb25PdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogc3R5bGluZ1ttb2RlXS5wb2x5Z29uT3V0bGluZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogc3R5bGluZ1ttb2RlXS5wb2x5Z29uRmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGluZ1ttb2RlXS5zZWxlY3RlZENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN0eWxpbmdbbW9kZV0ucG9seWdvbkZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gZmVhdHVyZSB0eXBlXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB0cnVlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgVGVycmFEcmF3Q2FsbGJhY2tzLFxuICAgIFRlcnJhRHJhd0FkYXB0ZXIsXG4gICAgVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnLFxuICAgIFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nLFxuICAgIFRlcnJhRHJhd0NoYW5nZXMsXG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBTRUxFQ1RfUFJPUEVSVElFUyxcbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHsgRmVhdHVyZSwgR2VvSnNvbk9iamVjdCB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgTCBmcm9tIFwibGVhZmxldFwiO1xuaW1wb3J0IHsgbGltaXRQcmVjaXNpb24gfSBmcm9tIFwiLi4vZ2VvbWV0cnkvbGltaXQtZGVjaW1hbC1wcmVjaXNpb25cIjtcblxuZXhwb3J0IGNsYXNzIFRlcnJhRHJhd0xlYWZsZXRBZGFwdGVyIGltcGxlbWVudHMgVGVycmFEcmF3QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiB7XG4gICAgbGliOiB0eXBlb2YgTDtcbiAgICBtYXA6IEwuTWFwO1xuICAgIGNvb3JkaW5hdGVQcmVjaXNpb24/OiBudW1iZXI7XG4gIH0pIHtcbiAgICAgICAgdGhpcy5fbGliID0gY29uZmlnLmxpYjtcbiAgICAgICAgdGhpcy5fbWFwID0gY29uZmlnLm1hcDtcbiAgICAgICAgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiA9XG4gICAgICB0eXBlb2YgY29uZmlnLmNvb3JkaW5hdGVQcmVjaXNpb24gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICA/IGNvbmZpZy5jb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICAgOiA5O1xuXG4gICAgICAgIHRoaXMuZ2V0TWFwQ29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXRDb250YWluZXIoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnByb2plY3QgPSAobG5nOiBudW1iZXIsIGxhdDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHsgbG5nLCBsYXQgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bnByb2plY3QgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbG5nLCBsYXQgfSA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9IGFzIEwuUG9pbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7IGxuZywgbGF0IH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IgPSAoY3Vyc29yKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3Vyc29yID09PSBcInVuc2V0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcENvbnRhaW5lcigpLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiY3Vyc29yXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcENvbnRhaW5lcigpLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9oZWxkS2V5czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG4gICAgcHJpdmF0ZSBfbGliOiB0eXBlb2YgTDtcbiAgICBwcml2YXRlIF9jb29yZGluYXRlUHJlY2lzaW9uOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfbWFwOiBMLk1hcDtcbiAgICBwcml2YXRlIF9vbk1vdXNlTW92ZUxpc3RlbmVyOiAoKGV2OiBhbnkpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX29uQ2xpY2tMaXN0ZW5lcjogKChldjogYW55KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbktleVVwTGlzdGVuZXI6ICgoZXY6IGFueSkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfb25LZXlEb3duTGlzdGVuZXI6ICgoZXY6IGFueSkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbiAgICBwcml2YXRlIF9vbkRyYWdTdGFydExpc3RlbmVyOiAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkRyYWdMaXN0ZW5lcjogKChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfb25EcmFnRW5kTGlzdGVuZXI6ICgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX2xheWVyOiBMLkxheWVyIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX21pZFBvaW50UGFuZVpJbmRleFN0eWxlU2hlZXQ6IEhUTUxTdHlsZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfbWlkUG9pbnRQYW5lID0gXCJtaWRQb2ludFBhbmVcIjtcbiAgICBwcml2YXRlIF9zZWxlY3Rpb25QYW5lWkluZGV4U3R5bGVTaGVldDogSFRNTFN0eWxlRWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9zZWxlY3RlZFBhbmUgPSBcInNlbGVjdGVkUGFuZVwiO1xuICAgIHB1YmxpYyBwcm9qZWN0OiBUZXJyYURyYXdNb2RlUmVnaXN0ZXJDb25maWdbXCJwcm9qZWN0XCJdO1xuICAgIHB1YmxpYyB1bnByb2plY3Q6IFRlcnJhRHJhd01vZGVSZWdpc3RlckNvbmZpZ1tcInVucHJvamVjdFwiXTtcbiAgICBwdWJsaWMgc2V0Q3Vyc29yOiBUZXJyYURyYXdNb2RlUmVnaXN0ZXJDb25maWdbXCJzZXRDdXJzb3JcIl07XG5cbiAgICBwdWJsaWMgZ2V0TWFwQ29udGFpbmVyOiAoKSA9PiBIVE1MRWxlbWVudDtcblxuICAgIHByaXZhdGUgY3JlYXRlUGFuZVN0eWxlU2hlZXQocGFuZTogc3RyaW5nLCB6SW5kZXg6IG51bWJlcikge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGUudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gYC5sZWFmbGV0LSR7cGFuZX0ge3otaW5kZXg6ICR7ekluZGV4fTt9YDtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgdGhpcy5fbWFwLmNyZWF0ZVBhbmUocGFuZSk7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZWdpc3RlcihjYWxsYmFja3M6IFRlcnJhRHJhd0NhbGxiYWNrcykge1xuICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGlvblBhbmVaSW5kZXhTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25QYW5lWkluZGV4U3R5bGVTaGVldCA9IHRoaXMuY3JlYXRlUGFuZVN0eWxlU2hlZXQoXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRQYW5lLFxuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9taWRQb2ludFBhbmVaSW5kZXhTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICB0aGlzLl9taWRQb2ludFBhbmVaSW5kZXhTdHlsZVNoZWV0ID0gdGhpcy5jcmVhdGVQYW5lU3R5bGVTaGVldChcbiAgICAgICAgICAgICAgICB0aGlzLl9taWRQb2ludFBhbmUsXG4gICAgICAgICAgICAgICAgMjBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldE1hcENvbnRhaW5lcigpO1xuXG4gICAgICAgIGxldCBkcmFnU3RhdGU6XG4gICAgICB8IFwibm90LWRyYWdnaW5nXCJcbiAgICAgIHwgXCJwcmUtZHJhZ2dpbmdcIlxuICAgICAgfCBcImRyYWdnaW5nXCJcbiAgICAgIHwgXCJhZnRlci1kcmFnZ2luZ1wiID0gXCJub3QtZHJhZ2dpbmdcIjtcblxuICAgICAgICB0aGlzLl9vbkNsaWNrTGlzdGVuZXIgPSAoZXZlbnQ6IEwuTGVhZmxldE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChkcmFnU3RhdGUgPT09IFwibm90LWRyYWdnaW5nXCIgfHwgZHJhZ1N0YXRlID09PSBcInByZS1kcmFnZ2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBsbmc6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxhdGxuZy5sbmcsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgICAgICBsYXQ6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxhdGxuZy5sYXQsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJYOlxuICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJZOlxuICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRZIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogZXZlbnQub3JpZ2luYWxFdmVudC5idXR0b24gPT09IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgaGVsZEtleXM6IFsuLi50aGlzLl9oZWxkS2V5c10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2UgY2FuJ3QgdXNlICdjbGljaycgaGVyZSBiZWNhdXNlIGl0IHRyaWdnZXJzXG4gICAgICAgIC8vIGFmdGVyIGRyYWcgZW5kIGluIExlYWZsZXQgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgIHRoaXMuX21hcC5vbihcIm1vdXNldXBcIiwgdGhpcy5fb25DbGlja0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fb25DbGlja0xpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZUxpc3RlbmVyID0gKGV2ZW50OiBMLkxlYWZsZXRNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5vbk1vdXNlTW92ZSh7XG4gICAgICAgICAgICAgICAgbG5nOiBsaW1pdFByZWNpc2lvbihldmVudC5sYXRsbmcubG5nLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICBsYXQ6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxhdGxuZy5sYXQsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6XG4gICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclk6XG4gICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRZIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5vcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PT0gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgIGhlbGRLZXlzOiBbLi4udGhpcy5faGVsZEtleXNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21hcC5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZUxpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLl9vbkRyYWdTdGFydExpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBkcmFnU3RhdGUgPSBcInByZS1kcmFnZ2luZ1wiO1xuICAgICAgICB9O1xuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuX29uRHJhZ1N0YXJ0TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uRHJhZ0xpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICAgICAgICB9IGFzIEwuUG9pbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgbG5nLCBsYXQgfSA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50KTtcblxuICAgICAgICAgICAgY29uc3QgZHJhd0V2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGxuZzogbGltaXRQcmVjaXNpb24obG5nLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICBsYXQ6IGxpbWl0UHJlY2lzaW9uKGxhdCwgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWDogZXZlbnQuY2xpZW50WCAtIGNvbnRhaW5lci5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjogZXZlbnQuYnV0dG9uID09PSAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgaGVsZEtleXM6IFsuLi50aGlzLl9oZWxkS2V5c10sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZHJhZ1N0YXRlID09PSBcInByZS1kcmFnZ2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgZHJhZ1N0YXRlID0gXCJkcmFnZ2luZ1wiO1xuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRHJhZ1N0YXJ0KGRyYXdFdmVudCwgKGVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ1N0YXRlID09PSBcImRyYWdnaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25EcmFnKGRyYXdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9vbkRyYWdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25EcmFnRW5kTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChkcmFnU3RhdGUgPT09IFwiZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIH0gYXMgTC5Qb2ludDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbG5nLCBsYXQgfSA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkRyYWdFbmQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogbGltaXRQcmVjaXNpb24obG5nLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogbGltaXRQcmVjaXNpb24obGF0LCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6IGV2ZW50LmNsaWVudFggLSBjb250YWluZXIub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5idXR0b24gPT09IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbGRLZXlzOiBbLi4udGhpcy5faGVsZEtleXNdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZHJhZ2dpbmcuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBhdm9pZCB0cmlnZ2VyaW5nIGFuIGNsaWNrXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgYWZ0ZXIgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBkcmFnU3RhdGUgPSBcImFmdGVyLWRyYWdnaW5nXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJhZ1N0YXRlID0gXCJub3QtZHJhZ2dpbmdcIjtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLl9vbkRyYWdFbmRMaXN0ZW5lcik7XG5cbiAgICAgICAgLy8gbWFwIGhhcyBubyBrZXlwcmVzcyBldmVudCwgc28gd2UgYWRkIG9uZSB0byB0aGUgY2FudmFzIGl0c2VsZlxuICAgICAgICB0aGlzLl9vbktleVVwTGlzdGVuZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2hlbGRLZXlzLmRlbGV0ZShldmVudC5rZXkpO1xuXG4gICAgICAgICAgICBjYWxsYmFja3Mub25LZXlVcCh7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9vbktleVVwTGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uS2V5RG93bkxpc3RlbmVyID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9oZWxkS2V5cy5hZGQoZXZlbnQua2V5KTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLm9uS2V5RG93bih7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93bkxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB1bnJlZ2lzdGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fb25DbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fb25DbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5fb25DbGlja0xpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vbk1vdXNlTW92ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKFwiY2xpY2tcIiwgdGhpcy5fb25DbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xpY2tMaXN0ZW5lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUGFuZSA9IHRoaXMuX21hcC5nZXRQYW5lKHRoaXMuX3NlbGVjdGVkUGFuZSk7XG4gICAgICAgIGlmIChzZWxlY3RlZFBhbmUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkUGFuZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihcbiAgICAgICAgY2hhbmdlczogVGVycmFEcmF3Q2hhbmdlcyxcbiAgICAgICAgc3R5bGluZzogeyBbbW9kZTogc3RyaW5nXTogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcgfVxuICAgICkge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgIC4uLmNoYW5nZXMuY3JlYXRlZCxcbiAgICAgICAgICAgIC4uLmNoYW5nZXMudXBkYXRlZCxcbiAgICAgICAgICAgIC4uLmNoYW5nZXMudW5jaGFuZ2VkLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVDb2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgIH0gYXMgR2VvSnNvbk9iamVjdDtcblxuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMuX2xpYi5nZW9KU09OKGZlYXR1cmVDb2xsZWN0aW9uLCB7XG4gICAgICAgICAgICAvLyBTdHlsZSBwb2ludHMgLSBjb252ZXJ0IG1hcmtlcnMgdG8gY2lyY2xlIG1hcmtlcnNcbiAgICAgICAgICAgIHBvaW50VG9MYXllcjogKGZlYXR1cmU6IEZlYXR1cmUsIGxhdGxuZzogTC5MYXRMbmdFeHByZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBoYXMgbm8gcHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm1vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZVN0eWxlID0gc3R5bGluZ1ttb2RlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID1cbiAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuU0VMRUNURURdIHx8XG4gICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnNlbGVjdGlvblBvaW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTWlkUG9pbnQgPSBmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuTUlEX1BPSU5UXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBpc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5zZWxlY3Rpb25Qb2ludFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzTWlkUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5taWRQb2ludFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlU3R5bGUucG9pbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiBpc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5zZWxlY3RlZENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzTWlkUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5taWRQb2ludENvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlU3R5bGUucG9pbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBpc1NlbGVjdGVkIHx8IGlzTWlkUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBpc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5zZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlzTWlkUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vZGVTdHlsZS5taWRQb2ludE91dGxpbmVDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZVN0eWxlLnBvaW50T3V0bGluZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGlzU2VsZWN0ZWQgfHwgaXNNaWRQb2ludCA/IDIgOiAwLFxuICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgICAgICAgICAgICAgICBwYW5lOiBpc1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX3NlbGVjdGVkUGFuZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpc01pZFBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9taWRQb2ludFBhbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLCAvLyBSZW1vdmVzIG1vdXNlIGhvdmVyIGN1cnNvciBzdHlsZXNcbiAgICAgICAgICAgICAgICB9IGFzIEwuQ2lyY2xlTWFya2VyT3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMuX2xpYi5jaXJjbGVNYXJrZXIobGF0bG5nLCBzdHlsZXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFN0eWxlIExpbmVTdHJpbmdzIGFuZCBQb2x5Z29uc1xuICAgICAgICAgICAgc3R5bGU6IChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlIHx8ICFmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGUgPSBmZWF0dXJlLnByb3BlcnRpZXMubW9kZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlU3R5bGUgPSBzdHlsaW5nW21vZGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSwgLy8gUmVtb3ZlcyBtb3VzZSBob3ZlciBjdXJzb3Igc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzW1NFTEVDVF9QUk9QRVJUSUVTLlNFTEVDVEVEXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbW9kZVN0eWxlLnNlbGVjdGVkQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vZGVTdHlsZS5saW5lU3RyaW5nQ29sb3IsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogbW9kZVN0eWxlLmxpbmVTdHJpbmdXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSwgLy8gUmVtb3ZlcyBtb3VzZSBob3ZlciBjdXJzb3Igc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogbW9kZVN0eWxlLnBvbHlnb25GaWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzW1NFTEVDVF9QUk9QRVJUSUVTLlNFTEVDVEVEXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbW9kZVN0eWxlLnNlbGVjdGVkQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vZGVTdHlsZS5wb2x5Z29uRmlsbENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBtb2RlU3R5bGUucG9seWdvbk91dGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuU0VMRUNURURdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtb2RlU3R5bGUuc2VsZWN0ZWRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZVN0eWxlLnBvbHlnb25PdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcblxuICAgICAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgVGVycmFEcmF3Q2FsbGJhY2tzLFxuICAgIFRlcnJhRHJhd0FkYXB0ZXIsXG4gICAgVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnLFxuICAgIFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nLFxuICAgIFRlcnJhRHJhd0NoYW5nZXMsXG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBTRUxFQ1RfUFJPUEVSVElFUyxcbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHsgRmVhdHVyZSwgTGluZVN0cmluZywgUG9pbnQsIFBvbHlnb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHsgbGltaXRQcmVjaXNpb24gfSBmcm9tIFwiLi4vZ2VvbWV0cnkvbGltaXQtZGVjaW1hbC1wcmVjaXNpb25cIjtcbmltcG9ydCBtYXBib3hnbCwge1xuICAgIENpcmNsZUxheWVyLFxuICAgIEZpbGxMYXllcixcbiAgICBMaW5lTGF5ZXIsXG4gICAgUG9pbnRMaWtlLFxufSBmcm9tIFwibWFwYm94LWdsXCI7XG5pbXBvcnQgeyBHZW9KU09OU3RvcmVGZWF0dXJlcywgR2VvSlNPTlN0b3JlR2VvbWV0cmllcyB9IGZyb20gXCIuLi9zdG9yZS9zdG9yZVwiO1xuXG5leHBvcnQgY2xhc3MgVGVycmFEcmF3TWFwYm94R0xBZGFwdGVyIGltcGxlbWVudHMgVGVycmFEcmF3QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiB7IG1hcDogbWFwYm94Z2wuTWFwOyBjb29yZGluYXRlUHJlY2lzaW9uOiBudW1iZXIgfSkge1xuICAgICAgICB0aGlzLl9tYXAgPSBjb25maWcubWFwO1xuICAgICAgICB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uID1cbiAgICAgIHR5cGVvZiBjb25maWcuY29vcmRpbmF0ZVByZWNpc2lvbiA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgID8gY29uZmlnLmNvb3JkaW5hdGVQcmVjaXNpb25cbiAgICAgICAgICA6IDk7XG5cbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKGxuZzogbnVtYmVyLCBsYXQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl9tYXAucHJvamVjdCh7IGxuZywgbGF0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudW5wcm9qZWN0ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGxuZywgbGF0IH0gPSB0aGlzLl9tYXAudW5wcm9qZWN0KHsgeCwgeSB9IGFzIFBvaW50TGlrZSk7XG4gICAgICAgICAgICByZXR1cm4geyBsbmcsIGxhdCB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yID0gKHN0eWxlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRNYXBDb250YWluZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldENvbnRhaW5lcigpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyB1bnByb2plY3Q6IFRlcnJhRHJhd01vZGVSZWdpc3RlckNvbmZpZ1tcInVucHJvamVjdFwiXTtcbiAgICBwdWJsaWMgcHJvamVjdDogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnW1wicHJvamVjdFwiXTtcbiAgICBwdWJsaWMgc2V0Q3Vyc29yOiBUZXJyYURyYXdNb2RlUmVnaXN0ZXJDb25maWdbXCJzZXRDdXJzb3JcIl07XG5cbiAgICBwdWJsaWMgZ2V0TWFwQ29udGFpbmVyOiAoKSA9PiBIVE1MRWxlbWVudDtcblxuICAgIHByaXZhdGUgX2hlbGRLZXlzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICBwcml2YXRlIF9jb29yZGluYXRlUHJlY2lzaW9uOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfbWFwOiBtYXBib3hnbC5NYXA7XG4gICAgcHJpdmF0ZSBfb25Nb3VzZU1vdmVMaXN0ZW5lcjpcbiAgICB8ICgoZXZlbnQ6IG1hcGJveGdsLk1hcE1vdXNlRXZlbnQgJiBtYXBib3hnbC5FdmVudERhdGEpID0+IHZvaWQpXG4gICAgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfb25DbGlja0xpc3RlbmVyOlxuICAgIHwgKChldmVudDogbWFwYm94Z2wuTWFwTW91c2VFdmVudCAmIG1hcGJveGdsLkV2ZW50RGF0YSkgPT4gdm9pZClcbiAgICB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkRyYWdTdGFydExpc3RlbmVyOiAoKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbkRyYWdMaXN0ZW5lcjogKChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfb25EcmFnRW5kTGlzdGVuZXI6ICgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX29uS2V5RG93bkxpc3RlbmVyOiAoKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9vbktleVVwTGlzdGVuZXI6ICgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IGFueSkgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfcmVuZGVyZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5cbiAgICBwcml2YXRlIF9hZGRHZW9KU09OU291cmNlKGlkOiBzdHJpbmcsIGZlYXR1cmVzOiBGZWF0dXJlW10pIHtcbiAgICAgICAgdGhpcy5fbWFwLmFkZFNvdXJjZShpZCwge1xuICAgICAgICAgICAgdHlwZTogXCJnZW9qc29uXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2FkZEZpbGxMYXllcihcbiAgICAgICAgaWQ6IHN0cmluZyxcbiAgICAgICAgbW9kZTogc3RyaW5nLFxuICAgICAgICBzdHlsaW5nOiBUZXJyYURyYXdBZGFwdGVyU3R5bGluZ1xuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgICAgICAgICAgZmlsdGVyOiBbXG4gICAgICAgICAgICAgICAgXCJhbGxcIixcbiAgICAgICAgICAgICAgICBbXCJtYXRjaFwiLCBbXCJnZW9tZXRyeS10eXBlXCJdLCBcIlBvbHlnb25cIiwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFtcIm1hdGNoXCIsIFtcImdldFwiLCBcIm1vZGVcIl0sIG1vZGUsIHRydWUsIGZhbHNlXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwYWludDoge1xuICAgICAgICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiBbXCJnZXRcIiwgXCJwb2x5Z29uRmlsbENvbG9yXCJdLFxuICAgICAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHN0eWxpbmcucG9seWdvbkZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSBhcyBGaWxsTGF5ZXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2FkZEZpbGxPdXRsaW5lTGF5ZXIoXG4gICAgICAgIGlkOiBzdHJpbmcsXG4gICAgICAgIG1vZGU6IHN0cmluZyxcbiAgICAgICAgc3R5bGluZzogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcsXG4gICAgICAgIGJlbmVhdGg/OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9tYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgaWQ6IGlkICsgXCJvdXRsaW5lXCIsXG4gICAgICAgICAgICBzb3VyY2U6IGlkLFxuICAgICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgICBmaWx0ZXI6IFtcbiAgICAgICAgICAgICAgICBcImFsbFwiLFxuICAgICAgICAgICAgICAgIFtcIm1hdGNoXCIsIFtcImdlb21ldHJ5LXR5cGVcIl0sIFwiUG9seWdvblwiLCB0cnVlLCBmYWxzZV0sXG4gICAgICAgICAgICAgICAgW1wibWF0Y2hcIiwgW1wiZ2V0XCIsIFwibW9kZVwiXSwgbW9kZSwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IHN0eWxpbmcucG9seWdvbk91dGxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICBcImxpbmUtY29sb3JcIjogW1wiZ2V0XCIsIFwicG9seWdvbk91dGxpbmVDb2xvclwiXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgTGluZUxheWVyKTtcblxuICAgICAgICBpZiAoYmVuZWF0aCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm1vdmVMYXllcihpZCwgYmVuZWF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWRkTGluZUxheWVyKFxuICAgICAgICBpZDogc3RyaW5nLFxuICAgICAgICBtb2RlOiBzdHJpbmcsXG4gICAgICAgIHN0eWxpbmc6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nLFxuICAgICAgICBiZW5lYXRoPzogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgICAgZmlsdGVyOiBbXG4gICAgICAgICAgICAgICAgXCJhbGxcIixcbiAgICAgICAgICAgICAgICBbXCJtYXRjaFwiLCBbXCJnZW9tZXRyeS10eXBlXCJdLCBcIkxpbmVTdHJpbmdcIiwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFtcIm1hdGNoXCIsIFtcImdldFwiLCBcIm1vZGVcIl0sIG1vZGUsIHRydWUsIGZhbHNlXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwYWludDoge1xuICAgICAgICAgICAgICAgIFwibGluZS13aWR0aFwiOiBzdHlsaW5nLmxpbmVTdHJpbmdXaWR0aCxcbiAgICAgICAgICAgICAgICBcImxpbmUtY29sb3JcIjogW1wiZ2V0XCIsIFwibGluZVN0cmluZ0NvbG9yXCJdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSBhcyBMaW5lTGF5ZXIpO1xuXG4gICAgICAgIGlmIChiZW5lYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAubW92ZUxheWVyKGlkLCBiZW5lYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9hZGRQb2ludExheWVyKFxuICAgICAgICBpZDogc3RyaW5nLFxuICAgICAgICBtb2RlOiBzdHJpbmcsXG4gICAgICAgIHN0eWxpbmc6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nLFxuICAgICAgICBiZW5lYXRoPzogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc291cmNlOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IFwiY2lyY2xlXCIsXG4gICAgICAgICAgICBmaWx0ZXI6IFtcbiAgICAgICAgICAgICAgICBcImFsbFwiLFxuICAgICAgICAgICAgICAgIFtcIm1hdGNoXCIsIFtcImdlb21ldHJ5LXR5cGVcIl0sIFwiUG9pbnRcIiwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgICAgICAgICAgIFtcIm1hdGNoXCIsIFtcImdldFwiLCBcIm1vZGVcIl0sIG1vZGUsIHRydWUsIGZhbHNlXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwYWludDoge1xuICAgICAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiBbXCJnZXRcIiwgXCJzZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yXCJdLFxuICAgICAgICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiAyLFxuICAgICAgICAgICAgICAgIFwiY2lyY2xlLXJhZGl1c1wiOiBbXCJnZXRcIiwgXCJwb2ludFdpZHRoXCJdLFxuICAgICAgICAgICAgICAgIFwiY2lyY2xlLWNvbG9yXCI6IFtcImdldFwiLCBcInBvaW50Q29sb3JcIl0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9IGFzIENpcmNsZUxheWVyKTtcbiAgICAgICAgaWYgKGJlbmVhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5tb3ZlTGF5ZXIoaWQsIGJlbmVhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9hZGRMYXllcihcbiAgICAgICAgaWQ6IHN0cmluZyxcbiAgICAgICAgbW9kZTogc3RyaW5nLFxuICAgICAgICBmZWF0dXJlVHlwZTogXCJQb2ludFwiIHwgXCJMaW5lU3RyaW5nXCIgfCBcIlBvbHlnb25cIixcbiAgICAgICAgc3R5bGluZzogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcsXG4gICAgICAgIGJlbmVhdGg/OiBzdHJpbmdcbiAgICApIHtcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFBvaW50TGF5ZXIoaWQsIG1vZGUsIHN0eWxpbmcsIGJlbmVhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWF0dXJlVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZExpbmVMYXllcihpZCwgbW9kZSwgc3R5bGluZywgYmVuZWF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgdGhpcy5fYWRkRmlsbExheWVyKGlkLCBtb2RlLCBzdHlsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEZpbGxPdXRsaW5lTGF5ZXIoaWQsIG1vZGUsIHN0eWxpbmcsIGJlbmVhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWRkR2VvSlNPTkxheWVyPFQgZXh0ZW5kcyBHZW9KU09OU3RvcmVHZW9tZXRyaWVzPihcbiAgICAgICAgbW9kZTogc3RyaW5nLFxuICAgICAgICBmZWF0dXJlVHlwZTogRmVhdHVyZTxUPltcImdlb21ldHJ5XCJdW1widHlwZVwiXSxcbiAgICAgICAgZmVhdHVyZXM6IEZlYXR1cmU8VD5bXSxcbiAgICAgICAgc3R5bGluZzogVGVycmFEcmF3QWRhcHRlclN0eWxpbmdcbiAgICApIHtcbiAgICAgICAgY29uc3QgaWQgPSBgdGQtJHttb2RlfS0ke2ZlYXR1cmVUeXBlLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgdGhpcy5fYWRkR2VvSlNPTlNvdXJjZShpZCwgZmVhdHVyZXMpO1xuICAgICAgICB0aGlzLl9hZGRMYXllcihpZCwgbW9kZSwgZmVhdHVyZVR5cGUsIHN0eWxpbmcpO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXRHZW9KU09OTGF5ZXJEYXRhPFQgZXh0ZW5kcyBHZW9KU09OU3RvcmVHZW9tZXRyaWVzPihcbiAgICAgICAgbW9kZTogc3RyaW5nLFxuICAgICAgICBmZWF0dXJlVHlwZTogRmVhdHVyZTxUPltcImdlb21ldHJ5XCJdW1widHlwZVwiXSxcbiAgICAgICAgZmVhdHVyZXM6IEZlYXR1cmU8VD5bXVxuICAgICkge1xuICAgICAgICBjb25zdCBpZCA9IGB0ZC0ke21vZGV9LSR7ZmVhdHVyZVR5cGUudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICAodGhpcy5fbWFwLmdldFNvdXJjZShpZCkgYXMgYW55KS5zZXREYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY2FsbGJhY2tzOiBUZXJyYURyYXdDYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5fb25DbGlja0xpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFja3Mub25DbGljayh7XG4gICAgICAgICAgICAgICAgbG5nOiBsaW1pdFByZWNpc2lvbihldmVudC5sbmdMYXQubG5nLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICBsYXQ6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxuZ0xhdC5sYXQsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6XG4gICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclk6XG4gICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRZIC0gdGhpcy5nZXRNYXBDb250YWluZXIoKS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5vcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PT0gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgIGhlbGRLZXlzOiBbLi4udGhpcy5faGVsZEtleXNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21hcC5vbihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX21hcC5vbihcImNvbnRleHRtZW51XCIsIHRoaXMuX29uQ2xpY2tMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2tzLm9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgICAgICBsbmc6IGxpbWl0UHJlY2lzaW9uKGV2ZW50LmxuZ0xhdC5sbmcsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGxhdDogbGltaXRQcmVjaXNpb24oZXZlbnQubG5nTGF0LmxhdCwgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWDpcbiAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFggLSB0aGlzLmdldE1hcENvbnRhaW5lcigpLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyWTpcbiAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFkgLSB0aGlzLmdldE1hcENvbnRhaW5lcigpLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICBidXR0b246IGV2ZW50Lm9yaWdpbmFsRXZlbnQuYnV0dG9uID09PSAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgaGVsZEtleXM6IFsuLi50aGlzLl9oZWxkS2V5c10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlTGlzdGVuZXIpO1xuXG4gICAgICAgIGxldCBkcmFnU3RhdGU6IFwibm90LWRyYWdnaW5nXCIgfCBcInByZS1kcmFnZ2luZ1wiIHwgXCJkcmFnZ2luZ1wiID1cbiAgICAgIFwibm90LWRyYWdnaW5nXCI7XG5cbiAgICAgICAgdGhpcy5fb25EcmFnU3RhcnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZHJhZ1N0YXRlID0gXCJwcmUtZHJhZ2dpbmdcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldE1hcENvbnRhaW5lcigpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX29uRHJhZ1N0YXJ0TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uRHJhZ0xpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGxuZywgbGF0IH0gPSB0aGlzLl9tYXAudW5wcm9qZWN0KHtcbiAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WSAtIGNvbnRhaW5lci5vZmZzZXRUb3AsXG4gICAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRyYXdFdmVudDogVGVycmFEcmF3TW91c2VFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBsbmc6IGxpbWl0UHJlY2lzaW9uKGxuZywgdGhpcy5fY29vcmRpbmF0ZVByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgbGF0OiBsaW1pdFByZWNpc2lvbihsYXQsIHRoaXMuX2Nvb3JkaW5hdGVQcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6IGV2ZW50LmNsaWVudFggLSBjb250YWluZXIub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJZOiBldmVudC5jbGllbnRZIC0gY29udGFpbmVyLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICBidXR0b246IGV2ZW50LmJ1dHRvbiA9PT0gMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgIGhlbGRLZXlzOiBbLi4udGhpcy5faGVsZEtleXNdLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGRyYWdTdGF0ZSA9PT0gXCJwcmUtZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGRyYWdTdGF0ZSA9IFwiZHJhZ2dpbmdcIjtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkRyYWdTdGFydChkcmF3RXZlbnQsIChlbmFibGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZHJhZ1Bhbi5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5kcmFnUGFuLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnU3RhdGUgPT09IFwiZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkRyYWcoZHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbkRyYWdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25EcmFnRW5kTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChkcmFnU3RhdGUgPT09IFwiZHJhZ2dpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBldmVudC5jbGllbnRYIC0gY29udGFpbmVyLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgIH0gYXMgbWFwYm94Z2wuUG9pbnQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGxuZywgbGF0IH0gPSB0aGlzLl9tYXAudW5wcm9qZWN0KHBvaW50KTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkRyYWdFbmQoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxuZzogbGltaXRQcmVjaXNpb24obG5nLCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdDogbGltaXRQcmVjaXNpb24obGF0LCB0aGlzLl9jb29yZGluYXRlUHJlY2lzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclg6IGV2ZW50LmNsaWVudFggLSBjb250YWluZXIub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclk6IGV2ZW50LmNsaWVudFkgLSBjb250YWluZXIub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBldmVudC5idXR0b24gPT09IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbGRLZXlzOiBbLi4udGhpcy5faGVsZEtleXNdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAoZW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZHJhZ1Bhbi5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJhZ1N0YXRlID0gXCJub3QtZHJhZ2dpbmdcIjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fb25EcmFnRW5kTGlzdGVuZXIpO1xuXG4gICAgICAgIC8vIG1hcCBoYXMgbm8ga2V5cHJlc3MgZXZlbnQsIHNvIHdlIGFkZCBvbmUgdG8gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICAgICAgdGhpcy5fb25LZXlVcExpc3RlbmVyID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9oZWxkS2V5cy5kZWxldGUoZXZlbnQua2V5KTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLm9uS2V5VXAoe1xuICAgICAgICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fb25LZXlVcExpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLl9vbktleURvd25MaXN0ZW5lciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdGhpcy5faGVsZEtleXMuYWRkKGV2ZW50LmtleSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5vbktleURvd24oe1xuICAgICAgICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd25MaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZihcImNvbnRleHRtZW51ZVwiLCB0aGlzLl9vbkNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25Nb3VzZU1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VNb3ZlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25LZXlVcExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgICAgICAuZ2V0Q2FudmFzKClcbiAgICAgICAgICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIHRoaXMuX29uS2V5VXBMaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25EcmFnU3RhcnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLmdldENhbnZhcygpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25EcmFnU3RhcnRMaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25EcmFnTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgICAgIC5nZXRDYW52YXMoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uRHJhZ0xpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vbkRyYWdFbmRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLmdldENhbnZhcygpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX29uRHJhZ0VuZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcihcbiAgICAgICAgY2hhbmdlczogVGVycmFEcmF3Q2hhbmdlcyxcbiAgICAgICAgc3R5bGluZzogeyBbbW9kZTogc3RyaW5nXTogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcgfVxuICAgICkge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtcbiAgICAgICAgICAgIC4uLmNoYW5nZXMuY3JlYXRlZCxcbiAgICAgICAgICAgIC4uLmNoYW5nZXMudXBkYXRlZCxcbiAgICAgICAgICAgIC4uLmNoYW5nZXMudW5jaGFuZ2VkLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IG1vZGVGZWF0dXJlczoge1xuICAgICAgW2tleTogc3RyaW5nXToge1xuICAgICAgICBwb2ludHM6IEdlb0pTT05TdG9yZUZlYXR1cmVzW107XG4gICAgICAgIGxpbmVzdHJpbmdzOiBHZW9KU09OU3RvcmVGZWF0dXJlc1tdO1xuICAgICAgICBwb2x5Z29uczogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXTtcbiAgICAgIH07XG4gICAgfSA9IHt9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGluZykuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxpbmdbbW9kZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5wcm9wZXJ0aWVzLm1vZGUgIT09IG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbW9kZUZlYXR1cmVzW21vZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVGZWF0dXJlc1ttb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc3RyaW5nczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uczogW10sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllc1tTRUxFQ1RfUFJPUEVSVElFUy5TRUxFQ1RFRF0gfHxcbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5zZWxlY3Rpb25Qb2ludFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5wb2ludENvbG9yID0gc3R5bGVzLnNlbGVjdGVkQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuc2VsZWN0ZWRQb2ludE91dGxpbmVDb2xvciA9XG4gICAgICAgICAgICAgIHN0eWxlcy5zZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnBvaW50V2lkdGggPSBzdHlsZXMuc2VsZWN0aW9uUG9pbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuTUlEX1BPSU5UXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnBvaW50Q29sb3IgPSBzdHlsZXMubWlkUG9pbnRDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5zZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yID1cbiAgICAgICAgICAgICAgc3R5bGVzLm1pZFBvaW50T3V0bGluZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnBvaW50V2lkdGggPSBzdHlsZXMubWlkUG9pbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5wb2ludENvbG9yID0gc3R5bGVzLnBvaW50Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuc2VsZWN0ZWRQb2ludE91dGxpbmVDb2xvciA9IHN0eWxlcy5wb2ludENvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnBvaW50V2lkdGggPSBzdHlsZXMucG9pbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlRmVhdHVyZXNbbW9kZV0ucG9pbnRzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuU0VMRUNURURdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMubGluZVN0cmluZ0NvbG9yID0gc3R5bGVzLnNlbGVjdGVkQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMubGluZVN0cmluZ0NvbG9yID0gc3R5bGVzLmxpbmVTdHJpbmdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtb2RlRmVhdHVyZXNbbW9kZV0ubGluZXN0cmluZ3MucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllc1tTRUxFQ1RfUFJPUEVSVElFUy5TRUxFQ1RFRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5wb2x5Z29uRmlsbENvbG9yID0gc3R5bGVzLnNlbGVjdGVkQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMucG9seWdvbk91dGxpbmVDb2xvciA9IHN0eWxlcy5zZWxlY3RlZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnBvbHlnb25GaWxsQ29sb3IgPSBzdHlsZXMucG9seWdvbkZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5wb2x5Z29uT3V0bGluZUNvbG9yID0gc3R5bGVzLnBvbHlnb25PdXRsaW5lQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZUZlYXR1cmVzW21vZGVdLnBvbHlnb25zLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsaW5nKS5mb3JFYWNoKChtb2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBzdHlsaW5nW21vZGVdO1xuICAgICAgICAgICAgaWYgKCFtb2RlRmVhdHVyZXNbbW9kZV0gfHwgIXN0eWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnRzLCBsaW5lc3RyaW5ncywgcG9seWdvbnMgfSA9IG1vZGVGZWF0dXJlc1ttb2RlXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlZFttb2RlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEdlb0pTT05MYXllcjxQb2ludD4oXG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIFwiUG9pbnRcIixcbiAgICAgICAgICBwb2ludHMgYXMgRmVhdHVyZTxQb2ludD5bXSxcbiAgICAgICAgICBzdHlsZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEdlb0pTT05MYXllcjxMaW5lU3RyaW5nPihcbiAgICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgbGluZXN0cmluZ3MgYXMgRmVhdHVyZTxMaW5lU3RyaW5nPltdLFxuICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkR2VvSlNPTkxheWVyPFBvbHlnb24+KFxuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICBcIlBvbHlnb25cIixcbiAgICAgICAgICBwb2x5Z29ucyBhcyBGZWF0dXJlPFBvbHlnb24+W10sXG4gICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlZFttb2RlXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50SWQgPSB0aGlzLl9zZXRHZW9KU09OTGF5ZXJEYXRhPFBvaW50PihcbiAgICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgXCJQb2ludFwiLFxuICAgICAgICAgIHBvaW50cyBhcyBGZWF0dXJlPFBvaW50PltdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRHZW9KU09OTGF5ZXJEYXRhPExpbmVTdHJpbmc+KFxuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICBsaW5lc3RyaW5ncyBhcyBGZWF0dXJlPExpbmVTdHJpbmc+W11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEdlb0pTT05MYXllckRhdGE8UG9seWdvbj4oXG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIFwiUG9seWdvblwiLFxuICAgICAgICAgIHBvbHlnb25zIGFzIEZlYXR1cmU8UG9seWdvbj5bXVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGxvZ2ljIGNvdWxkIGJlIGJldHRlciAtIEkgdGhpbmsgdGhpcyB3aWxsIHJlbmRlciB0aGUgc2VsZWN0aW9uIHBvaW50cyBhYm92ZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBsYXllcnMgb3V0c2lkZSBvZiBUZXJyYURyYXcgd2hpY2ggaXMgcGVyaGFwcyB1bmlkZWFsXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgc2VsZWN0aW9uL21pZCBwb2ludHMgYXJlIHJlbmRlcmVkIG9uIHRvcFxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5tb3ZlTGF5ZXIocG9pbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgU3RvcmVDaGFuZ2VIYW5kbGVyLFxuICAgIEdlb0pTT05TdG9yZSxcbiAgICBHZW9KU09OU3RvcmVGZWF0dXJlcyxcbn0gZnJvbSBcIi4vc3RvcmUvc3RvcmVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyB7XG4gIHBvaW50Q29sb3I6IHN0cmluZztcbiAgcG9pbnRXaWR0aDogbnVtYmVyO1xuICBwb2ludE91dGxpbmVDb2xvcjogc3RyaW5nO1xuICBwb2x5Z29uRmlsbENvbG9yOiBzdHJpbmc7XG4gIHBvbHlnb25GaWxsT3BhY2l0eTogbnVtYmVyO1xuICBwb2x5Z29uT3V0bGluZUNvbG9yOiBzdHJpbmc7XG4gIHBvbHlnb25PdXRsaW5lV2lkdGg6IG51bWJlcjtcbiAgbGluZVN0cmluZ1dpZHRoOiBudW1iZXI7XG4gIGxpbmVTdHJpbmdDb2xvcjogc3RyaW5nO1xuICBzZWxlY3RlZENvbG9yOiBzdHJpbmc7XG4gIHNlbGVjdGlvblBvaW50V2lkdGg6IG51bWJlcjtcbiAgc2VsZWN0ZWRQb2ludE91dGxpbmVDb2xvcjogc3RyaW5nO1xuICBtaWRQb2ludENvbG9yOiBzdHJpbmc7XG4gIG1pZFBvaW50V2lkdGg6IG51bWJlcjtcbiAgbWlkUG9pbnRPdXRsaW5lQ29sb3I6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYURyYXdNb3VzZUV2ZW50IHtcbiAgbG5nOiBudW1iZXI7XG4gIGxhdDogbnVtYmVyO1xuICBjb250YWluZXJYOiBudW1iZXI7XG4gIGNvbnRhaW5lclk6IG51bWJlcjtcbiAgYnV0dG9uOiBcImxlZnRcIiB8IFwicmlnaHRcIiB8IFwicG9pbnRlclwiO1xuICBoZWxkS2V5czogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVycmFEcmF3S2V5Ym9hcmRFdmVudCB7XG4gIGtleTogc3RyaW5nO1xufVxuXG50eXBlIFNldEN1cnNvciA9IChjdXJzb3I6IFwidW5zZXRcIiB8IFwiZ3JhYlwiIHwgXCJncmFiYmluZ1wiIHwgXCJjcm9zc2hhaXJcIikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgUHJvamVjdCA9IChsbmc6IG51bWJlciwgbGF0OiBudW1iZXIpID0+IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcbmV4cG9ydCB0eXBlIFVucHJvamVjdCA9ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4geyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfTtcblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYURyYXdNb2RlUmVnaXN0ZXJDb25maWcge1xuICBtb2RlOiBzdHJpbmc7XG4gIHN0b3JlOiBHZW9KU09OU3RvcmU7XG4gIHNldEN1cnNvcjogU2V0Q3Vyc29yO1xuICBvbkNoYW5nZTogU3RvcmVDaGFuZ2VIYW5kbGVyO1xuICBvblNlbGVjdDogKHNlbGVjdGVkSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgb25EZXNlbGVjdDogKGRlc2VsZWN0ZWRJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBwcm9qZWN0OiBQcm9qZWN0O1xuICB1bnByb2plY3Q6IFVucHJvamVjdDtcbn1cblxuZXhwb3J0IHR5cGUgVGVycmFEcmF3TW9kZVN0YXRlID1cbiAgfCBcInVucmVnaXN0ZXJlZFwiXG4gIHwgXCJyZWdpc3RlcmVkXCJcbiAgfCBcInN0YXJ0ZWRcIlxuICB8IFwic3RvcHBlZFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhRHJhd01vZGUge1xuICBtb2RlOiBzdHJpbmc7XG4gIHN0eWxpbmc6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nO1xuICBzdGF0ZTogVGVycmFEcmF3TW9kZVN0YXRlO1xuXG4gIHN0YXJ0OiAoKSA9PiB2b2lkO1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICByZWdpc3RlcjogKGNvbmZpZzogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnKSA9PiB2b2lkO1xuXG4gIC8vIGNsZWFuVXA6ICgpID0+IHZvaWQ7XG4gIG9uS2V5RG93bjogKGV2ZW50OiBUZXJyYURyYXdLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuICBvbktleVVwOiAoZXZlbnQ6IFRlcnJhRHJhd0tleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG4gIG9uTW91c2VNb3ZlOiAoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpID0+IHZvaWQ7XG4gIG9uQ2xpY2s6IChldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkgPT4gdm9pZDtcbiAgb25EcmFnU3RhcnQ6IChcbiAgICBldmVudDogVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBzZXRNYXBEcmFnZ2FiaWxpdHk6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkXG4gICkgPT4gdm9pZDtcbiAgb25EcmFnOiAoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpID0+IHZvaWQ7XG4gIG9uRHJhZ0VuZDogKFxuICAgIGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LFxuICAgIHNldE1hcERyYWdnYWJpbGl0eTogKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWRcbiAgKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhRHJhd0NhbGxiYWNrcyB7XG4gIG9uS2V5VXA6IChldmVudDogVGVycmFEcmF3S2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcbiAgb25LZXlEb3duOiAoZXZlbnQ6IFRlcnJhRHJhd0tleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG4gIG9uQ2xpY2s6IChldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkgPT4gdm9pZDtcbiAgb25Nb3VzZU1vdmU6IChldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkgPT4gdm9pZDtcbiAgb25EcmFnU3RhcnQ6IChcbiAgICBldmVudDogVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBzZXRNYXBEcmFnZ2FiaWxpdHk6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkXG4gICkgPT4gdm9pZDtcbiAgb25EcmFnOiAoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpID0+IHZvaWQ7XG4gIG9uRHJhZ0VuZDogKFxuICAgIGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LFxuICAgIHNldE1hcERyYWdnYWJpbGl0eTogKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHZvaWRcbiAgKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhRHJhd0NoYW5nZXMge1xuICBjcmVhdGVkOiBHZW9KU09OU3RvcmVGZWF0dXJlc1tdO1xuICB1cGRhdGVkOiBHZW9KU09OU3RvcmVGZWF0dXJlc1tdO1xuICB1bmNoYW5nZWQ6IEdlb0pTT05TdG9yZUZlYXR1cmVzW107XG4gIGRlbGV0ZWRJZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlcnJhRHJhd0FkYXB0ZXIge1xuICBwcm9qZWN0OiBQcm9qZWN0O1xuICB1bnByb2plY3Q6IFVucHJvamVjdDtcbiAgc2V0Q3Vyc29yOiBTZXRDdXJzb3I7XG4gIGdldE1hcENvbnRhaW5lcjogKCkgPT4gSFRNTEVsZW1lbnQ7XG4gIHJlZ2lzdGVyKGNhbGxiYWNrczogVGVycmFEcmF3Q2FsbGJhY2tzKTogdm9pZDtcbiAgdW5yZWdpc3RlcigpOiB2b2lkO1xuICByZW5kZXIoXG4gICAgY2hhbmdlczogVGVycmFEcmF3Q2hhbmdlcyxcbiAgICAvLyBmZWF0dXJlczogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXSxcbiAgICBzdHlsaW5nOiB7IFttb2RlOiBzdHJpbmddOiBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyB9XG4gICk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBTRUxFQ1RfUFJPUEVSVElFUyA9IHtcbiAgICBTRUxFQ1RFRDogXCJzZWxlY3RlZFwiLFxuICAgIE1JRF9QT0lOVDogXCJtaWRQb2ludFwiLFxuICAgIFNFTEVDVElPTl9QT0lOVDogXCJzZWxlY3Rpb25Qb2ludFwiLFxufSBhcyBjb25zdDtcbiIsIi8vIEJhc2VkIG9uIHdoaWNoLXBvbHlnb25cblxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L3doaWNoLXBvbHlnb24vYmxvYi8yZWI1YjhhNDI3ZDAxOGViZDk2NGMwNWFjZDNiOTE2NmM0NTU4YjJjL2luZGV4LmpzI0w4MVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50SW5Qb2x5Z29uKHBvaW50OiBQb3NpdGlvbiwgcmluZ3M6IFBvc2l0aW9uW11bXSkge1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuMiA9IHJpbmcubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gICAgICAgICAgICBpZiAocmF5SW50ZXJzZWN0KHBvaW50LCByaW5nW2pdLCByaW5nW2tdKSkge1xuICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuZnVuY3Rpb24gcmF5SW50ZXJzZWN0KHA6IFBvc2l0aW9uLCBwMTogUG9zaXRpb24sIHAyOiBQb3NpdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIHAxWzFdID4gcFsxXSAhPT0gcDJbMV0gPiBwWzFdICYmXG4gICAgcFswXSA8ICgocDJbMF0gLSBwMVswXSkgKiAocFsxXSAtIHAxWzFdKSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXVxuICAgICk7XG59XG4iLCIvLyBCYXNlZCBvbiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9tY2xhZXlzYi9nZW9qc29uLXBvbHlnb24tc2VsZi1pbnRlcnNlY3Rpb25zXG4vLyBNSVQgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2IE1hbnVlbCBDbGFleXMgQm91dWFlcnRcblxuaW1wb3J0IHsgRmVhdHVyZSwgTGluZVN0cmluZywgUG9seWdvbiwgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuLy8gaW1wb3J0ICogYXMgcmJ1c2ggZnJvbSBcInJidXNoXCI7XG5cbnR5cGUgU2VsZkludGVyc2VjdHNPcHRpb25zID0ge1xuICBlcHNpbG9uOiBudW1iZXI7XG4gIC8vIHJlcG9ydFZlcnRleE9uVmVydGV4OiBib29sZWFuO1xuICAvLyByZXBvcnRWZXJ0ZXhPbkVkZ2U6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VsZkludGVyc2VjdHMoXG4gICAgZmVhdHVyZTogRmVhdHVyZTxQb2x5Z29uPiB8IEZlYXR1cmU8TGluZVN0cmluZz5cbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9wdGlvbnM6IFNlbGZJbnRlcnNlY3RzT3B0aW9ucyA9IHtcbiAgICAgICAgZXBzaWxvbjogMCxcbiAgICAvLyByZXBvcnRWZXJ0ZXhPblZlcnRleDogZmFsc2UsXG4gICAgLy8gcmVwb3J0VmVydGV4T25FZGdlOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgbGV0IGNvb3JkOiBudW1iZXJbXVtdW107XG5cbiAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICBjb29yZCA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgIGNvb3JkID0gW2ZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGYgaW50ZXJzZWN0cyBvbmx5IGFjY2VwdHMgUG9seWdvbnMgYW5kIExpbmVTdHJpbmdzXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogbnVtYmVyW11bXSA9IFtdO1xuICAgIGNvbnN0IHNlZW46IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgICBmb3IgKGxldCByaW5nMCA9IDA7IHJpbmcwIDwgY29vcmQubGVuZ3RoOyByaW5nMCsrKSB7XG4gICAgICAgIGZvciAobGV0IGVkZ2UwID0gMDsgZWRnZTAgPCBjb29yZFtyaW5nMF0ubGVuZ3RoIC0gMTsgZWRnZTArKykge1xuICAgICAgICAgICAgZm9yIChsZXQgcmluZzEgPSAwOyByaW5nMSA8IGNvb3JkLmxlbmd0aDsgcmluZzErKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGVkZ2UxID0gMDsgZWRnZTEgPCBjb29yZFtyaW5nMV0ubGVuZ3RoIC0gMTsgZWRnZTErKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVlZHVwIHBvc3NpYmxlIGlmIG9ubHkgaW50ZXJlc3RlZCBpbiB1bmlxdWU6IHN0YXJ0IGxhc3QgdHdvIGxvb3BzIGF0IHJpbmcwIGFuZCBlZGdlMCsxXG4gICAgICAgICAgICAgICAgICAgIGlmSW50ZXJlc2N0aW9uQWRkVG9PdXRwdXQocmluZzAsIGVkZ2UwLCByaW5nMSwgZWRnZTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gMDtcblxuICAgIC8vIHRydWUgaWYgZnJhYyBpcyAoYWxtb3N0KSAxLjAgb3IgMC4wXG4gICAgLy8gZnVuY3Rpb24gaXNCb3VuZGFyeUNhc2UoZnJhYzogbnVtYmVyKSB7XG4gICAgLy8gICBjb25zdCBlMiA9IG9wdGlvbnMuZXBzaWxvbiAqIG9wdGlvbnMuZXBzaWxvbjtcbiAgICAvLyAgIHJldHVybiBlMiA+PSAoZnJhYyAtIDEpICogKGZyYWMgLSAxKSB8fCBlMiA+PSBmcmFjICogZnJhYztcbiAgICAvLyB9XG5cbiAgICBmdW5jdGlvbiBpc091dHNpZGUoZnJhYzogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmcmFjIDwgMCAtIG9wdGlvbnMuZXBzaWxvbiB8fCBmcmFjID4gMSArIG9wdGlvbnMuZXBzaWxvbjtcbiAgICB9XG4gICAgLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgdHdvIGVkZ2VzIGludGVyc2VjdCBhbmQgYWRkIHRoZSBpbnRlcnNlY3Rpb24gdG8gdGhlIG91dHB1dFxuICAgIGZ1bmN0aW9uIGlmSW50ZXJlc2N0aW9uQWRkVG9PdXRwdXQoXG4gICAgICAgIHJpbmcwOiBudW1iZXIsXG4gICAgICAgIGVkZ2UwOiBudW1iZXIsXG4gICAgICAgIHJpbmcxOiBudW1iZXIsXG4gICAgICAgIGVkZ2UxOiBudW1iZXJcbiAgICApIHtcbiAgICAgICAgY29uc3Qgc3RhcnQwID0gY29vcmRbcmluZzBdW2VkZ2UwXTtcbiAgICAgICAgY29uc3QgZW5kMCA9IGNvb3JkW3JpbmcwXVtlZGdlMCArIDFdO1xuICAgICAgICBjb25zdCBzdGFydDEgPSBjb29yZFtyaW5nMV1bZWRnZTFdO1xuICAgICAgICBjb25zdCBlbmQxID0gY29vcmRbcmluZzFdW2VkZ2UxICsgMV07XG5cbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0KHN0YXJ0MCwgZW5kMCwgc3RhcnQxLCBlbmQxKTtcblxuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGRpc2NhcmQgcGFyYWxsZWxzIGFuZCBjb2luY2lkZW5jZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZyYWMwO1xuICAgICAgICBsZXQgZnJhYzE7XG5cbiAgICAgICAgaWYgKGVuZDBbMF0gIT09IHN0YXJ0MFswXSkge1xuICAgICAgICAgICAgZnJhYzAgPSAoaW50ZXJzZWN0aW9uWzBdIC0gc3RhcnQwWzBdKSAvIChlbmQwWzBdIC0gc3RhcnQwWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWMwID0gKGludGVyc2VjdGlvblsxXSAtIHN0YXJ0MFsxXSkgLyAoZW5kMFsxXSAtIHN0YXJ0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZDFbMF0gIT09IHN0YXJ0MVswXSkge1xuICAgICAgICAgICAgZnJhYzEgPSAoaW50ZXJzZWN0aW9uWzBdIC0gc3RhcnQxWzBdKSAvIChlbmQxWzBdIC0gc3RhcnQxWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWMxID0gKGludGVyc2VjdGlvblsxXSAtIHN0YXJ0MVsxXSkgLyAoZW5kMVsxXSAtIHN0YXJ0MVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgcm91Z2hseSB0aHJlZSBjYXNlcyB3ZSBuZWVkIHRvIGRlYWwgd2l0aC5cbiAgICAgICAgLy8gMS4gSWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBmcmFjcyBsaWVzIG91dHNpZGUgWzAsMV0sIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbiAgICAgICAgaWYgKGlzT3V0c2lkZShmcmFjMCkgfHwgaXNPdXRzaWRlKGZyYWMxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyByZXF1aXJlIHNlZ21lbnQgaW50ZXJzZWN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBJZiBib3RoIGFyZSBlaXRoZXIgZXhhY3RseSAwIG9yIGV4YWN0bHkgMSwgdGhpcyBpcyBub3QgYW4gaW50ZXJzZWN0aW9uIGJ1dCBqdXN0XG4gICAgICAgIC8vIHR3byBlZGdlIHNlZ21lbnRzIHNoYXJpbmcgYSBjb21tb24gdmVydGV4LlxuICAgICAgICAvLyBpZiAoaXNCb3VuZGFyeUNhc2UoZnJhYzApICYmIGlzQm91bmRhcnlDYXNlKGZyYWMxKSkge1xuICAgICAgICAvLyAgIGlmICghb3B0aW9ucy5yZXBvcnRWZXJ0ZXhPblZlcnRleCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIDMuIElmIG9ubHkgb25lIG9mIHRoZSBmcmFjdGlvbnMgaXMgZXhhY3RseSAwIG9yIDEsIHRoaXMgaXNcbiAgICAgICAgLy8gLy8gYSB2ZXJ0ZXgtb24tZWRnZSBzaXR1YXRpb24uXG4gICAgICAgIC8vIGlmIChpc0JvdW5kYXJ5Q2FzZShmcmFjMCkgfHwgaXNCb3VuZGFyeUNhc2UoZnJhYzEpKSB7XG4gICAgICAgIC8vICAgaWYgKCFvcHRpb25zLnJlcG9ydFZlcnRleE9uRWRnZSkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGludGVyc2VjdGlvbi50b1N0cmluZygpO1xuICAgICAgICBjb25zdCB1bmlxdWUgPSAhc2VlbltrZXldO1xuICAgICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgICAgICBzZWVuW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2goaW50ZXJzZWN0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5MTogUG9zaXRpb24sIGFycmF5MjogUG9zaXRpb24pIHtcbiAgICByZXR1cm4gYXJyYXkxWzBdID09PSBhcnJheTJbMF0gJiYgYXJyYXkxWzFdID09PSBhcnJheTJbMV07XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNvbXB1dGUgd2hlcmUgdHdvIGxpbmVzIChub3Qgc2VnbWVudHMpIGludGVyc2VjdC4gRnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzbGluZV9pbnRlcnNlY3Rpb25cbmZ1bmN0aW9uIGludGVyc2VjdChcbiAgICBzdGFydDA6IFBvc2l0aW9uLFxuICAgIGVuZDA6IFBvc2l0aW9uLFxuICAgIHN0YXJ0MTogUG9zaXRpb24sXG4gICAgZW5kMTogUG9zaXRpb25cbikge1xuICAgIGlmIChcbiAgICAgICAgZXF1YWxBcnJheXMoc3RhcnQwLCBzdGFydDEpIHx8XG4gICAgZXF1YWxBcnJheXMoc3RhcnQwLCBlbmQxKSB8fFxuICAgIGVxdWFsQXJyYXlzKGVuZDAsIHN0YXJ0MSkgfHxcbiAgICBlcXVhbEFycmF5cyhlbmQxLCBzdGFydDEpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHgwID0gc3RhcnQwWzBdLFxuICAgICAgICB5MCA9IHN0YXJ0MFsxXSxcbiAgICAgICAgeDEgPSBlbmQwWzBdLFxuICAgICAgICB5MSA9IGVuZDBbMV0sXG4gICAgICAgIHgyID0gc3RhcnQxWzBdLFxuICAgICAgICB5MiA9IHN0YXJ0MVsxXSxcbiAgICAgICAgeDMgPSBlbmQxWzBdLFxuICAgICAgICB5MyA9IGVuZDFbMV07XG5cbiAgICBjb25zdCBkZW5vbSA9ICh4MCAtIHgxKSAqICh5MiAtIHkzKSAtICh5MCAtIHkxKSAqICh4MiAtIHgzKTtcbiAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeDQgPVxuICAgICgoeDAgKiB5MSAtIHkwICogeDEpICogKHgyIC0geDMpIC0gKHgwIC0geDEpICogKHgyICogeTMgLSB5MiAqIHgzKSkgLyBkZW5vbTtcblxuICAgIGNvbnN0IHk0ID1cbiAgICAoKHgwICogeTEgLSB5MCAqIHgxKSAqICh5MiAtIHkzKSAtICh5MCAtIHkxKSAqICh4MiAqIHkzIC0geTIgKiB4MykpIC8gZGVub207XG5cbiAgICByZXR1cm4gW3g0LCB5NF07XG59XG4iLCJpbXBvcnQgeyBGZWF0dXJlLCBMaW5lU3RyaW5nLCBQb2x5Z29uLCBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjZW50cm9pZChnZW9qc29uOiBGZWF0dXJlPFBvbHlnb24gfCBMaW5lU3RyaW5nPik6IFBvc2l0aW9uIHtcbiAgICBsZXQgeFN1bSA9IDA7XG4gICAgbGV0IHlTdW0gPSAwO1xuICAgIGxldCBsZW4gPSAwO1xuXG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPVxuICAgIGdlb2pzb24uZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCJcbiAgICAgICAgPyBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLnNsaWNlKDAsIC0xKVxuICAgICAgICA6IGdlb2pzb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKChjb29yZDogUG9zaXRpb24pID0+IHtcbiAgICAgICAgeFN1bSArPSBjb29yZFswXTtcbiAgICAgICAgeVN1bSArPSBjb29yZFsxXTtcbiAgICAgICAgbGVuKys7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gW3hTdW0gLyBsZW4sIHlTdW0gLyBsZW5dO1xufVxuIiwiaW1wb3J0IHsgUG9pbnQsIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IEpTT05PYmplY3QgfSBmcm9tIFwiLi4vc3RvcmUvc3RvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzQXNQb2ludHMoXG4gICAgc2VsZWN0ZWRDb29yZHM6IFBvc2l0aW9uW10sXG4gICAgZ2VvbWV0cnlUeXBlOiBcIlBvbHlnb25cIiB8IFwiTGluZVN0cmluZ1wiLFxuICAgIHByb3BlcnRpZXM6IChpbmRleDogbnVtYmVyKSA9PiBKU09OT2JqZWN0XG4pIHtcbiAgICBjb25zdCBzZWxlY3Rpb25Qb2ludHMgPSBbXTtcblxuICAgIC8vIFdlIGNhbiBza2lwIHRoZSBsYXN0IHBvaW50IGZvciBwb2x5Z29uc1xuICAgIC8vIGFzIGl0J3MgYSBkdXBsaWNhdGUgb2YgdGhlIGZpcnN0XG4gICAgY29uc3QgbGVuZ3RoID1cbiAgICBnZW9tZXRyeVR5cGUgPT09IFwiUG9seWdvblwiXG4gICAgICAgID8gc2VsZWN0ZWRDb29yZHMubGVuZ3RoIC0gMVxuICAgICAgICA6IHNlbGVjdGVkQ29vcmRzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZWN0aW9uUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHNlbGVjdGVkQ29vcmRzW2ldLFxuICAgICAgICAgICAgfSBhcyBQb2ludCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMoaSksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb25Qb2ludHM7XG59XG4iLCJpbXBvcnQgeyBQb2ludCwgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHsgSlNPTk9iamVjdCB9IGZyb20gXCIuLi9zdG9yZS9zdG9yZVwiO1xuaW1wb3J0IHsgbWlkcG9pbnRDb29yZGluYXRlIH0gZnJvbSBcIi4vbWlkcG9pbnQtY29vcmRpbmF0ZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkUG9pbnRDb29yZGluYXRlcyhcbiAgICBmZWF0dXJlQ29vcmRzOiBQb3NpdGlvbltdLFxuICAgIHByZWNpc2lvbjogbnVtYmVyXG4pIHtcbiAgICBjb25zdCBtaWRQb2ludENvb3JkczogUG9zaXRpb25bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHVyZUNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWlkID0gbWlkcG9pbnRDb29yZGluYXRlKFxuICAgICAgICAgICAgZmVhdHVyZUNvb3Jkc1tpXSxcbiAgICAgICAgICAgIGZlYXR1cmVDb29yZHNbaSArIDFdLFxuICAgICAgICAgICAgcHJlY2lzaW9uXG4gICAgICAgICk7XG4gICAgICAgIG1pZFBvaW50Q29vcmRzLnB1c2gobWlkKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pZFBvaW50Q29vcmRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkUG9pbnRzKFxuICAgIHNlbGVjdGVkQ29vcmRzOiBQb3NpdGlvbltdLFxuICAgIHByb3BlcnRpZXM6IChpbmRleDogbnVtYmVyKSA9PiBKU09OT2JqZWN0LFxuICAgIHByZWNpc2lvbjogbnVtYmVyXG4pIHtcbiAgICByZXR1cm4gZ2V0TWlkUG9pbnRDb29yZGluYXRlcyhzZWxlY3RlZENvb3JkcywgcHJlY2lzaW9uKS5tYXAoKGNvb3JkLCBpKSA9PiAoe1xuICAgICAgICBnZW9tZXRyeTogeyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBjb29yZCB9IGFzIFBvaW50LFxuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzKGkpLFxuICAgIH0pKTtcbn1cbiIsImV4cG9ydCBjb25zdCBlYXJ0aFJhZGl1cyA9IDYzNzEwMDguODtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCByYWRpYW5zID0gZGVncmVlcyAlIDM2MDtcbiAgICByZXR1cm4gKHJhZGlhbnMgKiBNYXRoLlBJKSAvIDE4MDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBmYWN0b3IgPSBlYXJ0aFJhZGl1cyAvIDEwMDA7XG4gICAgcmV0dXJuIGRpc3RhbmNlIC8gZmFjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zICUgKDIgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gKGRlZ3JlZXMgKiAxODApIC8gTWF0aC5QSTtcbn1cbiIsImltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcblxuXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZXNJZGVudGljYWwoY29vcmRpbmF0ZTogUG9zaXRpb24sIGNvb3JkaW5hdGVUd286IFBvc2l0aW9uKSB7XG4gICAgY29uc29sZS5sb2coXCJwcm90ZWNlZD9cIiwgY29vcmRpbmF0ZVswXSA9PT0gY29vcmRpbmF0ZVR3b1swXSAmJiBjb29yZGluYXRlWzFdID09PSBjb29yZGluYXRlVHdvWzFdKVxuICAgIHJldHVybiBjb29yZGluYXRlWzBdID09PSBjb29yZGluYXRlVHdvWzBdICYmIGNvb3JkaW5hdGVbMV0gPT09IGNvb3JkaW5hdGVUd29bMV1cbn0iLCJleHBvcnQgZnVuY3Rpb24gbGltaXRQcmVjaXNpb24obnVtOiBudW1iZXIsIGRlY2ltYWxMaW1pdCA9IDkpIHtcbiAgICBjb25zdCBkZWNpbWFscyA9IE1hdGgucG93KDEwLCBkZWNpbWFsTGltaXQpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIGRlY2ltYWxzKSAvIGRlY2ltYWxzO1xufVxuIiwiaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZXJzaW5lRGlzdGFuY2VLaWxvbWV0ZXJzKFxuICAgIHBvaW50T25lOiBQb3NpdGlvbixcbiAgICBwb2ludFR3bzogUG9zaXRpb25cbikge1xuICAgIGNvbnN0IHRvUmFkaWFucyA9IChsYXRPckxuZzogbnVtYmVyKSA9PiAobGF0T3JMbmcgKiBNYXRoLlBJKSAvIDE4MDtcblxuICAgIGNvbnN0IHBoaU9uZSA9IHRvUmFkaWFucyhwb2ludE9uZVsxXSk7XG4gICAgY29uc3QgbGFtYmRhT25lID0gdG9SYWRpYW5zKHBvaW50T25lWzBdKTtcbiAgICBjb25zdCBwaGlUd28gPSB0b1JhZGlhbnMocG9pbnRUd29bMV0pO1xuICAgIGNvbnN0IGxhbWJkYVR3byA9IHRvUmFkaWFucyhwb2ludFR3b1swXSk7XG4gICAgY29uc3QgZGVsdGFQaGkgPSBwaGlUd28gLSBwaGlPbmU7XG4gICAgY29uc3QgZGVsdGFsYW1iZGEgPSBsYW1iZGFUd28gLSBsYW1iZGFPbmU7XG5cbiAgICBjb25zdCBhID1cbiAgICBNYXRoLnNpbihkZWx0YVBoaSAvIDIpICogTWF0aC5zaW4oZGVsdGFQaGkgLyAyKSArXG4gICAgTWF0aC5jb3MocGhpT25lKSAqXG4gICAgICBNYXRoLmNvcyhwaGlUd28pICpcbiAgICAgIE1hdGguc2luKGRlbHRhbGFtYmRhIC8gMikgKlxuICAgICAgTWF0aC5zaW4oZGVsdGFsYW1iZGEgLyAyKTtcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcblxuICAgIGNvbnN0IHJhZGl1cyA9IDYzNzFlMztcbiAgICBjb25zdCBkaXN0YW5jZSA9IHJhZGl1cyAqIGM7XG5cbiAgICByZXR1cm4gZGlzdGFuY2UgLyAxMDAwO1xufVxuIiwiZXhwb3J0IGNvbnN0IHBpeGVsRGlzdGFuY2VUb0xpbmUgPSAoXG4gICAgcG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSxcbiAgICBsaW5lUG9pbnRPbmU6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSxcbiAgICBsaW5lUG9pbnRUd286IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuKSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlID0gKHg6IG51bWJlcikgPT4ge1xuICAgICAgICByZXR1cm4geCAqIHg7XG4gICAgfTtcbiAgICBjb25zdCBkaXN0MiA9ICh2OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0sIHc6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSkgPT4ge1xuICAgICAgICByZXR1cm4gc3F1YXJlKHYueCAtIHcueCkgKyBzcXVhcmUodi55IC0gdy55KTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3RUb1NlZ21lbnRTcXVhcmVkID0gKFxuICAgICAgICBwOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0sXG4gICAgICAgIHY6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSxcbiAgICAgICAgdzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IGwyID0gZGlzdDIodiwgdyk7XG5cbiAgICAgICAgaWYgKGwyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzdDIocCwgdik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdCA9ICgocC54IC0gdi54KSAqICh3LnggLSB2LngpICsgKHAueSAtIHYueSkgKiAody55IC0gdi55KSkgLyBsMjtcbiAgICAgICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcblxuICAgICAgICByZXR1cm4gZGlzdDIocCwgeyB4OiB2LnggKyB0ICogKHcueCAtIHYueCksIHk6IHYueSArIHQgKiAody55IC0gdi55KSB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hdGguc3FydChkaXN0VG9TZWdtZW50U3F1YXJlZChwb2ludCwgbGluZVBvaW50T25lLCBsaW5lUG9pbnRUd28pKTtcbn07XG4iLCJleHBvcnQgY29uc3QgcGl4ZWxEaXN0YW5jZSA9IChcbiAgICBwb2ludE9uZTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9LFxuICAgIHBvaW50VHdvOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbikgPT4ge1xuICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBwb2ludE9uZTtcbiAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gcG9pbnRUd287XG4gICAgY29uc3QgeSA9IHgyIC0geDE7XG4gICAgY29uc3QgeCA9IHkyIC0geTE7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn07XG4iLCJpbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBkZWdyZWVzVG9SYWRpYW5zLCByYWRpYW5zVG9EZWdyZWVzIH0gZnJvbSBcIi4uL2hlbHBlcnNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJodW1iQmVhcmluZyhzdGFydDogUG9zaXRpb24sIGVuZDogUG9zaXRpb24pOiBudW1iZXIge1xuICAgIGNvbnN0IGZyb20gPSBzdGFydDtcbiAgICBjb25zdCB0byA9IGVuZDtcblxuICAgIC8vIM+GID0+IHBoaVxuICAgIC8vIM6UzrsgPT4gZGVsdGFMYW1iZGFcbiAgICAvLyDOlM+IID0+IGRlbHRhUHNpXG4gICAgLy8gzrggPT4gdGhldGFcbiAgICBjb25zdCBwaGkxID0gZGVncmVlc1RvUmFkaWFucyhmcm9tWzFdKTtcbiAgICBjb25zdCBwaGkyID0gZGVncmVlc1RvUmFkaWFucyh0b1sxXSk7XG4gICAgbGV0IGRlbHRhTGFtYmRhID0gZGVncmVlc1RvUmFkaWFucyh0b1swXSAtIGZyb21bMF0pO1xuXG4gICAgLy8gaWYgZGVsdGFMYW1iZGFvbiBvdmVyIDE4MMKwIHRha2Ugc2hvcnRlciByaHVtYiBsaW5lIGFjcm9zcyB0aGUgYW50aS1tZXJpZGlhbjpcbiAgICBpZiAoZGVsdGFMYW1iZGEgPiBNYXRoLlBJKSB7XG4gICAgICAgIGRlbHRhTGFtYmRhIC09IDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAoZGVsdGFMYW1iZGEgPCAtTWF0aC5QSSkge1xuICAgICAgICBkZWx0YUxhbWJkYSArPSAyICogTWF0aC5QSTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YVBzaSA9IE1hdGgubG9nKFxuICAgICAgICBNYXRoLnRhbihwaGkyIC8gMiArIE1hdGguUEkgLyA0KSAvIE1hdGgudGFuKHBoaTEgLyAyICsgTWF0aC5QSSAvIDQpXG4gICAgKTtcblxuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihkZWx0YUxhbWJkYSwgZGVsdGFQc2kpO1xuXG4gICAgY29uc3QgYmVhcjM2MCA9IChyYWRpYW5zVG9EZWdyZWVzKHRoZXRhKSArIDM2MCkgJSAzNjA7XG5cbiAgICBjb25zdCBiZWFyMTgwID0gYmVhcjM2MCA+IDE4MCA/IC0oMzYwIC0gYmVhcjM2MCkgOiBiZWFyMzYwO1xuXG4gICAgcmV0dXJuIGJlYXIxODA7XG59XG4iLCJpbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBkZWdyZWVzVG9SYWRpYW5zLCByYWRpYW5zVG9EZWdyZWVzLCBlYXJ0aFJhZGl1cyB9IGZyb20gXCIuLi9oZWxwZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByaHVtYkRlc3RpbmF0aW9uKFxuICAgIG9yaWdpbjogUG9zaXRpb24sXG4gICAgZGlzdGFuY2VNZXRlcnM6IG51bWJlcixcbiAgICBiZWFyaW5nOiBudW1iZXJcbik6IFBvc2l0aW9uIHtcbiAgICBjb25zdCB3YXNOZWdhdGl2ZURpc3RhbmNlID0gZGlzdGFuY2VNZXRlcnMgPCAwO1xuICAgIGxldCBkaXN0YW5jZUluTWV0ZXJzID0gZGlzdGFuY2VNZXRlcnM7XG5cbiAgICBpZiAod2FzTmVnYXRpdmVEaXN0YW5jZSkge1xuICAgICAgICBkaXN0YW5jZUluTWV0ZXJzID0gLU1hdGguYWJzKGRpc3RhbmNlSW5NZXRlcnMpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gZGlzdGFuY2VNZXRlcnMgLyBlYXJ0aFJhZGl1czsgLy8gYW5ndWxhciBkaXN0YW5jZSBpbiByYWRpYW5zXG4gICAgY29uc3QgbGFtYmRhMSA9IChvcmlnaW5bMF0gKiBNYXRoLlBJKSAvIDE4MDsgLy8gdG8gcmFkaWFucywgYnV0IHdpdGhvdXQgbm9ybWFsaXplIHRvIPCdnItcbiAgICBjb25zdCBwaGkxID0gZGVncmVlc1RvUmFkaWFucyhvcmlnaW5bMV0pO1xuICAgIGNvbnN0IHRoZXRhID0gZGVncmVlc1RvUmFkaWFucyhiZWFyaW5nKTtcblxuICAgIGNvbnN0IERlbHRhUGhpID0gZGVsdGEgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgbGV0IHBoaTIgPSBwaGkxICsgRGVsdGFQaGk7XG5cbiAgICAvLyBjaGVjayBmb3IgZ29pbmcgcGFzdCB0aGUgcG9sZSwgbm9ybWFsaXNlIGxhdGl0dWRlIGlmIHNvXG4gICAgaWYgKE1hdGguYWJzKHBoaTIpID4gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgcGhpMiA9IHBoaTIgPiAwID8gTWF0aC5QSSAtIHBoaTIgOiAtTWF0aC5QSSAtIHBoaTI7XG4gICAgfVxuXG4gICAgY29uc3QgRGVsdGFQc2kgPSBNYXRoLmxvZyhcbiAgICAgICAgTWF0aC50YW4ocGhpMiAvIDIgKyBNYXRoLlBJIC8gNCkgLyBNYXRoLnRhbihwaGkxIC8gMiArIE1hdGguUEkgLyA0KVxuICAgICk7XG4gICAgLy8gRS1XIGNvdXJzZSBiZWNvbWVzIGlsbC1jb25kaXRpb25lZCB3aXRoIDAvMFxuICAgIGNvbnN0IHEgPSBNYXRoLmFicyhEZWx0YVBzaSkgPiAxMGUtMTIgPyBEZWx0YVBoaSAvIERlbHRhUHNpIDogTWF0aC5jb3MocGhpMSk7XG5cbiAgICBjb25zdCBEZWx0YUxhbWJkYSA9IChkZWx0YSAqIE1hdGguc2luKHRoZXRhKSkgLyBxO1xuICAgIGNvbnN0IGxhbWJkYTIgPSBsYW1iZGExICsgRGVsdGFMYW1iZGE7XG5cbiAgICAvLyBub3JtYWxpc2UgdG8g4oiSMTgwLi4rMTgwwrBcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IFtcbiAgICAgICAgKCgobGFtYmRhMiAqIDE4MCkgLyBNYXRoLlBJICsgNTQwKSAlIDM2MCkgLSAxODAsXG4gICAgICAgIChwaGkyICogMTgwKSAvIE1hdGguUEksXG4gICAgXTtcblxuICAgIC8vIGNvbXBlbnNhdGUgdGhlIGNyb3NzaW5nIG9mIHRoZSAxODB0aCBtZXJpZGlhbiAoaHR0cHM6Ly9tYWN3cmlnaHQub3JnLzIwMTYvMDkvMjYvdGhlLTE4MHRoLW1lcmlkaWFuLmh0bWwpXG4gICAgLy8gc29sdXRpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMzI1MCNpc3N1ZWNvbW1lbnQtMjk0ODg3Njc4XG4gICAgZGVzdGluYXRpb25bMF0gKz1cbiAgICBkZXN0aW5hdGlvblswXSAtIG9yaWdpblswXSA+IDE4MFxuICAgICAgICA/IC0zNjBcbiAgICAgICAgOiBvcmlnaW5bMF0gLSBkZXN0aW5hdGlvblswXSA+IDE4MFxuICAgICAgICAgICAgPyAzNjBcbiAgICAgICAgICAgIDogMDtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG4iLCJpbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBlYXJ0aFJhZGl1cyB9IGZyb20gXCIuLi9oZWxwZXJzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiByaHVtYkRpc3RhbmNlKGRlc3RpbmF0aW9uOiBQb3NpdGlvbiwgb3JpZ2luOiBQb3NpdGlvbik6IG51bWJlciB7XG4gICAgLy8gY29tcGVuc2F0ZSB0aGUgY3Jvc3Npbmcgb2YgdGhlIDE4MHRoIG1lcmlkaWFuIChodHRwczovL21hY3dyaWdodC5vcmcvMjAxNi8wOS8yNi90aGUtMTgwdGgtbWVyaWRpYW4uaHRtbClcbiAgICAvLyBzb2x1dGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8zMjUwI2lzc3VlY29tbWVudC0yOTQ4ODc2NzhcbiAgICBkZXN0aW5hdGlvblswXSArPVxuICAgIGRlc3RpbmF0aW9uWzBdIC0gb3JpZ2luWzBdID4gMTgwXG4gICAgICAgID8gLTM2MFxuICAgICAgICA6IG9yaWdpblswXSAtIGRlc3RpbmF0aW9uWzBdID4gMTgwXG4gICAgICAgICAgICA/IDM2MFxuICAgICAgICAgICAgOiAwO1xuXG4gICAgLy8gc2VlIHd3dy5lZHdpbGxpYW1zLm9yZy9hdmZvcm0uaHRtI1JodW1iXG5cbiAgICBjb25zdCBSID0gZWFydGhSYWRpdXM7XG4gICAgY29uc3QgcGhpMSA9IChvcmlnaW5bMV0gKiBNYXRoLlBJKSAvIDE4MDtcbiAgICBjb25zdCBwaGkyID0gKGRlc3RpbmF0aW9uWzFdICogTWF0aC5QSSkgLyAxODA7XG4gICAgY29uc3QgRGVsdGFQaGkgPSBwaGkyIC0gcGhpMTtcbiAgICBsZXQgRGVsdGFMYW1iZGEgPSAoTWF0aC5hYnMoZGVzdGluYXRpb25bMF0gLSBvcmlnaW5bMF0pICogTWF0aC5QSSkgLyAxODA7XG5cbiAgICAvLyBpZiBkTG9uIG92ZXIgMTgwwrAgdGFrZSBzaG9ydGVyIHJodW1iIGxpbmUgYWNyb3NzIHRoZSBhbnRpLW1lcmlkaWFuOlxuICAgIGlmIChEZWx0YUxhbWJkYSA+IE1hdGguUEkpIHtcbiAgICAgICAgRGVsdGFMYW1iZGEgLT0gMiAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgLy8gb24gTWVyY2F0b3IgcHJvamVjdGlvbiwgbG9uZ2l0dWRlIGRpc3RhbmNlcyBzaHJpbmsgYnkgbGF0aXR1ZGU7IHEgaXMgdGhlICdzdHJldGNoIGZhY3RvcidcbiAgICAvLyBxIGJlY29tZXMgaWxsLWNvbmRpdGlvbmVkIGFsb25nIEUtVyBsaW5lICgwLzApOyB1c2UgZW1waXJpY2FsIHRvbGVyYW5jZSB0byBhdm9pZCBpdFxuICAgIGNvbnN0IERlbHRhUHNpID0gTWF0aC5sb2coXG4gICAgICAgIE1hdGgudGFuKHBoaTIgLyAyICsgTWF0aC5QSSAvIDQpIC8gTWF0aC50YW4ocGhpMSAvIDIgKyBNYXRoLlBJIC8gNClcbiAgICApO1xuICAgIGNvbnN0IHEgPSBNYXRoLmFicyhEZWx0YVBzaSkgPiAxMGUtMTIgPyBEZWx0YVBoaSAvIERlbHRhUHNpIDogTWF0aC5jb3MocGhpMSk7XG5cbiAgICAvLyBkaXN0YW5jZSBpcyBweXRoYWdvcmFzIG9uICdzdHJldGNoZWQnIE1lcmNhdG9yIHByb2plY3Rpb25cbiAgICBjb25zdCBkZWx0YSA9IE1hdGguc3FydChcbiAgICAgICAgRGVsdGFQaGkgKiBEZWx0YVBoaSArIHEgKiBxICogRGVsdGFMYW1iZGEgKiBEZWx0YUxhbWJkYVxuICAgICk7IC8vIGFuZ3VsYXIgZGlzdGFuY2UgaW4gcmFkaWFuc1xuXG4gICAgY29uc3QgZGlzdGFuY2VNZXRlcnMgPSBkZWx0YSAqIFI7XG5cbiAgICByZXR1cm4gZGlzdGFuY2VNZXRlcnM7XG59XG4iLCJpbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBkZXN0aW5hdGlvbiB9IGZyb20gXCIuL3NoYXBlL2NyZWF0ZS1jaXJjbGVcIjtcbmltcG9ydCB7IGRlZ3JlZXNUb1JhZGlhbnMsIHJhZGlhbnNUb0RlZ3JlZXMgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgeyBsaW1pdFByZWNpc2lvbiB9IGZyb20gXCIuL2xpbWl0LWRlY2ltYWwtcHJlY2lzaW9uXCI7XG5pbXBvcnQgeyBoYXZlcnNpbmVEaXN0YW5jZUtpbG9tZXRlcnMgfSBmcm9tIFwiLi9tZWFzdXJlL2hhdmVyc2luZS1kaXN0YW5jZVwiO1xuXG5mdW5jdGlvbiBiZWFyaW5nKGNvb3JkaW5hdGVzMTogUG9zaXRpb24sIGNvb3JkaW5hdGVzMjogUG9zaXRpb24pIHtcbiAgICBjb25zdCBsb24xID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczFbMF0pO1xuICAgIGNvbnN0IGxvbjIgPSBkZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMlswXSk7XG4gICAgY29uc3QgbGF0MSA9IGRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICBjb25zdCBsYXQyID0gZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMV0pO1xuICAgIGNvbnN0IGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgICBjb25zdCBiID1cbiAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxhdDIpIC1cbiAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuXG4gICAgcmV0dXJuIHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hdGFuMihhLCBiKSk7XG59XG5cbi8vIEJhc2VkIG9uIHR1cmYtbWlkcG9pbnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9UdXJmanMvdHVyZi90cmVlL21hc3Rlci9wYWNrYWdlcy90dXJmLW1pZHBvaW50XG5cbmV4cG9ydCBmdW5jdGlvbiBtaWRwb2ludENvb3JkaW5hdGUoXG4gICAgY29vcmRpbmF0ZXMxOiBQb3NpdGlvbixcbiAgICBjb29yZGluYXRlczI6IFBvc2l0aW9uLFxuICAgIHByZWNpc2lvbjogbnVtYmVyXG4pIHtcbiAgICBjb25zdCBkaXN0ID0gaGF2ZXJzaW5lRGlzdGFuY2VLaWxvbWV0ZXJzKGNvb3JkaW5hdGVzMSwgY29vcmRpbmF0ZXMyKTtcbiAgICBjb25zdCBoZWFkaW5nID0gYmVhcmluZyhjb29yZGluYXRlczEsIGNvb3JkaW5hdGVzMik7XG4gICAgY29uc3QgbWlkcG9pbnQgPSBkZXN0aW5hdGlvbihjb29yZGluYXRlczEsIGRpc3QgLyAyLCBoZWFkaW5nKTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGxpbWl0UHJlY2lzaW9uKG1pZHBvaW50WzBdLCBwcmVjaXNpb24pLFxuICAgICAgICBsaW1pdFByZWNpc2lvbihtaWRwb2ludFsxXSwgcHJlY2lzaW9uKSxcbiAgICBdO1xufVxuIiwiaW1wb3J0IHsgRmVhdHVyZSwgUG9seWdvbiwgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHtcbiAgICBkZWdyZWVzVG9SYWRpYW5zLFxuICAgIGxlbmd0aFRvUmFkaWFucyxcbiAgICByYWRpYW5zVG9EZWdyZWVzLFxufSBmcm9tIFwiLi4vaGVscGVyc1wiO1xuXG4vLyBCYXNlZCBvbiBUdXJmLmpzIENpcmNsZSBtb2R1bGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9UdXJmanMvdHVyZi9ibG9iL21hc3Rlci9wYWNrYWdlcy90dXJmLWNpcmNsZS9pbmRleC50c1xuXG5leHBvcnQgZnVuY3Rpb24gZGVzdGluYXRpb24oXG4gICAgb3JpZ2luOiBQb3NpdGlvbixcbiAgICBkaXN0YW5jZTogbnVtYmVyLFxuICAgIGJlYXJpbmc6IG51bWJlclxuKTogUG9zaXRpb24ge1xuICAgIGNvbnN0IGxvbmdpdHVkZTEgPSBkZWdyZWVzVG9SYWRpYW5zKG9yaWdpblswXSk7XG4gICAgY29uc3QgbGF0aXR1ZGUxID0gZGVncmVlc1RvUmFkaWFucyhvcmlnaW5bMV0pO1xuICAgIGNvbnN0IGJlYXJpbmdSYWQgPSBkZWdyZWVzVG9SYWRpYW5zKGJlYXJpbmcpO1xuICAgIGNvbnN0IHJhZGlhbnMgPSBsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UpO1xuXG4gICAgLy8gTWFpblxuICAgIGNvbnN0IGxhdGl0dWRlMiA9IE1hdGguYXNpbihcbiAgICAgICAgTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguY29zKHJhZGlhbnMpICtcbiAgICAgIE1hdGguY29zKGxhdGl0dWRlMSkgKiBNYXRoLnNpbihyYWRpYW5zKSAqIE1hdGguY29zKGJlYXJpbmdSYWQpXG4gICAgKTtcbiAgICBjb25zdCBsb25naXR1ZGUyID1cbiAgICBsb25naXR1ZGUxICtcbiAgICBNYXRoLmF0YW4yKFxuICAgICAgICBNYXRoLnNpbihiZWFyaW5nUmFkKSAqIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MobGF0aXR1ZGUxKSxcbiAgICAgICAgTWF0aC5jb3MocmFkaWFucykgLSBNYXRoLnNpbihsYXRpdHVkZTEpICogTWF0aC5zaW4obGF0aXR1ZGUyKVxuICAgICk7XG4gICAgY29uc3QgbG5nID0gcmFkaWFuc1RvRGVncmVlcyhsb25naXR1ZGUyKTtcbiAgICBjb25zdCBsYXQgPSByYWRpYW5zVG9EZWdyZWVzKGxhdGl0dWRlMik7XG5cbiAgICByZXR1cm4gW2xuZywgbGF0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShvcHRpb25zOiB7XG4gIGNlbnRlcjogUG9zaXRpb247XG4gIHJhZGl1c0tpbG9tZXRlcnM6IG51bWJlcjtcbiAgc3RlcHM/OiBudW1iZXI7XG59KTogRmVhdHVyZTxQb2x5Z29uPiB7XG4gICAgY29uc3QgeyBjZW50ZXIsIHJhZGl1c0tpbG9tZXRlcnMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3RlcHMgPSBvcHRpb25zLnN0ZXBzID8gb3B0aW9ucy5zdGVwcyA6IDY0O1xuXG4gICAgY29uc3QgY29vcmRpbmF0ZXM6IFBvc2l0aW9uW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChkZXN0aW5hdGlvbihjZW50ZXIsIHJhZGl1c0tpbG9tZXRlcnMsIChpICogLTM2MCkgLyBzdGVwcykpO1xuICAgIH1cbiAgICBjb29yZGluYXRlcy5wdXNoKGNvb3JkaW5hdGVzWzBdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeTogeyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtjb29yZGluYXRlc10gfSxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgfTtcbn1cbiIsImltcG9ydCB7IEZlYXR1cmUsIExpbmVTdHJpbmcsIFBvbHlnb24sIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IGNlbnRyb2lkIH0gZnJvbSBcIi4uL2NlbnRyb2lkXCI7XG5pbXBvcnQgeyByaHVtYkJlYXJpbmcgfSBmcm9tIFwiLi4vbWVhc3VyZS9yaHVtYi1iZWFyaW5nXCI7XG5pbXBvcnQgeyByaHVtYkRlc3RpbmF0aW9uIH0gZnJvbSBcIi4uL21lYXN1cmUvcmh1bWItZGVzdGluYXRpb25cIjtcbmltcG9ydCB7IHJodW1iRGlzdGFuY2UgfSBmcm9tIFwiLi4vbWVhc3VyZS9yaHVtYi1kaXN0YW5jZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKFxuICAgIGdlb2pzb246IEZlYXR1cmU8UG9seWdvbiB8IExpbmVTdHJpbmc+LFxuICAgIGFuZ2xlOiBudW1iZXJcbikge1xuICAgIC8vIFNob3J0Y3V0IG5vLXJvdGF0aW9uXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBnZW9qc29uO1xuICAgIH1cblxuICAgIC8vIFVzZSBjZW50cm9pZCBvZiBHZW9KU09OIGlmIHBpdm90IGlzIG5vdCBwcm92aWRlZFxuICAgIGNvbnN0IHBpdm90ID0gY2VudHJvaWQoZ2VvanNvbik7XG5cbiAgICBjb25zdCBjb29vcmRpbmF0ZXMgPVxuICAgIGdlb2pzb24uZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCJcbiAgICAgICAgPyBnZW9qc29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdXG4gICAgICAgIDogZ2VvanNvbi5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgIGNvb29yZGluYXRlcy5mb3JFYWNoKChwb2ludENvb3JkczogUG9zaXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgaW5pdGlhbEFuZ2xlID0gcmh1bWJCZWFyaW5nKHBpdm90LCBwb2ludENvb3Jkcyk7XG4gICAgICAgIGNvbnN0IGZpbmFsQW5nbGUgPSBpbml0aWFsQW5nbGUgKyBhbmdsZTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSByaHVtYkRpc3RhbmNlKHBpdm90LCBwb2ludENvb3Jkcyk7XG4gICAgICAgIGNvbnN0IG5ld0Nvb3JkcyA9IHJodW1iRGVzdGluYXRpb24ocGl2b3QsIGRpc3RhbmNlLCBmaW5hbEFuZ2xlKTtcbiAgICAgICAgcG9pbnRDb29yZHNbMF0gPSBuZXdDb29yZHNbMF07XG4gICAgICAgIHBvaW50Q29vcmRzWzFdID0gbmV3Q29vcmRzWzFdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdlb2pzb247XG59XG4iLCJpbXBvcnQgeyBGZWF0dXJlLCBMaW5lU3RyaW5nLCBQb2x5Z29uLCBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBjZW50cm9pZCB9IGZyb20gXCIuLi9jZW50cm9pZFwiO1xuaW1wb3J0IHsgcmh1bWJCZWFyaW5nIH0gZnJvbSBcIi4uL21lYXN1cmUvcmh1bWItYmVhcmluZ1wiO1xuaW1wb3J0IHsgcmh1bWJEZXN0aW5hdGlvbiB9IGZyb20gXCIuLi9tZWFzdXJlL3JodW1iLWRlc3RpbmF0aW9uXCI7XG5pbXBvcnQgeyByaHVtYkRpc3RhbmNlIH0gZnJvbSBcIi4uL21lYXN1cmUvcmh1bWItZGlzdGFuY2VcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVNjYWxlKFxuICAgIGZlYXR1cmU6IEZlYXR1cmU8UG9seWdvbiB8IExpbmVTdHJpbmc+LFxuICAgIGZhY3RvcjogbnVtYmVyXG4pIHtcbiAgICAvLyBTaG9ydGN1dCBuby1zY2FsaW5nXG4gICAgaWYgKGZhY3RvciA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnaW4gPSBjZW50cm9pZChmZWF0dXJlKTtcblxuICAgIGNvbnN0IGNvb29yZGluYXRlcyA9XG4gICAgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIlxuICAgICAgICA/IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1cbiAgICAgICAgOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgY29vb3JkaW5hdGVzLmZvckVhY2goKHBvaW50Q29vcmRzOiBQb3NpdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbERpc3RhbmNlID0gcmh1bWJEaXN0YW5jZShvcmlnaW4sIHBvaW50Q29vcmRzKTtcbiAgICAgICAgY29uc3QgYmVhcmluZyA9IHJodW1iQmVhcmluZyhvcmlnaW4sIHBvaW50Q29vcmRzKTtcbiAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBvcmlnaW5hbERpc3RhbmNlICogZmFjdG9yO1xuICAgICAgICBjb25zdCBuZXdDb29yZCA9IHJodW1iRGVzdGluYXRpb24ob3JpZ2luLCBuZXdEaXN0YW5jZSwgYmVhcmluZyk7XG4gICAgICAgIHBvaW50Q29vcmRzWzBdID0gbmV3Q29vcmRbMF07XG4gICAgICAgIHBvaW50Q29vcmRzWzFdID0gbmV3Q29vcmRbMV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cbiIsImltcG9ydCB7IFByb2plY3QsIFVucHJvamVjdCB9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IEdlb0pTT05TdG9yZSB9IGZyb20gXCIuLi9zdG9yZS9zdG9yZVwiO1xuXG5leHBvcnQgdHlwZSBCZWhhdmlvckNvbmZpZyA9IHtcbiAgc3RvcmU6IEdlb0pTT05TdG9yZTtcbiAgbW9kZTogc3RyaW5nO1xuICBwcm9qZWN0OiBQcm9qZWN0O1xuICB1bnByb2plY3Q6IFVucHJvamVjdDtcbiAgcG9pbnRlckRpc3RhbmNlOiBudW1iZXI7XG4gIGNvb3JkaW5hdGVQcmVjaXNpb246IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBUZXJyYURyYXdNb2RlQmVoYXZpb3Ige1xuICAgIHByb3RlY3RlZCBzdG9yZTogR2VvSlNPTlN0b3JlO1xuICAgIHByb3RlY3RlZCBtb2RlOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHByb2plY3Q6IFByb2plY3Q7XG4gICAgcHJvdGVjdGVkIHVucHJvamVjdDogVW5wcm9qZWN0O1xuICAgIHByb3RlY3RlZCBwb2ludGVyRGlzdGFuY2U6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgY29vcmRpbmF0ZVByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBzdG9yZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgcHJvamVjdCxcbiAgICAgICAgdW5wcm9qZWN0LFxuICAgICAgICBwb2ludGVyRGlzdGFuY2UsXG4gICAgICAgIGNvb3JkaW5hdGVQcmVjaXNpb24sXG4gICAgfTogQmVoYXZpb3JDb25maWcpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnVucHJvamVjdCA9IHVucHJvamVjdDtcbiAgICAgICAgdGhpcy5wb2ludGVyRGlzdGFuY2UgPSBwb2ludGVyRGlzdGFuY2U7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZVByZWNpc2lvbiA9IGNvb3JkaW5hdGVQcmVjaXNpb247XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQmVoYXZpb3JDb25maWcsIFRlcnJhRHJhd01vZGVCZWhhdmlvciB9IGZyb20gXCIuL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7XG4gICAgVGVycmFEcmF3QWRhcHRlclN0eWxpbmcsXG4gICAgVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnLFxuICAgIFRlcnJhRHJhd01vZGVTdGF0ZSxcbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHsgR2VvSlNPTlN0b3JlIH0gZnJvbSBcIi4uL3N0b3JlL3N0b3JlXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0U3R5bGluZyB9IGZyb20gXCIuLi91dGlsL3N0eWxpbmdcIjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB7XG4gICAgX3N0YXRlOiBUZXJyYURyYXdNb2RlU3RhdGU7XG4gICAgX3N0eWxpbmc6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nO1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBzZXQgc3RhdGUoXykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIHRoZSBtb2RlcyBsaWZlY3ljbGUgbWV0aG9kc1wiKTtcbiAgICB9XG5cbiAgICBnZXQgc3R5bGluZygpOiBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsaW5nO1xuICAgIH1cbiAgICBzZXQgc3R5bGluZyhzdHlsaW5nOiBUZXJyYURyYXdBZGFwdGVyU3R5bGluZykge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxpbmcgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxpbmcgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uU3R5bGVDaGFuZ2UoW10sIFwic3R5bGluZ1wiKTtcbiAgICAgICAgdGhpcy5fc3R5bGluZyA9IHN0eWxpbmc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGJlaGF2aW9yczogVGVycmFEcmF3TW9kZUJlaGF2aW9yW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgcG9pbnRlckRpc3RhbmNlOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGNvb3JkaW5hdGVQcmVjaXNpb246IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgb25TdHlsZUNoYW5nZTogYW55O1xuICAgIHByb3RlY3RlZCBzdG9yZSE6IEdlb0pTT05TdG9yZTtcbiAgICBwcm90ZWN0ZWQgdW5wcm9qZWN0ITogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnW1widW5wcm9qZWN0XCJdO1xuICAgIHByb3RlY3RlZCBwcm9qZWN0ITogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnW1wicHJvamVjdFwiXTtcbiAgICBwcm90ZWN0ZWQgc2V0Q3Vyc29yITogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnW1wic2V0Q3Vyc29yXCJdO1xuICAgIHByb3RlY3RlZCByZWdpc3RlckJlaGF2aW9ycyhiZWhhdmlvckNvbmZpZzogQmVoYXZpb3JDb25maWcpOiB2b2lkIHt9XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzoge1xuICAgIHN0eWxpbmc/OiBQYXJ0aWFsPFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nPjtcbiAgICBwb2ludGVyRGlzdGFuY2U/OiBudW1iZXI7XG4gICAgY29vcmRpbmF0ZVByZWNpc2lvbj86IG51bWJlcjtcbiAgfSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFwidW5yZWdpc3RlcmVkXCI7XG4gICAgICAgIHRoaXMuX3N0eWxpbmcgPVxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnN0eWxpbmdcbiAgICAgICAgICA/IHsgLi4uZ2V0RGVmYXVsdFN0eWxpbmcoKSwgLi4ub3B0aW9ucy5zdHlsaW5nIH1cbiAgICAgICAgICA6IGdldERlZmF1bHRTdHlsaW5nKCk7XG5cbiAgICAgICAgdGhpcy5wb2ludGVyRGlzdGFuY2UgPSAob3B0aW9ucyAmJiBvcHRpb25zLnBvaW50ZXJEaXN0YW5jZSkgfHwgNDA7XG5cbiAgICAgICAgdGhpcy5jb29yZGluYXRlUHJlY2lzaW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb29yZGluYXRlUHJlY2lzaW9uKSB8fCA5O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXRTdGFydGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFwic3RvcHBlZFwiIHx8IHRoaXMuX3N0YXRlID09PSBcInJlZ2lzdGVyZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBcInN0YXJ0ZWRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGUgbXVzdCBiZSB1bnJlZ2lzdGVyZWQgb3Igc3RvcHBlZCB0byBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXRTdG9wcGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFwic3RhcnRlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFwic3RvcHBlZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBtdXN0IGJlIHN0YXJ0ZWQgdG8gYmUgc3RvcHBlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyKGNvbmZpZzogVGVycmFEcmF3TW9kZVJlZ2lzdGVyQ29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gXCJ1bnJlZ2lzdGVyZWRcIikge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBcInJlZ2lzdGVyZWRcIjtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBjb25maWcuc3RvcmU7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLnJlZ2lzdGVyT25DaGFuZ2UoY29uZmlnLm9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdCA9IGNvbmZpZy5wcm9qZWN0O1xuICAgICAgICAgICAgdGhpcy51bnByb2plY3QgPSBjb25maWcudW5wcm9qZWN0O1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdCA9IGNvbmZpZy5vblNlbGVjdDtcbiAgICAgICAgICAgIHRoaXMub25EZXNlbGVjdCA9IGNvbmZpZy5vbkRlc2VsZWN0O1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IgPSBjb25maWcuc2V0Q3Vyc29yO1xuICAgICAgICAgICAgdGhpcy5vblN0eWxlQ2hhbmdlID0gY29uZmlnLm9uQ2hhbmdlO1xuXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQmVoYXZpb3JzKHtcbiAgICAgICAgICAgICAgICBtb2RlOiBjb25maWcubW9kZSxcbiAgICAgICAgICAgICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICAgICAgdW5wcm9qZWN0OiB0aGlzLnVucHJvamVjdCxcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlzdGFuY2U6IHRoaXMucG9pbnRlckRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVQcmVjaXNpb246IHRoaXMuY29vcmRpbmF0ZVByZWNpc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWdpc3RlciB1bmxlc3MgbW9kZSBpcyB1bnJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkRlc2VsZWN0KGRlc2VsZWN0ZWRJZDogc3RyaW5nKSB7fVxuICAgIG9uU2VsZWN0KHNlbGVjdGVkSWQ6IHN0cmluZykge31cbn1cbiIsImltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7XG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyxcbiAgICBUZXJyYURyYXdLZXlib2FyZEV2ZW50LFxufSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBoYXZlcnNpbmVEaXN0YW5jZUtpbG9tZXRlcnMgfSBmcm9tIFwiLi4vLi4vZ2VvbWV0cnkvbWVhc3VyZS9oYXZlcnNpbmUtZGlzdGFuY2VcIjtcbmltcG9ydCB7IGNpcmNsZSB9IGZyb20gXCIuLi8uLi9nZW9tZXRyeS9zaGFwZS9jcmVhdGUtY2lyY2xlXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdCYXNlRHJhd01vZGUgfSBmcm9tIFwiLi4vYmFzZS5tb2RlXCI7XG5cbnR5cGUgVGVycmFEcmF3Q2lyY2xlTW9kZUtleUV2ZW50cyA9IHtcbiAgY2FuY2VsOiBLZXlib2FyZEV2ZW50W1wia2V5XCJdO1xufTtcblxuZXhwb3J0IGNsYXNzIFRlcnJhRHJhd0NpcmNsZU1vZGUgZXh0ZW5kcyBUZXJyYURyYXdCYXNlRHJhd01vZGUge1xuICAgIG1vZGUgPSBcImNpcmNsZVwiO1xuICAgIHByaXZhdGUgY2VudGVyOiBQb3NpdGlvbiB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIGNsaWNrQ291bnQgPSAwO1xuICAgIHByaXZhdGUgY3VycmVudENpcmNsZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBrZXlFdmVudHM6IFRlcnJhRHJhd0NpcmNsZU1vZGVLZXlFdmVudHM7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzoge1xuICAgIHN0eWxpbmc/OiBQYXJ0aWFsPFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nPjtcbiAgICBrZXlFdmVudHM/OiBUZXJyYURyYXdDaXJjbGVNb2RlS2V5RXZlbnRzO1xuICB9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMua2V5RXZlbnRzID1cbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5rZXlFdmVudHMgPyBvcHRpb25zLmtleUV2ZW50cyA6IHsgY2FuY2VsOiBcIkVzY2FwZVwiIH07XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRlZCgpO1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcImNyb3NzaGFpclwiKTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNldFN0b3BwZWQoKTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoXCJ1bnNldFwiKTtcbiAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IFtldmVudC5sbmcsIGV2ZW50LmxhdF07XG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ0NpcmNsZSA9IGNpcmNsZSh7XG4gICAgICAgICAgICAgICAgY2VudGVyOiB0aGlzLmNlbnRlcixcbiAgICAgICAgICAgICAgICByYWRpdXNLaWxvbWV0ZXJzOiAwLjAwMDAxLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IFtjcmVhdGVkSWRdID0gdGhpcy5zdG9yZS5jcmVhdGUoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHN0YXJ0aW5nQ2lyY2xlLmdlb21ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2lyY2xlSWQgPSBjcmVhdGVkSWQ7XG4gICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCBkcmF3aW5nXG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENpcmNsZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jbGlja0NvdW50ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1vdXNlTW92ZShldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja0NvdW50ID09PSAxICYmIHRoaXMuY2VudGVyICYmIHRoaXMuY3VycmVudENpcmNsZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZUttID0gaGF2ZXJzaW5lRGlzdGFuY2VLaWxvbWV0ZXJzKHRoaXMuY2VudGVyLCBbXG4gICAgICAgICAgICAgICAgZXZlbnQubG5nLFxuICAgICAgICAgICAgICAgIGV2ZW50LmxhdCxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ2lyY2xlID0gY2lyY2xlKHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IHRoaXMuY2VudGVyLFxuICAgICAgICAgICAgICAgIHJhZGl1c0tpbG9tZXRlcnM6IGRpc3RhbmNlS20sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAgICAgeyBpZDogdGhpcy5jdXJyZW50Q2lyY2xlSWQsIGdlb21ldHJ5OiB1cGRhdGVkQ2lyY2xlLmdlb21ldHJ5IH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbktleURvd24oKSB7fVxuICAgIG9uS2V5VXAoZXZlbnQ6IFRlcnJhRHJhd0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gdGhpcy5rZXlFdmVudHMuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRyYWdTdGFydCgpIHt9XG4gICAgb25EcmFnKCkge31cbiAgICBvbkRyYWdFbmQoKSB7fVxuICAgIGNsZWFuVXAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2lyY2xlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZShbdGhpcy5jdXJyZW50Q2lyY2xlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaXJjbGVJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGlja0NvdW50ID0gMDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBGZWF0dXJlLCBQb2x5Z29uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IEJlaGF2aW9yQ29uZmlnLCBUZXJyYURyYXdNb2RlQmVoYXZpb3IgfSBmcm9tIFwiLi9iYXNlLmJlaGF2aW9yXCI7XG5cbmltcG9ydCB7IFRlcnJhRHJhd01vdXNlRXZlbnQgfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBDbGlja0JvdW5kaW5nQm94QmVoYXZpb3IgZXh0ZW5kcyBUZXJyYURyYXdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmVoYXZpb3JDb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyWDogeCwgY29udGFpbmVyWTogeSB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGhhbGZEaXN0ID0gdGhpcy5wb2ludGVyRGlzdGFuY2UgLyAyO1xuXG4gICAgICAgIGNvbnN0IGJib3ggPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHJvamVjdCh4IC0gaGFsZkRpc3QsIHkgLSBoYWxmRGlzdCksIC8vIFRvcExlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5wcm9qZWN0KHggKyBoYWxmRGlzdCwgeSAtIGhhbGZEaXN0KSwgLy8gVG9wUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5wcm9qZWN0KHggKyBoYWxmRGlzdCwgeSArIGhhbGZEaXN0KSwgLy8gQm90dG9tUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5wcm9qZWN0KHggLSBoYWxmRGlzdCwgeSArIGhhbGZEaXN0KSwgLy8gQm90dG9tTGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnByb2plY3QoeCAtIGhhbGZEaXN0LCB5IC0gaGFsZkRpc3QpLCAvLyBUb3BMZWZ0XG4gICAgICAgICAgICAgICAgICAgIF0ubWFwKChjKSA9PiBbYy5sbmcsIGMubGF0XSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgRmVhdHVyZTxQb2x5Z29uPjtcblxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9XG59XG4iLCJpbXBvcnQge1xuICAgIFRlcnJhRHJhd01vdXNlRXZlbnQsXG4gICAgVGVycmFEcmF3QWRhcHRlclN0eWxpbmcsXG4gICAgVGVycmFEcmF3S2V5Ym9hcmRFdmVudCxcbn0gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5cbmltcG9ydCB7IFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB9IGZyb20gXCIuLi9iYXNlLm1vZGVcIjtcblxudHlwZSBUZXJyYURyYXdGcmVlaGFuZE1vZGVLZXlFdmVudHMgPSB7XG4gIGNhbmNlbDogS2V5Ym9hcmRFdmVudFtcImtleVwiXTtcbn07XG5cbmV4cG9ydCBjbGFzcyBUZXJyYURyYXdGcmVlaGFuZE1vZGUgZXh0ZW5kcyBUZXJyYURyYXdCYXNlRHJhd01vZGUge1xuICAgIG1vZGUgPSBcImZyZWVoYW5kXCI7XG5cbiAgICBwcml2YXRlIHN0YXJ0aW5nQ2xpY2sgPSBmYWxzZTtcbiAgICBwcml2YXRlIGN1cnJlbnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgc2tpcCA9IDA7XG4gICAgcHJpdmF0ZSBldmVyeU50aE1vdXNlRXZlbnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGtleUV2ZW50czogVGVycmFEcmF3RnJlZWhhbmRNb2RlS2V5RXZlbnRzO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IHtcbiAgICBzdHlsaW5nPzogUGFydGlhbDxUZXJyYURyYXdBZGFwdGVyU3R5bGluZz47XG4gICAgZXZlcnlOdGhNb3VzZUV2ZW50PzogbnVtYmVyO1xuICAgIGtleUV2ZW50cz86IFRlcnJhRHJhd0ZyZWVoYW5kTW9kZUtleUV2ZW50cztcbiAgfSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmV2ZXJ5TnRoTW91c2VFdmVudCA9IChvcHRpb25zICYmIG9wdGlvbnMuZXZlcnlOdGhNb3VzZUV2ZW50KSB8fCAxMDtcbiAgICAgICAgdGhpcy5rZXlFdmVudHMgPVxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmtleUV2ZW50cyA/IG9wdGlvbnMua2V5RXZlbnRzIDogeyBjYW5jZWw6IFwiRXNjYXBlXCIgfTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGFydGVkKCk7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKFwiY3Jvc3NoYWlyXCIpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNldFN0b3BwZWQoKTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoXCJ1bnNldFwiKTtcbiAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRJZCB8fCB0aGlzLnN0YXJ0aW5nQ2xpY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5za2lwID4gdGhpcy5ldmVyeU50aE1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZUdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8UG9seWdvbj4oXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRMaW5lR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0ucG9wKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudElkLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudExpbmVHZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2V2ZW50LmxuZywgZXZlbnQubGF0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVHZW9tZXRyeS5jb29yZGluYXRlc1swXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNraXArKztcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0aW5nQ2xpY2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBbY3JlYXRlZElkXSA9IHRoaXMuc3RvcmUuY3JlYXRlKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG1vZGU6IHRoaXMubW9kZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SWQgPSBjcmVhdGVkSWQ7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0aW5nQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFydGluZ0NsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudElkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvbktleURvd24oKSB7fVxuICAgIG9uS2V5VXAoZXZlbnQ6IFRlcnJhRHJhd0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gdGhpcy5rZXlFdmVudHMuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRyYWdTdGFydCgpIHt9XG4gICAgb25EcmFnKCkge31cbiAgICBvbkRyYWdFbmQoKSB7fVxuXG4gICAgY2xlYW5VcCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKFt0aGlzLmN1cnJlbnRJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRpbmdDbGljayA9IGZhbHNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyxcbiAgICBUZXJyYURyYXdLZXlib2FyZEV2ZW50LFxufSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBMaW5lU3RyaW5nIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IHNlbGZJbnRlcnNlY3RzIH0gZnJvbSBcIi4uLy4uL2dlb21ldHJ5L2Jvb2xlYW4vc2VsZi1pbnRlcnNlY3RzXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdCYXNlRHJhd01vZGUgfSBmcm9tIFwiLi4vYmFzZS5tb2RlXCI7XG5pbXBvcnQgeyBwaXhlbERpc3RhbmNlIH0gZnJvbSBcIi4uLy4uL2dlb21ldHJ5L21lYXN1cmUvcGl4ZWwtZGlzdGFuY2VcIjtcbmltcG9ydCB7IEJlaGF2aW9yQ29uZmlnIH0gZnJvbSBcIi4uL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IENsaWNrQm91bmRpbmdCb3hCZWhhdmlvciB9IGZyb20gXCIuLi9jbGljay1ib3VuZGluZy1ib3guYmVoYXZpb3JcIjtcbmltcG9ydCB7IFBpeGVsRGlzdGFuY2VCZWhhdmlvciB9IGZyb20gXCIuLi9waXhlbC1kaXN0YW5jZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgU25hcHBpbmdCZWhhdmlvciB9IGZyb20gXCIuLi9zbmFwcGluZy5iZWhhdmlvclwiO1xuXG50eXBlIFRlcnJhRHJhd0xpbmVTdHJpbmdNb2RlS2V5RXZlbnRzID0ge1xuICBjYW5jZWw6IEtleWJvYXJkRXZlbnRbXCJrZXlcIl07XG59O1xuZXhwb3J0IGNsYXNzIFRlcnJhRHJhd0xpbmVTdHJpbmdNb2RlIGV4dGVuZHMgVGVycmFEcmF3QmFzZURyYXdNb2RlIHtcbiAgICBtb2RlID0gXCJsaW5lc3RyaW5nXCI7XG5cbiAgICBwcml2YXRlIGN1cnJlbnRDb29yZGluYXRlID0gMDtcbiAgICBwcml2YXRlIGN1cnJlbnRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgYWxsb3dTZWxmSW50ZXJzZWN0aW9ucztcbiAgICBwcml2YXRlIGtleUV2ZW50czogVGVycmFEcmF3TGluZVN0cmluZ01vZGVLZXlFdmVudHM7XG4gICAgcHJpdmF0ZSBzbmFwcGluZ0VuYWJsZWQ6IGJvb2xlYW47XG5cbiAgICAvLyBCZWhhdmlvcnNcbiAgICBwcml2YXRlIHNuYXBwaW5nITogU25hcHBpbmdCZWhhdmlvcjtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiB7XG4gICAgc25hcHBpbmc/OiBib29sZWFuO1xuICAgIGFsbG93U2VsZkludGVyc2VjdGlvbnM/OiBib29sZWFuO1xuICAgIHBvaW50ZXJEaXN0YW5jZT86IG51bWJlcjtcbiAgICBzdHlsaW5nPzogUGFydGlhbDxUZXJyYURyYXdBZGFwdGVyU3R5bGluZz47XG4gICAga2V5RXZlbnRzPzogVGVycmFEcmF3TGluZVN0cmluZ01vZGVLZXlFdmVudHM7XG4gIH0pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zbmFwcGluZ0VuYWJsZWQgPVxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnNuYXBwaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNuYXBwaW5nIDogZmFsc2U7XG5cbiAgICAgICAgdGhpcy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25zID1cbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25zICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG9wdGlvbnMuYWxsb3dTZWxmSW50ZXJzZWN0aW9uc1xuICAgICAgICAgIDogdHJ1ZTtcblxuICAgICAgICB0aGlzLmtleUV2ZW50cyA9XG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMua2V5RXZlbnRzID8gb3B0aW9ucy5rZXlFdmVudHMgOiB7IGNhbmNlbDogXCJFc2NhcGVcIiB9O1xuICAgIH1cblxuICAgIHB1YmxpYyByZWdpc3RlckJlaGF2aW9ycyhjb25maWc6IEJlaGF2aW9yQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuc25hcHBpbmcgPSBuZXcgU25hcHBpbmdCZWhhdmlvcihcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIG5ldyBQaXhlbERpc3RhbmNlQmVoYXZpb3IoY29uZmlnKSxcbiAgICAgICAgICAgIG5ldyBDbGlja0JvdW5kaW5nQm94QmVoYXZpb3IoY29uZmlnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWQoKTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoXCJjcm9zc2hhaXJcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcHBlZCgpO1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcInVuc2V0XCIpO1xuICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudElkIHx8IHRoaXMuY3VycmVudENvb3JkaW5hdGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50TGluZUdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8TGluZVN0cmluZz4oXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgJ2xpdmUnIHBvaW50IHRoYXQgY2hhbmdlcyBvbiBtb3VzZSBtb3ZlXG4gICAgICAgIGN1cnJlbnRMaW5lR2VvbWV0cnkuY29vcmRpbmF0ZXMucG9wKCk7XG5cbiAgICAgICAgY29uc3Qgc25hcHBlZENvb3JkID1cbiAgICAgIHRoaXMuc25hcHBpbmdFbmFibGVkICYmXG4gICAgICB0aGlzLnNuYXBwaW5nLmdldFNuYXBwYWJsZUNvb3JkaW5hdGUoZXZlbnQsIHRoaXMuY3VycmVudElkKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZENvb3JkID0gc25hcHBlZENvb3JkID8gc25hcHBlZENvb3JkIDogW2V2ZW50LmxuZywgZXZlbnQubGF0XTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlICdsaXZlJyBwb2ludFxuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZUdlb21ldHJ5KFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50SWQsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbLi4uY3VycmVudExpbmVHZW9tZXRyeS5jb29yZGluYXRlcywgdXBkYXRlZENvb3JkXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgb25DbGljayhldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBjb25zdCBzbmFwcGVkQ29vcmQgPVxuICAgICAgdGhpcy5jdXJyZW50SWQgJiZcbiAgICAgIHRoaXMuc25hcHBpbmdFbmFibGVkICYmXG4gICAgICB0aGlzLnNuYXBwaW5nLmdldFNuYXBwYWJsZUNvb3JkaW5hdGUoZXZlbnQsIHRoaXMuY3VycmVudElkKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZENvb3JkID0gc25hcHBlZENvb3JkID8gc25hcHBlZENvb3JkIDogW2V2ZW50LmxuZywgZXZlbnQubGF0XTtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29vcmRpbmF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgW2NyZWF0ZWRJZF0gPSB0aGlzLnN0b3JlLmNyZWF0ZShbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQ29vcmQsIC8vIFRoaXMgaXMgdGhlICdsaXZlJyBwb2ludCB0aGF0IGNoYW5nZXMgb24gbW91c2UgbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyBtb2RlOiB0aGlzLm1vZGUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZCA9IGNyZWF0ZWRJZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvb3JkaW5hdGUrKztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRDb29yZGluYXRlID09PSAxICYmIHRoaXMuY3VycmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZUdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8TGluZVN0cmluZz4oXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudElkLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb29yZGluYXRlKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5lR2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxMaW5lU3RyaW5nPihcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgW3ByZXZpb3VzTG5nLCBwcmV2aW91c0xhdF0gPVxuICAgICAgICBjdXJyZW50TGluZUdlb21ldHJ5LmNvb3JkaW5hdGVzW1xuICAgICAgICAgICAgY3VycmVudExpbmVHZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAyXG4gICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucHJvamVjdChwcmV2aW91c0xuZywgcHJldmlvdXNMYXQpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwaXhlbERpc3RhbmNlKFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogZXZlbnQuY29udGFpbmVyWCwgeTogZXZlbnQuY29udGFpbmVyWSB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBpc0Nsb3NpbmdDbGljayA9IGRpc3RhbmNlIDwgdGhpcy5wb2ludGVyRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChpc0Nsb3NpbmdDbGljaykge1xuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBvZmYgdGhlIGRyYXdpbmdcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZUdlb21ldHJ5LmNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbLi4uY3VycmVudExpbmVHZW9tZXRyeS5jb29yZGluYXRlc10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29vcmRpbmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBjbG9zZSB0byB0aGUgZmluYWwgcG9pbnQsIGtlZXAgYWRkaW5nIHBvaW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTdHJpbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogWy4uLmN1cnJlbnRMaW5lR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHVwZGF0ZWRDb29yZF0sXG4gICAgICAgICAgICAgICAgfSBhcyBMaW5lU3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93U2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzU2VsZkludGVyc2VjdGlvbnMgPSBzZWxmSW50ZXJzZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBuZXdMaW5lU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IHRoaXMuY3VycmVudElkLCBnZW9tZXRyeTogbmV3TGluZVN0cmluZyB9LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvb3JkaW5hdGUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbktleURvd24oKSB7fVxuICAgIG9uS2V5VXAoZXZlbnQ6IFRlcnJhRHJhd0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gdGhpcy5rZXlFdmVudHMuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRyYWdTdGFydCgpIHt9XG4gICAgb25EcmFnKCkge31cbiAgICBvbkRyYWdFbmQoKSB7fVxuICAgIGNsZWFuVXAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZShbdGhpcy5jdXJyZW50SWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudENvb3JkaW5hdGUgPSAwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEJlaGF2aW9yQ29uZmlnLCBUZXJyYURyYXdNb2RlQmVoYXZpb3IgfSBmcm9tIFwiLi9iYXNlLmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdNb3VzZUV2ZW50IH0gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBwaXhlbERpc3RhbmNlIH0gZnJvbSBcIi4uL2dlb21ldHJ5L21lYXN1cmUvcGl4ZWwtZGlzdGFuY2VcIjtcblxuZXhwb3J0IGNsYXNzIFBpeGVsRGlzdGFuY2VCZWhhdmlvciBleHRlbmRzIFRlcnJhRHJhd01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCZWhhdmlvckNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cbiAgICBwdWJsaWMgbWVhc3VyZShjbGlja0V2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LCBzZWNvbmRDb29yZGluYXRlOiBQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucHJvamVjdChzZWNvbmRDb29yZGluYXRlWzBdLCBzZWNvbmRDb29yZGluYXRlWzFdKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBpeGVsRGlzdGFuY2UoXG4gICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgIHsgeDogY2xpY2tFdmVudC5jb250YWluZXJYLCB5OiBjbGlja0V2ZW50LmNvbnRhaW5lclkgfVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUZXJyYURyYXdNb3VzZUV2ZW50LCBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyB9IGZyb20gXCIuLi8uLi9jb21tb25cIjtcbmltcG9ydCB7IFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB9IGZyb20gXCIuLi9iYXNlLm1vZGVcIjtcblxuZXhwb3J0IGNsYXNzIFRlcnJhRHJhd1BvaW50TW9kZSBleHRlbmRzIFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB7XG4gICAgbW9kZSA9IFwicG9pbnRcIjtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiB7IHN0eWxpbmc/OiBQYXJ0aWFsPFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nPiB9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWQoKTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoXCJjcm9zc2hhaXJcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcHBlZCgpO1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcInVuc2V0XCIpO1xuICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICB9XG5cbiAgICBvbkNsaWNrKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBtdXN0IGJlIHJlZ2lzdGVyZWQgZmlyc3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3JlLmNyZWF0ZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW2V2ZW50LmxuZywgZXZlbnQubGF0XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgbW9kZTogdGhpcy5tb2RlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgb25Nb3VzZU1vdmUoKSB7fVxuICAgIG9uS2V5RG93bigpIHt9XG4gICAgb25LZXlVcCgpIHt9XG4gICAgY2xlYW5VcCgpIHt9XG4gICAgb25EcmFnU3RhcnQoKSB7fVxuICAgIG9uRHJhZygpIHt9XG4gICAgb25EcmFnRW5kKCkge31cbn1cbiIsImltcG9ydCB7XG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyxcbiAgICBUZXJyYURyYXdLZXlib2FyZEV2ZW50LFxufSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IHNlbGZJbnRlcnNlY3RzIH0gZnJvbSBcIi4uLy4uL2dlb21ldHJ5L2Jvb2xlYW4vc2VsZi1pbnRlcnNlY3RzXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdCYXNlRHJhd01vZGUgfSBmcm9tIFwiLi4vYmFzZS5tb2RlXCI7XG5pbXBvcnQgeyBQaXhlbERpc3RhbmNlQmVoYXZpb3IgfSBmcm9tIFwiLi4vcGl4ZWwtZGlzdGFuY2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IENsaWNrQm91bmRpbmdCb3hCZWhhdmlvciB9IGZyb20gXCIuLi9jbGljay1ib3VuZGluZy1ib3guYmVoYXZpb3JcIjtcbmltcG9ydCB7IEJlaGF2aW9yQ29uZmlnIH0gZnJvbSBcIi4uL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IGNyZWF0ZVBvbHlnb24gfSBmcm9tIFwiLi4vLi4vdXRpbC9nZW9tc1wiO1xuaW1wb3J0IHsgU25hcHBpbmdCZWhhdmlvciB9IGZyb20gXCIuLi9zbmFwcGluZy5iZWhhdmlvclwiO1xuaW1wb3J0IHsgY29vcmRpbmF0ZXNJZGVudGljYWwgfSBmcm9tIFwiLi4vLi4vZ2VvbWV0cnkvaWRlbnRpY2FsLWNvb3JkaW5hdGVzXCI7XG5cbnR5cGUgVGVycmFEcmF3UG9seWdvbk1vZGVLZXlFdmVudHMgPSB7XG4gICAgY2FuY2VsOiBLZXlib2FyZEV2ZW50W1wia2V5XCJdO1xufTtcbmV4cG9ydCBjbGFzcyBUZXJyYURyYXdQb2x5Z29uTW9kZSBleHRlbmRzIFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB7XG4gICAgbW9kZSA9IFwicG9seWdvblwiO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Q29vcmRpbmF0ZSA9IDA7XG4gICAgcHJpdmF0ZSBjdXJyZW50SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIGFsbG93U2VsZkludGVyc2VjdGlvbnM6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBrZXlFdmVudHM6IFRlcnJhRHJhd1BvbHlnb25Nb2RlS2V5RXZlbnRzO1xuICAgIHByaXZhdGUgc25hcHBpbmdFbmFibGVkOiBib29sZWFuO1xuICAgIHByaXZhdGUgaXNDbG9zZWQgPSBmYWxzZTtcblxuICAgIC8vIEJlaGF2aW9yc1xuICAgIHByaXZhdGUgc25hcHBpbmchOiBTbmFwcGluZ0JlaGF2aW9yO1xuICAgIHByaXZhdGUgcGl4ZWxEaXN0YW5jZSE6IFBpeGVsRGlzdGFuY2VCZWhhdmlvcjtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiB7XG4gICAgICAgIGFsbG93U2VsZkludGVyc2VjdGlvbnM/OiBib29sZWFuO1xuICAgICAgICBzbmFwcGluZz86IGJvb2xlYW47XG4gICAgICAgIHN0eWxpbmc/OiBQYXJ0aWFsPFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nPjtcbiAgICAgICAgcG9pbnRlckRpc3RhbmNlPzogbnVtYmVyO1xuICAgICAgICBrZXlFdmVudHM/OiBUZXJyYURyYXdQb2x5Z29uTW9kZUtleUV2ZW50cztcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc25hcHBpbmdFbmFibGVkID1cbiAgICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zbmFwcGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbmFwcGluZyA6IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYWxsb3dTZWxmSW50ZXJzZWN0aW9ucyA9XG4gICAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dTZWxmSW50ZXJzZWN0aW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmFsbG93U2VsZkludGVyc2VjdGlvbnNcbiAgICAgICAgICAgICAgICA6IHRydWU7XG5cbiAgICAgICAgdGhpcy5rZXlFdmVudHMgPVxuICAgICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmtleUV2ZW50cyA/IG9wdGlvbnMua2V5RXZlbnRzIDogeyBjYW5jZWw6IFwiRXNjYXBlXCIgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVnaXN0ZXJCZWhhdmlvcnMoY29uZmlnOiBCZWhhdmlvckNvbmZpZykge1xuICAgICAgICB0aGlzLnBpeGVsRGlzdGFuY2UgPSBuZXcgUGl4ZWxEaXN0YW5jZUJlaGF2aW9yKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuc25hcHBpbmcgPSBuZXcgU25hcHBpbmdCZWhhdmlvcihcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHRoaXMucGl4ZWxEaXN0YW5jZSxcbiAgICAgICAgICAgIG5ldyBDbGlja0JvdW5kaW5nQm94QmVoYXZpb3IoY29uZmlnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWQoKTtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoXCJjcm9zc2hhaXJcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcHBlZCgpO1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcInVuc2V0XCIpO1xuICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICB9XG5cbiAgICBvbk1vdXNlTW92ZShldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcImNyb3NzaGFpclwiKTtcblxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudElkIHx8IHRoaXMuY3VycmVudENvb3JkaW5hdGUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb3Nlc3RDb29yZCA9IHRoaXMuc25hcHBpbmdFbmFibGVkXG4gICAgICAgICAgICA/IHRoaXMuc25hcHBpbmcuZ2V0U25hcHBhYmxlQ29vcmRpbmF0ZShldmVudCwgdGhpcy5jdXJyZW50SWQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8UG9seWdvbj4oXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJZFxuICAgICAgICApLmNvb3JkaW5hdGVzWzBdO1xuXG4gICAgICAgIGlmIChjbG9zZXN0Q29vcmQpIHtcbiAgICAgICAgICAgIGV2ZW50LmxuZyA9IGNsb3Nlc3RDb29yZFswXTtcbiAgICAgICAgICAgIGV2ZW50LmxhdCA9IGNsb3Nlc3RDb29yZFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB1cGRhdGVkQ29vcmRpbmF0ZXM7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvb3JkaW5hdGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgYWRkIGEgdmVyeSBzbWFsbCBlcHNpbG9uIHZhbHVlIHNvIHRoYXQgTWFwYm94IEdMXG4gICAgICAgICAgICAvLyByZW5kZXJzIHRoZSBwb2x5Z29uIC0gVGhlcmUgbWlnaHQgYmUgYSBjbGVhbmVyIHNvbHV0aW9uP1xuICAgICAgICAgICAgY29uc3QgZXBzaWxvbiA9IDEgLyBNYXRoLnBvdygxMCwgdGhpcy5jb29yZGluYXRlUHJlY2lzaW9uIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heCgwLjAwMDAwMSwgZXBzaWxvbik7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb29yZGluYXRlcyA9IFtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgICAgIFtldmVudC5sbmcsIGV2ZW50LmxhdF0sXG4gICAgICAgICAgICAgICAgW2V2ZW50LmxuZywgZXZlbnQubGF0ICsgb2Zmc2V0XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRDb29yZGluYXRlID09PSAyKSB7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb29yZGluYXRlcyA9IFtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uQ29vcmRpbmF0ZXNbMV0sXG4gICAgICAgICAgICAgICAgW2V2ZW50LmxuZywgZXZlbnQubGF0XSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBpeGVsRGlzdGFuY2UubWVhc3VyZShcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzWzBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBpc0Nsb3NpbmcgPSBkaXN0YW5jZSA8IHRoaXMucG9pbnRlckRpc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb29yZGluYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRQb2x5Z29uQ29vcmRpbmF0ZXMuc2xpY2UoMCwgLTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvbHlnb25Db29yZGluYXRlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uQ29vcmRpbmF0ZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb29yZGluYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRQb2x5Z29uQ29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdXBkYXRlZENvb3JkaW5hdGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5jdXJyZW50UG9seWdvbkNvb3JkaW5hdGVzLnNsaWNlKDAsIC0yKSxcbiAgICAgICAgICAgICAgICAgICAgW2V2ZW50LmxuZywgZXZlbnQubGF0XSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvbHlnb25Db29yZGluYXRlc1swXSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudElkLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW3VwZGF0ZWRDb29yZGluYXRlc10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2xvc2VzdENvb3JkID1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudElkICYmIHRoaXMuc25hcHBpbmdFbmFibGVkXG4gICAgICAgICAgICAgICAgPyB0aGlzLnNuYXBwaW5nLmdldFNuYXBwYWJsZUNvb3JkaW5hdGUoZXZlbnQsIHRoaXMuY3VycmVudElkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb29yZGluYXRlID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdENvb3JkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQubG5nID0gY2xvc2VzdENvb3JkWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LmxhdCA9IGNsb3Nlc3RDb29yZFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgW25ld0lkXSA9IHRoaXMuc3RvcmUuY3JlYXRlKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG1vZGU6IHRoaXMubW9kZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElkID0gbmV3SWQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb29yZGluYXRlKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50Q29vcmRpbmF0ZSA9PT0gMSAmJiB0aGlzLmN1cnJlbnRJZCkge1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RDb29yZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmxuZyA9IGNsb3Nlc3RDb29yZFswXTtcbiAgICAgICAgICAgICAgICBldmVudC5sYXQgPSBjbG9zZXN0Q29vcmRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2x5Z29uR2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxQb2x5Z29uPihcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDb29yZGluYXRlID0gY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXVswXTtcbiAgICAgICAgICAgIGNvbnN0IGlzSWRlbnRpY2FsID0gY29vcmRpbmF0ZXNJZGVudGljYWwoW2V2ZW50LmxuZywgZXZlbnQubGF0XSwgcHJldmlvdXNDb29yZGluYXRlKTtcblxuICAgICAgICAgICAgaWYgKGlzSWRlbnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZUdlb21ldHJ5KFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmN1cnJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtldmVudC5sbmcsIGV2ZW50LmxhdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtldmVudC5sbmcsIGV2ZW50LmxhdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb29yZGluYXRlKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50Q29vcmRpbmF0ZSA9PT0gMiAmJiB0aGlzLmN1cnJlbnRJZCkge1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RDb29yZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmxuZyA9IGNsb3Nlc3RDb29yZFswXTtcbiAgICAgICAgICAgICAgICBldmVudC5sYXQgPSBjbG9zZXN0Q29vcmRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2x5Z29uR2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxQb2x5Z29uPihcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRJZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDb29yZGluYXRlID0gY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXVxuICAgICAgICAgICAgY29uc3QgaXNJZGVudGljYWwgPSBjb29yZGluYXRlc0lkZW50aWNhbChbZXZlbnQubG5nLCBldmVudC5sYXRdLCBwcmV2aW91c0Nvb3JkaW5hdGUpXG5cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29vcmRpbmF0ZSsrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9seWdvbkdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8UG9seWdvbj4oXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SWRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5waXhlbERpc3RhbmNlLm1lYXN1cmUoXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXVswXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgaXNDbG9zaW5nQ2xpY2sgPSBkaXN0YW5jZSA8IHRoaXMucG9pbnRlckRpc3RhbmNlO1xuXG5cbiAgICAgICAgICAgIGlmIChpc0Nsb3NpbmdDbGljaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN1cnJlbnRQb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0uc2xpY2UoMCwgLTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvb3JkaW5hdGUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdENvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmxuZyA9IGNsb3Nlc3RDb29yZFswXTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQubGF0ID0gY2xvc2VzdENvb3JkWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ29vcmRpbmF0ZSA9IGN1cnJlbnRQb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bdGhpcy5jdXJyZW50Q29vcmRpbmF0ZSAtIDFdXG4gICAgICAgICAgICAgICAgY29uc3QgaXNJZGVudGljYWwgPSBjb29yZGluYXRlc0lkZW50aWNhbChbZXZlbnQubG5nLCBldmVudC5sYXRdLCBwcmV2aW91c0Nvb3JkaW5hdGUpXG5cbiAgICAgICAgICAgICAgICBpZiAoaXNJZGVudGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBvbHlnb24gPSBjcmVhdGVQb2x5Z29uKFtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXS5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nLCBldmVudC5sYXRdLCAvLyBOZXcgcG9pbnQgdGhhdCBvbk1vdXNlTW92ZSBjYW4gbWFuaXB1bGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlc1swXVswXSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb29yZGluYXRlID4gMiAmJiAhdGhpcy5hbGxvd1NlbGZJbnRlcnNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1NlbGZJbnRlcnNlY3Rpb25zID0gc2VsZkludGVyc2VjdHModXBkYXRlZFBvbHlnb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBnZW9tZXRyeSFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBjbG9zZSB0byB0aGUgZmluYWwgcG9pbnQsIGtlZXAgYWRkaW5nIHBvaW50c1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgICAgICAgICB7IGlkOiB0aGlzLmN1cnJlbnRJZCwgZ2VvbWV0cnk6IHVwZGF0ZWRQb2x5Z29uLmdlb21ldHJ5IH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29vcmRpbmF0ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlVcChldmVudDogVGVycmFEcmF3S2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSB0aGlzLmtleUV2ZW50cy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25LZXlEb3duKCkgeyB9XG5cbiAgICBvbkRyYWdTdGFydCgpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBhbGxvdyB0aGUgZGVmYXVsdCBkcmFnXG4gICAgICAgIC8vIGN1cnNvciB0byBleGlzdFxuICAgICAgICB0aGlzLnNldEN1cnNvcihcInVuc2V0XCIpO1xuICAgIH1cbiAgICBvbkRyYWcoKSB7IH1cbiAgICBvbkRyYWdFbmQoKSB7XG4gICAgICAgIC8vIFNldCBpdCBiYWNrIHRvIGNyb3NzaGFpclxuICAgICAgICB0aGlzLnNldEN1cnNvcihcImNyb3NzaGFpclwiKTtcbiAgICB9XG5cbiAgICBjbGVhblVwKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUoW3RoaXMuY3VycmVudElkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdGhpcy5jdXJyZW50SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudENvb3JkaW5hdGUgPSAwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nIH0gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IHsgVGVycmFEcmF3QmFzZURyYXdNb2RlIH0gZnJvbSBcIi4uL2Jhc2UubW9kZVwiO1xuaW1wb3J0IHsgQmVoYXZpb3JDb25maWcgfSBmcm9tIFwiLi4vYmFzZS5iZWhhdmlvclwiO1xuXG5leHBvcnQgY2xhc3MgVGVycmFEcmF3UmVuZGVyTW9kZSBleHRlbmRzIFRlcnJhRHJhd0Jhc2VEcmF3TW9kZSB7XG4gICAgcHVibGljIG1vZGUgPSBcInJlbmRlclwiOyAvLyBUaGlzIGdldHMgY2hhbmdlZCBkeW5hbWljYWxseVxuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogeyBzdHlsaW5nOiBQYXJ0aWFsPFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nPiB9KSB7XG4gICAgICAgIHN1cGVyKHsgc3R5bGluZzogb3B0aW9ucy5zdHlsaW5nIH0pO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgaXMgcHJvYmFibHkgYWJ1c2luZ1xuICAgIC8vIHJlZ2lzdGVyQmVoYXZpb3JzIGJ1dCBpdCB3b3JrcyBxdWl0ZSB3ZWxsIGNvbmNlcHR1YWxseVxuICAgIHJlZ2lzdGVyQmVoYXZpb3JzKGJlaGF2aW9yQ29uZmlnOiBCZWhhdmlvckNvbmZpZykge1xuICAgIC8vIFdlIGNhbiBzZXQgdGhlIG1vZGUgbmFtZSBkeW5hbWljYWxseVxuICAgICAgICB0aGlzLm1vZGUgPSBiZWhhdmlvckNvbmZpZy5tb2RlO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdG9wcGVkKCk7XG4gICAgfVxuICAgIG9uS2V5VXAoKSB7fVxuICAgIG9uS2V5RG93bigpIHt9XG4gICAgb25DbGljaygpIHt9XG4gICAgb25EcmFnU3RhcnQoKSB7fVxuICAgIG9uRHJhZygpIHt9XG4gICAgb25EcmFnRW5kKCkge31cbiAgICBvbk1vdXNlTW92ZSgpIHt9XG59XG4iLCJpbXBvcnQgeyBUZXJyYURyYXdNb3VzZUV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IHsgQmVoYXZpb3JDb25maWcsIFRlcnJhRHJhd01vZGVCZWhhdmlvciB9IGZyb20gXCIuLi8uLi9iYXNlLmJlaGF2aW9yXCI7XG5cbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IFBpeGVsRGlzdGFuY2VCZWhhdmlvciB9IGZyb20gXCIuLi8uLi9waXhlbC1kaXN0YW5jZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgTWlkUG9pbnRCZWhhdmlvciB9IGZyb20gXCIuL21pZHBvaW50LmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBTZWxlY3Rpb25Qb2ludEJlaGF2aW9yIH0gZnJvbSBcIi4vc2VsZWN0aW9uLXBvaW50LmJlaGF2aW9yXCI7XG5cbmV4cG9ydCBjbGFzcyBEcmFnQ29vcmRpbmF0ZUJlaGF2aW9yIGV4dGVuZHMgVGVycmFEcmF3TW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBjb25maWc6IEJlaGF2aW9yQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGl4ZWxEaXN0YW5jZTogUGl4ZWxEaXN0YW5jZUJlaGF2aW9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VsZWN0aW9uUG9pbnRzOiBTZWxlY3Rpb25Qb2ludEJlaGF2aW9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWlkUG9pbnRzOiBNaWRQb2ludEJlaGF2aW9yXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYWcoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQsIHNlbGVjdGVkSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuc3RvcmUuZ2V0R2VvbWV0cnlDb3B5KHNlbGVjdGVkSWQpO1xuXG4gICAgICAgIGxldCBnZW9tQ29vcmRpbmF0ZXM6IFBvc2l0aW9uW10gfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICBnZW9tQ29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgZ2VvbUNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhbmRsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgLy8gcG9pbnRzIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb3Nlc3RDb29yZGluYXRlID0ge1xuICAgICAgICAgICAgZGlzdDogSW5maW5pdHksXG4gICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICBpc0ZpcnN0T3JMYXN0UG9seWdvbkNvb3JkOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBMb29rIHRocm91Z2ggdGhlIHNlbGVjdGVkIGZlYXR1cmVzIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIGFuZCB0cnkgdG8gZmluZCBhIGNvb3JkaW5hdGUgdGhhdCBpcyBkcmFnZ2FibGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tQ29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gZ2VvbUNvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBpeGVsRGlzdGFuY2UubWVhc3VyZShldmVudCwgY29vcmQpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPCB0aGlzLnBvaW50ZXJEaXN0YW5jZSAmJlxuICAgICAgICBkaXN0YW5jZSA8IGNsb3Nlc3RDb29yZGluYXRlLmRpc3RcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGNyZWF0ZSBhIHBvaW50IGZvciB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBwb2x5Z29uIGNvb3JkLCBzbyB3ZSBtdXN0IHNldCBpdCB0byB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBjb29yZGluYXRlIGluc3RlYWRcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZpcnN0T3JMYXN0UG9seWdvbkNvb3JkID1cbiAgICAgICAgICBnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIiAmJlxuICAgICAgICAgIChpID09PSBnZW9tQ29vcmRpbmF0ZXMubGVuZ3RoIC0gMSB8fCBpID09PSAwKTtcblxuICAgICAgICAgICAgICAgIGNsb3Nlc3RDb29yZGluYXRlLmRpc3QgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Q29vcmRpbmF0ZS5pbmRleCA9IGlzRmlyc3RPckxhc3RQb2x5Z29uQ29vcmQgPyAwIDogaTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Q29vcmRpbmF0ZS5pc0ZpcnN0T3JMYXN0UG9seWdvbkNvb3JkID0gaXNGaXJzdE9yTGFzdFBvbHlnb25Db29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGNvb3JkaW5hdGUgd2FzIHdpdGhpbiB0aGUgcG9pbnRlciBkaXN0YW5jZVxuICAgICAgICBpZiAoY2xvc2VzdENvb3JkaW5hdGUuaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgdXBkYXRlZCBjb29yZFxuICAgICAgICBjb25zdCB1cGRhdGVkQ29vcmRpbmF0ZSA9IFtldmVudC5sbmcsIGV2ZW50LmxhdF07XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byB1cGRhdGUgdGhlIGFjdHVhbCBQb2x5Z29uL0xpbmVTdHJpbmcgaXRzZWxmIC1cbiAgICAgICAgLy8gZm9yIFBvbHlnb25zIHdlIHdhbnQgdGhlIGZpcnN0IGFuZCBsYXN0IGNvb3JkaW5hdGVzIHRvIG1hdGNoXG4gICAgICAgIGlmIChjbG9zZXN0Q29vcmRpbmF0ZS5pc0ZpcnN0T3JMYXN0UG9seWdvbkNvb3JkKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q29vcmRJbmRleCA9IGdlb21Db29yZGluYXRlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZ2VvbUNvb3JkaW5hdGVzWzBdID0gdXBkYXRlZENvb3JkaW5hdGU7XG4gICAgICAgICAgICBnZW9tQ29vcmRpbmF0ZXNbbGFzdENvb3JkSW5kZXhdID0gdXBkYXRlZENvb3JkaW5hdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW9tQ29vcmRpbmF0ZXNbY2xvc2VzdENvb3JkaW5hdGUuaW5kZXhdID0gdXBkYXRlZENvb3JkaW5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkU2VsZWN0aW9uUG9pbnQgPSB0aGlzLnNlbGVjdGlvblBvaW50cy5nZXRPbmVVcGRhdGVkKFxuICAgICAgICAgICAgY2xvc2VzdENvb3JkaW5hdGUuaW5kZXgsXG4gICAgICAgICAgICB1cGRhdGVkQ29vcmRpbmF0ZVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3Rpb25Qb2ludHMgPSB1cGRhdGVkU2VsZWN0aW9uUG9pbnRcbiAgICAgICAgICAgID8gW3VwZGF0ZWRTZWxlY3Rpb25Qb2ludF1cbiAgICAgICAgICAgIDogW107XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZE1pZFBvaW50cyA9IHRoaXMubWlkUG9pbnRzLmdldFVwZGF0ZWQoZ2VvbUNvb3JkaW5hdGVzKSB8fCBbXTtcblxuICAgICAgICAvLyBBcHBseSBhbGwgdGhlIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAvLyBVcGRhdGUgZmVhdHVyZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBzZWxlY3RlZElkLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIGFuZCBtaWQgcG9pbnRzXG4gICAgICAgICAgICAuLi51cGRhdGVkU2VsZWN0aW9uUG9pbnRzLFxuICAgICAgICAgICAgLi4udXBkYXRlZE1pZFBvaW50cyxcbiAgICAgICAgXSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVGVycmFEcmF3TW91c2VFdmVudCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmltcG9ydCB7IEJlaGF2aW9yQ29uZmlnLCBUZXJyYURyYXdNb2RlQmVoYXZpb3IgfSBmcm9tIFwiLi4vLi4vYmFzZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgRmVhdHVyZXNBdE1vdXNlRXZlbnRCZWhhdmlvciB9IGZyb20gXCIuL2ZlYXR1cmVzLWF0LW1vdXNlLWV2ZW50LmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBTZWxlY3Rpb25Qb2ludEJlaGF2aW9yIH0gZnJvbSBcIi4vc2VsZWN0aW9uLXBvaW50LmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBNaWRQb2ludEJlaGF2aW9yIH0gZnJvbSBcIi4vbWlkcG9pbnQuYmVoYXZpb3JcIjtcblxuZXhwb3J0IGNsYXNzIERyYWdGZWF0dXJlQmVoYXZpb3IgZXh0ZW5kcyBUZXJyYURyYXdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGNvbmZpZzogQmVoYXZpb3JDb25maWcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmZWF0dXJlc0F0TW91c2VFdmVudDogRmVhdHVyZXNBdE1vdXNlRXZlbnRCZWhhdmlvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlbGVjdGlvblBvaW50czogU2VsZWN0aW9uUG9pbnRCZWhhdmlvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1pZFBvaW50czogTWlkUG9pbnRCZWhhdmlvclxuICAgICkge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhZ1Bvc2l0aW9uOiBQb3NpdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1Bvc2l0aW9uID8gdGhpcy5kcmFnUG9zaXRpb24uY29uY2F0KCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2V0IHBvc2l0aW9uKG5ld1Bvc2l0aW9uOiB1bmRlZmluZWQgfCBQb3NpdGlvbikge1xuICAgICAgICBpZiAobmV3UG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShuZXdQb3NpdGlvbikgfHxcbiAgICAgIG5ld1Bvc2l0aW9uLmxlbmd0aCAhPT0gMiB8fFxuICAgICAgdHlwZW9mIG5ld1Bvc2l0aW9uWzBdICE9PSBcIm51bWJlclwiIHx8XG4gICAgICB0eXBlb2YgbmV3UG9zaXRpb25bMV0gIT09IFwibnVtYmVyXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBtdXN0IGJlIFtudW1iZXIsIG51bWJlcl0gYXJyYXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uLmNvbmNhdCgpO1xuICAgIH1cblxuICAgIGRyYWcoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQsIHNlbGVjdGVkSWQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBoYXNTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGNsaWNrZWRGZWF0dXJlIH0gPSB0aGlzLmZlYXR1cmVzQXRNb3VzZUV2ZW50LmZpbmQoXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvblxuICAgICAgICApO1xuXG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgbm90IG92ZXIgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGZlYXR1cmUgdGhlbiB3ZSBkb24ndCB3YW50IHRvIGRyYWdcbiAgICAgICAgaWYgKCFjbGlja2VkRmVhdHVyZSB8fCBjbGlja2VkRmVhdHVyZS5pZCAhPT0gc2VsZWN0ZWRJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weShzZWxlY3RlZElkKTtcbiAgICAgICAgY29uc3QgbW91c2VDb29yZCA9IFtldmVudC5sbmcsIGV2ZW50LmxhdF07XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBvZiB0aGUgZHJhZ2dlZCBmZWF0dXJlXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIiB8fCBnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWRDb29yZHM6IFBvc2l0aW9uW10gfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgdXBUb0Nvb3JkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICB1cFRvQ29vcmQgPSB1cGRhdGVkQ29vcmRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIHVwVG9Db29yZCA9IHVwZGF0ZWRDb29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXBUb0Nvb3JkID09PSB1bmRlZmluZWQgfHwgIXVwZGF0ZWRDb29yZHMgfHwgIXRoaXMuZHJhZ1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwVG9Db29yZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IHVwZGF0ZWRDb29yZHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uWzBdIC0gbW91c2VDb29yZFswXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnUG9zaXRpb25bMV0gLSBtb3VzZUNvb3JkWzFdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvb3Jkc1tpXSA9IFtjb29yZGluYXRlWzBdIC0gZGVsdGFbMF0sIGNvb3JkaW5hdGVbMV0gLSBkZWx0YVsxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCBmaW5hbCBjb29yZGluYXRlIGlkZW50aWNhbCB0byBmaXJzdFxuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGRvIHRoaXMgZm9yIHBvbHlnb25zIVxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvb3Jkc1t1cGRhdGVkQ29vcmRzLmxlbmd0aCAtIDFdID0gW1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQ29vcmRzWzBdWzBdLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQ29vcmRzWzBdWzFdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3Rpb25Qb2ludHMgPVxuICAgICAgICB0aGlzLnNlbGVjdGlvblBvaW50cy5nZXRVcGRhdGVkKHVwZGF0ZWRDb29yZHMpIHx8IFtdO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTWlkUG9pbnRzID0gdGhpcy5taWRQb2ludHMuZ2V0VXBkYXRlZCh1cGRhdGVkQ29vcmRzKSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gSXNzdWUgdGhlIHVwZGF0ZSB0byB0aGUgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAgICAgeyBpZDogc2VsZWN0ZWRJZCwgZ2VvbWV0cnkgfSxcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVkU2VsZWN0aW9uUG9pbnRzLFxuICAgICAgICAgICAgICAgIC4uLnVwZGF0ZWRNaWRQb2ludHMsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIG1pZCBwb2ludCBwb3NpdGlvbnNcbiAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgIC8vIEZvciBtb3VzZSBwb2ludHMgd2UgY2FuIHNpbXBseSBtb3ZlIGl0XG4gICAgICAgICAgICAvLyB0byB0aGUgZHJhZ2dlZCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZDogc2VsZWN0ZWRJZCxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBtb3VzZUNvb3JkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFNFTEVDVF9QUk9QRVJUSUVTLCBUZXJyYURyYXdNb3VzZUV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IHsgQkJveFBvbHlnb24sIEdlb0pTT05TdG9yZUZlYXR1cmVzIH0gZnJvbSBcIi4uLy4uLy4uL3N0b3JlL3N0b3JlXCI7XG5cbmltcG9ydCB7IEJlaGF2aW9yQ29uZmlnLCBUZXJyYURyYXdNb2RlQmVoYXZpb3IgfSBmcm9tIFwiLi4vLi4vYmFzZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgQ2xpY2tCb3VuZGluZ0JveEJlaGF2aW9yIH0gZnJvbSBcIi4uLy4uL2NsaWNrLWJvdW5kaW5nLWJveC5iZWhhdmlvclwiO1xuXG5pbXBvcnQgeyBwb2ludEluUG9seWdvbiB9IGZyb20gXCIuLi8uLi8uLi9nZW9tZXRyeS9ib29sZWFuL3BvaW50LWluLXBvbHlnb25cIjtcbmltcG9ydCB7IFBpeGVsRGlzdGFuY2VCZWhhdmlvciB9IGZyb20gXCIuLi8uLi9waXhlbC1kaXN0YW5jZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgcGl4ZWxEaXN0YW5jZVRvTGluZSB9IGZyb20gXCIuLi8uLi8uLi9nZW9tZXRyeS9tZWFzdXJlL3BpeGVsLWRpc3RhbmNlLXRvLWxpbmVcIjtcblxuZXhwb3J0IGNsYXNzIEZlYXR1cmVzQXRNb3VzZUV2ZW50QmVoYXZpb3IgZXh0ZW5kcyBUZXJyYURyYXdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGNvbmZpZzogQmVoYXZpb3JDb25maWcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjcmVhdGVDbGlja0JvdW5kaW5nQm94OiBDbGlja0JvdW5kaW5nQm94QmVoYXZpb3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwaXhlbERpc3RhbmNlOiBQaXhlbERpc3RhbmNlQmVoYXZpb3JcbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmluZChldmVudDogVGVycmFEcmF3TW91c2VFdmVudCwgaGFzU2VsZWN0aW9uOiBib29sZWFuKSB7XG4gICAgICAgIGxldCBjbGlja2VkRmVhdHVyZTogR2VvSlNPTlN0b3JlRmVhdHVyZXMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjbGlja2VkRmVhdHVyZURpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbGlja2VkTWlkUG9pbnQ6IEdlb0pTT05TdG9yZUZlYXR1cmVzIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2xpY2tlZE1pZFBvaW50RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy5jcmVhdGVDbGlja0JvdW5kaW5nQm94LmNyZWF0ZShldmVudCk7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5zdG9yZS5zZWFyY2goYmJveCBhcyBCQm94UG9seWdvbik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNlbGVjdGlvbiBwb2ludHMgYWx3YXlzLCBhbmQgaWdub3JlIG1pZCBwb2ludHNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdGlvblBvaW50ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnNlbGVjdGlvblBvaW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTm9uU2VsZWN0ZWRNaWRQb2ludCA9XG4gICAgICAgICAgIWhhc1NlbGVjdGlvbiAmJiBmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuTUlEX1BPSU5UXTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1NlbGVjdGlvblBvaW50IHx8IGlzTm9uU2VsZWN0ZWRNaWRQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucGl4ZWxEaXN0YW5jZS5tZWFzdXJlKFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcblxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNhdGNoIGJvdGggY2xpY2tlZFxuICAgICAgICAgICAgICAgIC8vIGZlYXR1cmVzIGJ1dCBhbHNvIGFueSBtaWRwb2ludHNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgY2xpY2tlZCBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNbU0VMRUNUX1BST1BFUlRJRVMuTUlEX1BPSU5UXSAmJlxuICAgICAgICAgIGRpc3RhbmNlIDwgdGhpcy5wb2ludGVyRGlzdGFuY2UgJiZcbiAgICAgICAgICBkaXN0YW5jZSA8IGNsaWNrZWRNaWRQb2ludERpc3RhbmNlXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRNaWRQb2ludERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRNaWRQb2ludCA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWZlYXR1cmUucHJvcGVydGllc1tTRUxFQ1RfUFJPUEVSVElFUy5NSURfUE9JTlRdICYmXG4gICAgICAgICAgZGlzdGFuY2UgPCB0aGlzLnBvaW50ZXJEaXN0YW5jZSAmJlxuICAgICAgICAgIGRpc3RhbmNlIDwgY2xpY2tlZEZlYXR1cmVEaXN0YW5jZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjbGlja2VkRmVhdHVyZURpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrZWRGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29vcmQgPSBnZW9tZXRyeS5jb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dENvb3JkID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVRvTGluZSA9IHBpeGVsRGlzdGFuY2VUb0xpbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IGV2ZW50LmNvbnRhaW5lclgsIHk6IGV2ZW50LmNvbnRhaW5lclkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdChjb29yZFswXSwgY29vcmRbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0KG5leHRDb29yZFswXSwgbmV4dENvb3JkWzFdKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlVG9MaW5lIDwgdGhpcy5wb2ludGVyRGlzdGFuY2UgJiZcbiAgICAgICAgICAgIGRpc3RhbmNlVG9MaW5lIDwgY2xpY2tlZEZlYXR1cmVEaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRGZWF0dXJlRGlzdGFuY2UgPSBkaXN0YW5jZVRvTGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGlja0luc2lkZVBvbHlnb24gPSBwb2ludEluUG9seWdvbihcbiAgICAgICAgICAgICAgICAgICAgW2V2ZW50LmxuZywgZXZlbnQubGF0XSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrSW5zaWRlUG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICBjbGlja2VkRmVhdHVyZURpc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGNsaWNrZWRGZWF0dXJlLCBjbGlja2VkTWlkUG9pbnQgfTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBMaW5lU3RyaW5nLCBQb2ludCwgUG9seWdvbiwgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHsgQmVoYXZpb3JDb25maWcsIFRlcnJhRHJhd01vZGVCZWhhdmlvciB9IGZyb20gXCIuLi8uLi9iYXNlLmJlaGF2aW9yXCI7XG5pbXBvcnQge1xuICAgIGdldE1pZFBvaW50Q29vcmRpbmF0ZXMsXG4gICAgZ2V0TWlkUG9pbnRzLFxufSBmcm9tIFwiLi4vLi4vLi4vZ2VvbWV0cnkvZ2V0LW1pZHBvaW50c1wiO1xuaW1wb3J0IHsgU2VsZWN0aW9uUG9pbnRCZWhhdmlvciB9IGZyb20gXCIuL3NlbGVjdGlvbi1wb2ludC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgU0VMRUNUX1BST1BFUlRJRVMgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBNaWRQb2ludEJlaGF2aW9yIGV4dGVuZHMgVGVycmFEcmF3TW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBjb25maWc6IEJlaGF2aW9yQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VsZWN0aW9uUG9pbnRCZWhhdmlvcjogU2VsZWN0aW9uUG9pbnRCZWhhdmlvclxuICAgICkge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21pZFBvaW50czogc3RyaW5nW10gPSBbXTtcblxuICAgIGdldCBpZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taWRQb2ludHMuY29uY2F0KCk7XG4gICAgfVxuXG4gICAgc2V0IGlkcyhfOiBzdHJpbmdbXSkge31cblxuICAgIHB1YmxpYyBpbnNlcnQobWlkUG9pbnRJZDogc3RyaW5nLCBjb29yZGluYXRlUHJlY2lzaW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWlkUG9pbnQgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weShtaWRQb2ludElkKTtcbiAgICAgICAgY29uc3QgeyBtaWRQb2ludEZlYXR1cmVJZCwgbWlkUG9pbnRTZWdtZW50IH0gPVxuICAgICAgdGhpcy5zdG9yZS5nZXRQcm9wZXJ0aWVzQ29weShtaWRQb2ludElkKTtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxQb2x5Z29uIHwgTGluZVN0cmluZz4oXG4gICAgICBtaWRQb2ludEZlYXR1cmVJZCBhcyBzdHJpbmdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvb3JkaW5hdGVzIHRvIGluY2x1ZGUgaW5zZXJ0ZWQgbWlkcG9pbnRcbiAgICAgICAgY29uc3QgdXBkYXRlZENvb3JkaW5hdGVzID1cbiAgICAgIGdlb21ldHJ5LnR5cGUgPT09IFwiUG9seWdvblwiXG4gICAgICAgICAgPyBnZW9tZXRyeS5jb29yZGluYXRlc1swXVxuICAgICAgICAgIDogZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgdXBkYXRlZENvb3JkaW5hdGVzLnNwbGljZShcbiAgICAgICAgICAgIChtaWRQb2ludFNlZ21lbnQgYXMgbnVtYmVyKSArIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgbWlkUG9pbnQuY29vcmRpbmF0ZXMgYXMgUG9zaXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgZGVwZW5kaW5nXG4gICAgICAgIC8vIG9uIGlmIGEgcG9seWdvbiBvciBsaW5lc3RyaW5nXG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID1cbiAgICAgIGdlb21ldHJ5LnR5cGUgPT09IFwiUG9seWdvblwiID8gW3VwZGF0ZWRDb29yZGluYXRlc10gOiB1cGRhdGVkQ29vcmRpbmF0ZXM7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3RlZCBmZWF0dXJlcyBnZW9tZXRyeSB0byBpbnNlcnRcbiAgICAgICAgLy8gdGhlIG5ldyBtaWRwb2ludFxuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZUdlb21ldHJ5KFt7IGlkOiBtaWRQb2ludEZlYXR1cmVJZCBhcyBzdHJpbmcsIGdlb21ldHJ5IH1dKTtcblxuICAgICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIHdheSBvZiBqdXN0IHVwZGF0aW5nIHRoZSBzZWxlY3Rpb24gcG9pbnRzIHJhdGhlclxuICAgICAgICAvLyB0aGFuIGZ1bGx5IGRlbGV0aW5nIC8gcmVjcmVhdGluZz9cbiAgICAgICAgLy8gUmVjcmVhdGUgdGhlIHNlbGVjdGlvbiBwb2ludHNcblxuICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZShbLi4udGhpcy5fbWlkUG9pbnRzLCAuLi50aGlzLnNlbGVjdGlvblBvaW50QmVoYXZpb3IuaWRzXSk7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBpZiBmbGFncyBhcmUgY29ycmVjdFxuICAgICAgICAvLyBiZWNhdXNlIHNlbGVjdGlvbiBwb2ludHMgYXJlIHByZXJlcXVpc3RlIGZvciBtaWRwb2ludHNcbiAgICAgICAgdGhpcy5jcmVhdGUoXG4gICAgICAgICAgICB1cGRhdGVkQ29vcmRpbmF0ZXMsXG4gICAgICBtaWRQb2ludEZlYXR1cmVJZCBhcyBzdHJpbmcsXG4gICAgICBjb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUG9pbnRCZWhhdmlvci5jcmVhdGUoXG4gICAgICAgICAgICB1cGRhdGVkQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBnZW9tZXRyeS50eXBlLFxuICAgICAgbWlkUG9pbnRGZWF0dXJlSWQgYXMgc3RyaW5nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZShcbiAgICAgICAgc2VsZWN0ZWRDb29yZHM6IFBvc2l0aW9uW10sXG4gICAgICAgIGZlYXR1cmVJZDogc3RyaW5nLFxuICAgICAgICBjb29yZGluYXRlUHJlY2lzaW9uOiBudW1iZXJcbiAgICApIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JlLmhhcyhmZWF0dXJlSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9yZSBkb2VzIG5vdCBoYXZlIGZlYXR1cmUgd2l0aCB0aGlzIGlkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWlkUG9pbnRzID0gdGhpcy5zdG9yZS5jcmVhdGUoXG4gICAgICAgICAgICBnZXRNaWRQb2ludHMoXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRDb29yZHMsXG4gICAgICAgICAgICAgICAgKGkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgW1NFTEVDVF9QUk9QRVJUSUVTLk1JRF9QT0lOVF06IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1pZFBvaW50U2VnbWVudDogaSxcbiAgICAgICAgICAgICAgICAgICAgbWlkUG9pbnRGZWF0dXJlSWQ6IGZlYXR1cmVJZCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21pZFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKHRoaXMuX21pZFBvaW50cyk7XG4gICAgICAgICAgICB0aGlzLl9taWRQb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRVcGRhdGVkKHVwZGF0ZWRDb29yZGluYXRlczogUG9zaXRpb25bXSkge1xuICAgICAgICBpZiAodGhpcy5fbWlkUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRNaWRQb2ludENvb3JkaW5hdGVzKFxuICAgICAgICAgICAgdXBkYXRlZENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgdGhpcy5jb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICkubWFwKCh1cGRhdGVkTWlkUG9pbnRDb29yZCwgaSkgPT4gKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9taWRQb2ludHNbaV0gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHVwZGF0ZWRNaWRQb2ludENvb3JkLFxuICAgICAgICAgICAgfSBhcyBQb2ludCxcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFRlcnJhRHJhd01vdXNlRXZlbnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBCZWhhdmlvckNvbmZpZywgVGVycmFEcmF3TW9kZUJlaGF2aW9yIH0gZnJvbSBcIi4uLy4uL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IExpbmVTdHJpbmcsIFBvbHlnb24sIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IFNlbGVjdGlvblBvaW50QmVoYXZpb3IgfSBmcm9tIFwiLi9zZWxlY3Rpb24tcG9pbnQuYmVoYXZpb3JcIjtcbmltcG9ydCB7IE1pZFBvaW50QmVoYXZpb3IgfSBmcm9tIFwiLi9taWRwb2ludC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgdHJhbnNmb3JtUm90YXRlIH0gZnJvbSBcIi4uLy4uLy4uL2dlb21ldHJ5L3RyYW5zZm9ybS9yb3RhdGVcIjtcbmltcG9ydCB7IGNlbnRyb2lkIH0gZnJvbSBcIi4uLy4uLy4uL2dlb21ldHJ5L2NlbnRyb2lkXCI7XG5pbXBvcnQgeyByaHVtYkJlYXJpbmcgfSBmcm9tIFwiLi4vLi4vLi4vZ2VvbWV0cnkvbWVhc3VyZS9yaHVtYi1iZWFyaW5nXCI7XG5pbXBvcnQgeyBsaW1pdFByZWNpc2lvbiB9IGZyb20gXCIuLi8uLi8uLi9nZW9tZXRyeS9saW1pdC1kZWNpbWFsLXByZWNpc2lvblwiO1xuXG5leHBvcnQgY2xhc3MgUm90YXRlRmVhdHVyZUJlaGF2aW9yIGV4dGVuZHMgVGVycmFEcmF3TW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBjb25maWc6IEJlaGF2aW9yQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VsZWN0aW9uUG9pbnRzOiBTZWxlY3Rpb25Qb2ludEJlaGF2aW9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWlkUG9pbnRzOiBNaWRQb2ludEJlaGF2aW9yXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsYXN0QmVhcmluZzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubGFzdEJlYXJpbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcm90YXRlKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LCBzZWxlY3RlZElkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxMaW5lU3RyaW5nIHwgUG9seWdvbj4oXG4gICAgICAgICAgICBzZWxlY3RlZElkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBvZiB0aGUgZHJhZ2dlZCBmZWF0dXJlXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlICE9PSBcIlBvbHlnb25cIiAmJiBnZW9tZXRyeS50eXBlICE9PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW91c2VDb29yZCA9IFtldmVudC5sbmcsIGV2ZW50LmxhdF07XG5cbiAgICAgICAgY29uc3QgYmVhcmluZyA9IHJodW1iQmVhcmluZyhcbiAgICAgICAgICAgIGNlbnRyb2lkKHsgdHlwZTogXCJGZWF0dXJlXCIsIGdlb21ldHJ5LCBwcm9wZXJ0aWVzOiB7fSB9KSxcbiAgICAgICAgICAgIG1vdXNlQ29vcmRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBXZSBuZWVkIGFuIG9yaWdpbmFsIGJlYXJpbmcgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgICAgIGlmICghdGhpcy5sYXN0QmVhcmluZykge1xuICAgICAgICAgICAgdGhpcy5sYXN0QmVhcmluZyA9IGJlYXJpbmcgKyAxODA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMubGFzdEJlYXJpbmcgLSAoYmVhcmluZyArIDE4MCk7XG5cbiAgICAgICAgdHJhbnNmb3JtUm90YXRlKHsgdHlwZTogXCJGZWF0dXJlXCIsIGdlb21ldHJ5LCBwcm9wZXJ0aWVzOiB7fSB9LCAtYW5nbGUpO1xuXG4gICAgICAgIGxldCB1cGRhdGVkQ29vcmRzOiBQb3NpdGlvbltdIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgdXBkYXRlZENvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICB1cGRhdGVkQ29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjb29yZGluYXRlIHByZWNpc2lvbiBpcyBtYWludGFpbmVkXG4gICAgICAgIHVwZGF0ZWRDb29yZHMuZm9yRWFjaCgoY29vcmRpbmF0ZSkgPT4ge1xuICAgICAgICAgICAgY29vcmRpbmF0ZVswXSA9IGxpbWl0UHJlY2lzaW9uKGNvb3JkaW5hdGVbMF0sIHRoaXMuY29vcmRpbmF0ZVByZWNpc2lvbik7XG4gICAgICAgICAgICBjb29yZGluYXRlWzFdID0gbGltaXRQcmVjaXNpb24oY29vcmRpbmF0ZVsxXSwgdGhpcy5jb29yZGluYXRlUHJlY2lzaW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZE1pZFBvaW50cyA9IHRoaXMubWlkUG9pbnRzLmdldFVwZGF0ZWQodXBkYXRlZENvb3JkcykgfHwgW107XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFNlbGVjdGlvblBvaW50cyA9XG4gICAgICB0aGlzLnNlbGVjdGlvblBvaW50cy5nZXRVcGRhdGVkKHVwZGF0ZWRDb29yZHMpIHx8IFtdO1xuXG4gICAgICAgIC8vIElzc3VlIHRoZSB1cGRhdGUgdG8gdGhlIHNlbGVjdGVkIGZlYXR1cmVcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVHZW9tZXRyeShbXG4gICAgICAgICAgICB7IGlkOiBzZWxlY3RlZElkLCBnZW9tZXRyeSB9LFxuICAgICAgICAgICAgLi4udXBkYXRlZFNlbGVjdGlvblBvaW50cyxcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRNaWRQb2ludHMsXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMubGFzdEJlYXJpbmcgPSBiZWFyaW5nICsgMTgwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFRlcnJhRHJhd01vdXNlRXZlbnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBCZWhhdmlvckNvbmZpZywgVGVycmFEcmF3TW9kZUJlaGF2aW9yIH0gZnJvbSBcIi4uLy4uL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IExpbmVTdHJpbmcsIFBvbHlnb24sIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IFNlbGVjdGlvblBvaW50QmVoYXZpb3IgfSBmcm9tIFwiLi9zZWxlY3Rpb24tcG9pbnQuYmVoYXZpb3JcIjtcbmltcG9ydCB7IE1pZFBvaW50QmVoYXZpb3IgfSBmcm9tIFwiLi9taWRwb2ludC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgY2VudHJvaWQgfSBmcm9tIFwiLi4vLi4vLi4vZ2VvbWV0cnkvY2VudHJvaWRcIjtcbmltcG9ydCB7IGhhdmVyc2luZURpc3RhbmNlS2lsb21ldGVycyB9IGZyb20gXCIuLi8uLi8uLi9nZW9tZXRyeS9tZWFzdXJlL2hhdmVyc2luZS1kaXN0YW5jZVwiO1xuaW1wb3J0IHsgdHJhbnNmb3JtU2NhbGUgfSBmcm9tIFwiLi4vLi4vLi4vZ2VvbWV0cnkvdHJhbnNmb3JtL3NjYWxlXCI7XG5pbXBvcnQgeyBsaW1pdFByZWNpc2lvbiB9IGZyb20gXCIuLi8uLi8uLi9nZW9tZXRyeS9saW1pdC1kZWNpbWFsLXByZWNpc2lvblwiO1xuXG5leHBvcnQgY2xhc3MgU2NhbGVGZWF0dXJlQmVoYXZpb3IgZXh0ZW5kcyBUZXJyYURyYXdNb2RlQmVoYXZpb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGNvbmZpZzogQmVoYXZpb3JDb25maWcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3Rpb25Qb2ludHM6IFNlbGVjdGlvblBvaW50QmVoYXZpb3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtaWRQb2ludHM6IE1pZFBvaW50QmVoYXZpb3JcbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxhc3REaXN0YW5jZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubGFzdERpc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNjYWxlKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LCBzZWxlY3RlZElkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxMaW5lU3RyaW5nIHwgUG9seWdvbj4oXG4gICAgICAgICAgICBzZWxlY3RlZElkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBvZiB0aGUgZHJhZ2dlZCBmZWF0dXJlXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlICE9PSBcIlBvbHlnb25cIiAmJiBnZW9tZXRyeS50eXBlICE9PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW91c2VDb29yZCA9IFtldmVudC5sbmcsIGV2ZW50LmxhdF07XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBoYXZlcnNpbmVEaXN0YW5jZUtpbG9tZXRlcnMoXG4gICAgICAgICAgICBjZW50cm9pZCh7IHR5cGU6IFwiRmVhdHVyZVwiLCBnZW9tZXRyeSwgcHJvcGVydGllczoge30gfSksXG4gICAgICAgICAgICBtb3VzZUNvb3JkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gV2UgbmVlZCBhbiBvcmlnaW5hbCBiZWFyaW5nIHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgICAgICBpZiAoIXRoaXMubGFzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NhbGUgPSAxIC0gKHRoaXMubGFzdERpc3RhbmNlIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG5cbiAgICAgICAgdHJhbnNmb3JtU2NhbGUoeyB0eXBlOiBcIkZlYXR1cmVcIiwgZ2VvbWV0cnksIHByb3BlcnRpZXM6IHt9IH0sIHNjYWxlKTtcblxuICAgICAgICBsZXQgdXBkYXRlZENvb3JkczogUG9zaXRpb25bXSB8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRDb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgdXBkYXRlZENvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgY29vcmRpbmF0ZSBwcmVjaXNpb24gaXMgbWFpbnRhaW5lZFxuICAgICAgICB1cGRhdGVkQ29vcmRzLmZvckVhY2goKGNvb3JkaW5hdGUpID0+IHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVbMF0gPSBsaW1pdFByZWNpc2lvbihjb29yZGluYXRlWzBdLCB0aGlzLmNvb3JkaW5hdGVQcmVjaXNpb24pO1xuICAgICAgICAgICAgY29vcmRpbmF0ZVsxXSA9IGxpbWl0UHJlY2lzaW9uKGNvb3JkaW5hdGVbMV0sIHRoaXMuY29vcmRpbmF0ZVByZWNpc2lvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRNaWRQb2ludHMgPSB0aGlzLm1pZFBvaW50cy5nZXRVcGRhdGVkKHVwZGF0ZWRDb29yZHMpIHx8IFtdO1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3Rpb25Qb2ludHMgPVxuICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMuZ2V0VXBkYXRlZCh1cGRhdGVkQ29vcmRzKSB8fCBbXTtcblxuICAgICAgICAvLyBJc3N1ZSB0aGUgdXBkYXRlIHRvIHRoZSBzZWxlY3RlZCBmZWF0dXJlXG4gICAgICAgIHRoaXMuc3RvcmUudXBkYXRlR2VvbWV0cnkoW1xuICAgICAgICAgICAgeyBpZDogc2VsZWN0ZWRJZCwgZ2VvbWV0cnkgfSxcbiAgICAgICAgICAgIC4uLnVwZGF0ZWRTZWxlY3Rpb25Qb2ludHMsXG4gICAgICAgICAgICAuLi51cGRhdGVkTWlkUG9pbnRzLFxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLmxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IExpbmVTdHJpbmcsIFBvaW50LCBQb2x5Z29uLCBQb3NpdGlvbiB9IGZyb20gXCJnZW9qc29uXCI7XG5pbXBvcnQgeyBCZWhhdmlvckNvbmZpZywgVGVycmFEcmF3TW9kZUJlaGF2aW9yIH0gZnJvbSBcIi4uLy4uL2Jhc2UuYmVoYXZpb3JcIjtcbmltcG9ydCB7IGdldENvb3JkaW5hdGVzQXNQb2ludHMgfSBmcm9tIFwiLi4vLi4vLi4vZ2VvbWV0cnkvZ2V0LWNvb3JkaW5hdGVzLWFzLXBvaW50c1wiO1xuXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uUG9pbnRCZWhhdmlvciBleHRlbmRzIFRlcnJhRHJhd01vZGVCZWhhdmlvciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCZWhhdmlvckNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NlbGVjdGlvblBvaW50czogc3RyaW5nW10gPSBbXTtcblxuICAgIGdldCBpZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Qb2ludHMuY29uY2F0KCk7XG4gICAgfVxuXG4gICAgc2V0IGlkcyhfOiBzdHJpbmdbXSkge31cblxuICAgIHB1YmxpYyBjcmVhdGUoXG4gICAgICAgIHNlbGVjdGVkQ29vcmRzOiBQb3NpdGlvbltdLFxuICAgICAgICB0eXBlOiBQb2x5Z29uW1widHlwZVwiXSB8IExpbmVTdHJpbmdbXCJ0eXBlXCJdLFxuICAgICAgICBmZWF0dXJlSWQ6IHN0cmluZ1xuICAgICkge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb25Qb2ludHMgPSB0aGlzLnN0b3JlLmNyZWF0ZShcbiAgICAgICAgICAgIGdldENvb3JkaW5hdGVzQXNQb2ludHMoc2VsZWN0ZWRDb29yZHMsIHR5cGUsIChpKSA9PiAoe1xuICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Qb2ludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Qb2ludEZlYXR1cmVJZDogZmVhdHVyZUlkLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUodGhpcy5pZHMpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uUG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VXBkYXRlZCh1cGRhdGVkQ29vcmRpbmF0ZXM6IFBvc2l0aW9uW10pIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uUG9pbnRzLm1hcCgoaWQsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogdXBkYXRlZENvb3JkaW5hdGVzW2ldLFxuICAgICAgICAgICAgICAgIH0gYXMgUG9pbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0T25lVXBkYXRlZChpbmRleDogbnVtYmVyLCB1cGRhdGVkQ29vcmRpbmF0ZTogUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblBvaW50c1tpbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5fc2VsZWN0aW9uUG9pbnRzW2luZGV4XSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogdXBkYXRlZENvb3JkaW5hdGUsXG4gICAgICAgICAgICB9IGFzIFBvaW50LFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsImltcG9ydCB7XG4gICAgVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICBUZXJyYURyYXdLZXlib2FyZEV2ZW50LFxuICAgIFNFTEVDVF9QUk9QRVJUSUVTLFxufSBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBQb2ludCwgUG9zaXRpb24gfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHsgVGVycmFEcmF3QmFzZURyYXdNb2RlIH0gZnJvbSBcIi4uL2Jhc2UubW9kZVwiO1xuaW1wb3J0IHsgTWlkUG9pbnRCZWhhdmlvciB9IGZyb20gXCIuL2JlaGF2aW9ycy9taWRwb2ludC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgU2VsZWN0aW9uUG9pbnRCZWhhdmlvciB9IGZyb20gXCIuL2JlaGF2aW9ycy9zZWxlY3Rpb24tcG9pbnQuYmVoYXZpb3JcIjtcbmltcG9ydCB7IEZlYXR1cmVzQXRNb3VzZUV2ZW50QmVoYXZpb3IgfSBmcm9tIFwiLi9iZWhhdmlvcnMvZmVhdHVyZXMtYXQtbW91c2UtZXZlbnQuYmVoYXZpb3JcIjtcbmltcG9ydCB7IFBpeGVsRGlzdGFuY2VCZWhhdmlvciB9IGZyb20gXCIuLi9waXhlbC1kaXN0YW5jZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgQ2xpY2tCb3VuZGluZ0JveEJlaGF2aW9yIH0gZnJvbSBcIi4uL2NsaWNrLWJvdW5kaW5nLWJveC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgRHJhZ0ZlYXR1cmVCZWhhdmlvciB9IGZyb20gXCIuL2JlaGF2aW9ycy9kcmFnLWZlYXR1cmUuYmVoYXZpb3JcIjtcbmltcG9ydCB7IERyYWdDb29yZGluYXRlQmVoYXZpb3IgfSBmcm9tIFwiLi9iZWhhdmlvcnMvZHJhZy1jb29yZGluYXRlLmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBCZWhhdmlvckNvbmZpZyB9IGZyb20gXCIuLi9iYXNlLmJlaGF2aW9yXCI7XG5pbXBvcnQgeyBSb3RhdGVGZWF0dXJlQmVoYXZpb3IgfSBmcm9tIFwiLi9iZWhhdmlvcnMvcm90YXRlLWZlYXR1cmUuYmVoYXZpb3JcIjtcbmltcG9ydCB7IFNjYWxlRmVhdHVyZUJlaGF2aW9yIH0gZnJvbSBcIi4vYmVoYXZpb3JzL3NjYWxlLWZlYXR1cmUuYmVoYXZpb3JcIjtcblxudHlwZSBUZXJyYURyYXdTZWxlY3RNb2RlS2V5RXZlbnRzID0ge1xuICAgIGRlc2VsZWN0OiBLZXlib2FyZEV2ZW50W1wia2V5XCJdO1xuICAgIGRlbGV0ZTogS2V5Ym9hcmRFdmVudFtcImtleVwiXTtcbiAgICByb3RhdGU6IEtleWJvYXJkRXZlbnRbXCJrZXlcIl07XG4gICAgc2NhbGU6IEtleWJvYXJkRXZlbnRbXCJrZXlcIl07XG59O1xuXG50eXBlIE1vZGVGbGFncyA9IHtcbiAgICBmZWF0dXJlPzoge1xuICAgICAgICBkcmFnZ2FibGU/OiBib29sZWFuO1xuICAgICAgICByb3RhdGVhYmxlPzogYm9vbGVhbjtcbiAgICAgICAgc2NhbGVhYmxlPzogYm9vbGVhbjtcbiAgICAgICAgY29vcmRpbmF0ZXM/OiB7XG4gICAgICAgICAgICBtaWRwb2ludHM/OiBib29sZWFuO1xuICAgICAgICAgICAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcbiAgICAgICAgICAgIGRlbGV0YWJsZT86IGJvb2xlYW47XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5cbmV4cG9ydCBjbGFzcyBUZXJyYURyYXdTZWxlY3RNb2RlIGV4dGVuZHMgVGVycmFEcmF3QmFzZURyYXdNb2RlIHtcbiAgICBtb2RlID0gXCJzZWxlY3RcIjtcblxuICAgIHByaXZhdGUgZHJhZ0V2ZW50VGhyb3R0bGUgPSA1O1xuICAgIHByaXZhdGUgZHJhZ0V2ZW50Q291bnQgPSAwO1xuICAgIHByaXZhdGUgc2VsZWN0ZWQ6IHN0cmluZ1tdID0gW107XG5cbiAgICBwcml2YXRlIGZsYWdzOiB7IFttb2RlOiBzdHJpbmddOiBNb2RlRmxhZ3MgfTtcbiAgICBwcml2YXRlIGtleUV2ZW50czogVGVycmFEcmF3U2VsZWN0TW9kZUtleUV2ZW50cztcblxuICAgIC8vIEJlaGF2aW9yc1xuICAgIHByaXZhdGUgc2VsZWN0aW9uUG9pbnRzITogU2VsZWN0aW9uUG9pbnRCZWhhdmlvcjtcbiAgICBwcml2YXRlIG1pZFBvaW50cyE6IE1pZFBvaW50QmVoYXZpb3I7XG4gICAgcHJpdmF0ZSBmZWF0dXJlc0F0TW91c2VFdmVudCE6IEZlYXR1cmVzQXRNb3VzZUV2ZW50QmVoYXZpb3I7XG4gICAgcHJpdmF0ZSBwaXhlbERpc3RhbmNlITogUGl4ZWxEaXN0YW5jZUJlaGF2aW9yO1xuICAgIHByaXZhdGUgY2xpY2tCb3VuZGluZ0JveCE6IENsaWNrQm91bmRpbmdCb3hCZWhhdmlvcjtcbiAgICBwcml2YXRlIGRyYWdGZWF0dXJlITogRHJhZ0ZlYXR1cmVCZWhhdmlvcjtcbiAgICBwcml2YXRlIGRyYWdDb29yZGluYXRlITogRHJhZ0Nvb3JkaW5hdGVCZWhhdmlvcjtcbiAgICBwcml2YXRlIHJvdGF0ZUZlYXR1cmUhOiBSb3RhdGVGZWF0dXJlQmVoYXZpb3I7XG4gICAgcHJpdmF0ZSBzY2FsZUZlYXR1cmUhOiBTY2FsZUZlYXR1cmVCZWhhdmlvcjtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiB7XG4gICAgICAgIHBvaW50ZXJEaXN0YW5jZT86IG51bWJlcjtcbiAgICAgICAgZmxhZ3M/OiB7IFttb2RlOiBzdHJpbmddOiBNb2RlRmxhZ3MgfTtcbiAgICAgICAga2V5RXZlbnRzPzogVGVycmFEcmF3U2VsZWN0TW9kZUtleUV2ZW50cztcbiAgICAgICAgZHJhZ0V2ZW50VGhyb3R0bGU/OiBudW1iZXI7XG4gICAgfSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmZsYWdzID0gb3B0aW9ucyAmJiBvcHRpb25zLmZsYWdzID8gb3B0aW9ucy5mbGFncyA6IHt9O1xuXG4gICAgICAgIHRoaXMua2V5RXZlbnRzID1cbiAgICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5rZXlFdmVudHNcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMua2V5RXZlbnRzXG4gICAgICAgICAgICAgICAgOiB7IGRlc2VsZWN0OiBcIkVzY2FwZVwiLCBkZWxldGU6IFwiRGVsZXRlXCIsIHJvdGF0ZTogXCJyXCIsIHNjYWxlOiBcInNcIiB9O1xuXG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50VGhyb3R0bGUgPVxuICAgICAgICAgICAgKG9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRyYWdFdmVudFRocm90dGxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRyYWdFdmVudFRocm90dGxlKSB8fFxuICAgICAgICAgICAgNTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVnaXN0ZXJCZWhhdmlvcnMoY29uZmlnOiBCZWhhdmlvckNvbmZpZykge1xuICAgICAgICB0aGlzLnBpeGVsRGlzdGFuY2UgPSBuZXcgUGl4ZWxEaXN0YW5jZUJlaGF2aW9yKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2xpY2tCb3VuZGluZ0JveCA9IG5ldyBDbGlja0JvdW5kaW5nQm94QmVoYXZpb3IoY29uZmlnKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlc0F0TW91c2VFdmVudCA9IG5ldyBGZWF0dXJlc0F0TW91c2VFdmVudEJlaGF2aW9yKFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jbGlja0JvdW5kaW5nQm94LFxuICAgICAgICAgICAgdGhpcy5waXhlbERpc3RhbmNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMgPSBuZXcgU2VsZWN0aW9uUG9pbnRCZWhhdmlvcihjb25maWcpO1xuICAgICAgICB0aGlzLm1pZFBvaW50cyA9IG5ldyBNaWRQb2ludEJlaGF2aW9yKGNvbmZpZywgdGhpcy5zZWxlY3Rpb25Qb2ludHMpO1xuXG4gICAgICAgIHRoaXMucm90YXRlRmVhdHVyZSA9IG5ldyBSb3RhdGVGZWF0dXJlQmVoYXZpb3IoXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblBvaW50cyxcbiAgICAgICAgICAgIHRoaXMubWlkUG9pbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zY2FsZUZlYXR1cmUgPSBuZXcgU2NhbGVGZWF0dXJlQmVoYXZpb3IoXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblBvaW50cyxcbiAgICAgICAgICAgIHRoaXMubWlkUG9pbnRzXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5kcmFnRmVhdHVyZSA9IG5ldyBEcmFnRmVhdHVyZUJlaGF2aW9yKFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc0F0TW91c2VFdmVudCxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uUG9pbnRzLFxuICAgICAgICAgICAgdGhpcy5taWRQb2ludHNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kcmFnQ29vcmRpbmF0ZSA9IG5ldyBEcmFnQ29vcmRpbmF0ZUJlaGF2aW9yKFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5waXhlbERpc3RhbmNlLFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMsXG4gICAgICAgICAgICB0aGlzLm1pZFBvaW50c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUudXBkYXRlUHJvcGVydHkoXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLm1hcCgoaWQpID0+ICh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IFNFTEVDVF9QUk9QRVJUSUVTLlNFTEVDVEVELFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMub25EZXNlbGVjdCh0aGlzLnNlbGVjdGVkWzBdKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblBvaW50cy5kZWxldGUoKTtcbiAgICAgICAgdGhpcy5taWRQb2ludHMuZGVsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZWxldGVTZWxlY3RlZCgpIHtcbiAgICAgICAgLy8gRGVsZXRlIGFsbCBzZWxlY3RlZCBmZWF0dXJlc1xuICAgICAgICAvLyBmcm9tIHRoZSBzdG9yZSBhbmQgY2xlYXIgc2VsZWN0ZWRcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzZXQgc2VsZWN0ZWQgZmFsc2VcbiAgICAgICAgLy8gYXMgd2UncmUgZ29pbmcgdG8gZGVsZXRlIHRoZSBmZWF0dXJlXG5cbiAgICAgICAgdGhpcy5zdG9yZS5kZWxldGUodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uUmlnaHRDbGljayhldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uUG9pbnRzLmlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjbGlja2VkU2VsZWN0aW9uUG9pbnRQcm9wczpcbiAgICAgICAgICAgIHwge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblBvaW50RmVhdHVyZUlkOiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGxldCBjbGlja2VkRmVhdHVyZURpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMuaWRzLmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8UG9pbnQ+KGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5waXhlbERpc3RhbmNlLm1lYXN1cmUoZXZlbnQsIGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlIDwgdGhpcy5wb2ludGVyRGlzdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA8IGNsaWNrZWRGZWF0dXJlRGlzdGFuY2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNsaWNrZWRGZWF0dXJlRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjbGlja2VkU2VsZWN0aW9uUG9pbnRQcm9wcyA9IHRoaXMuc3RvcmUuZ2V0UHJvcGVydGllc0NvcHkoaWQpIGFzIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUG9pbnRGZWF0dXJlSWQ6IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWNsaWNrZWRTZWxlY3Rpb25Qb2ludFByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmZWF0dXJlSWQgPSBjbGlja2VkU2VsZWN0aW9uUG9pbnRQcm9wcy5zZWxlY3Rpb25Qb2ludEZlYXR1cmVJZDtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZUluZGV4ID0gY2xpY2tlZFNlbGVjdGlvblBvaW50UHJvcHMuaW5kZXg7XG5cbiAgICAgICAgLy8gV2UgYWxsb3cgZm9yIHByZXZlbnRpbmcgZGVsZXRpbmcgY29vcmRpbmF0ZXMgdmlhIGZsYWdzXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLnN0b3JlLmdldFByb3BlcnRpZXNDb3B5KGZlYXR1cmVJZCk7XG4gICAgICAgIGNvbnN0IG1vZGVGbGFncyA9IHRoaXMuZmxhZ3NbcHJvcGVydGllcy5tb2RlIGFzIHN0cmluZ107XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIGFjdHVhbGx5IGRlbGV0ZSB0aGUgY29vcmRpbmF0ZVxuICAgICAgICBjb25zdCBjYW5ub3REZWxldGUgPSAhbW9kZUZsYWdzIHx8XG4gICAgICAgICAgICAhbW9kZUZsYWdzLmZlYXR1cmUgfHxcbiAgICAgICAgICAgICFtb2RlRmxhZ3MuZmVhdHVyZS5jb29yZGluYXRlcyB8fFxuICAgICAgICAgICAgIW1vZGVGbGFncy5mZWF0dXJlLmNvb3JkaW5hdGVzLmRlbGV0YWJsZTtcblxuICAgICAgICBpZiAoY2Fubm90RGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuc3RvcmUuZ2V0R2VvbWV0cnlDb3B5KGZlYXR1cmVJZCk7XG5cbiAgICAgICAgbGV0IGNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgY3JlYXRpbmcgYW4gaW52YWxpZCBwb2x5Z29uXG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgY3JlYXRpbmcgYW4gaW52YWxpZCBsaW5lc3RyaW5nXG4gICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDw9IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW9tZXRyeSBpcyBub3QgUG9seWdvbiBvciBMaW5lU3RyaW5nXG4gICAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIiAmJiBjb29yZGluYXRlSW5kZXggPT09IDApIHx8XG4gICAgICAgICAgICBjb29yZGluYXRlSW5kZXggPT09IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBEZWxldGluZyB0aGUgZmluYWwgY29vcmRpbmF0ZSBpbiBhIHBvbHlnb24gYnJlYWtzIGl0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIEdlb0pTT04gZXhwZWN0cyBhIGR1cGxpY2F0ZSwgc28gd2UgbmVlZCB0byBmaXhcbiAgICAgICAgICAgIC8vIGl0IGJ5IGFkZGluZyB0aGUgbmV3IGZpcnN0IGNvb3JkaW5hdGUgdG8gdGhlIGVuZFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMucHVzaChbY29vcmRpbmF0ZXNbMF1bMF0sIGNvb3JkaW5hdGVzWzBdWzFdXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY29vcmRpbmF0ZSBmcm9tIGFycmF5XG4gICAgICAgICAgICBjb29yZGluYXRlcy5zcGxpY2UoY29vcmRpbmF0ZUluZGV4LCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcmUuZGVsZXRlKFsuLi50aGlzLm1pZFBvaW50cy5pZHMsIC4uLnRoaXMuc2VsZWN0aW9uUG9pbnRzLmlkc10pO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZUdlb21ldHJ5KFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogZmVhdHVyZUlkLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMuY3JlYXRlKFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICAgICAgICBnZW9tZXRyeS50eXBlIGFzIFwiUG9seWdvblwiIHwgXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICBmZWF0dXJlSWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtb2RlRmxhZ3MgJiZcbiAgICAgICAgICAgIG1vZGVGbGFncy5mZWF0dXJlICYmXG4gICAgICAgICAgICBtb2RlRmxhZ3MuZmVhdHVyZS5jb29yZGluYXRlcyAmJlxuICAgICAgICAgICAgbW9kZUZsYWdzLmZlYXR1cmUuY29vcmRpbmF0ZXMubWlkcG9pbnRzXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5taWRQb2ludHMuY3JlYXRlKGNvb3JkaW5hdGVzLCBmZWF0dXJlSWQsIHRoaXMuY29vcmRpbmF0ZVByZWNpc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uTGVmdENsaWNrKGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY2xpY2tlZEZlYXR1cmUsIGNsaWNrZWRNaWRQb2ludCB9ID0gdGhpcy5mZWF0dXJlc0F0TW91c2VFdmVudC5maW5kKFxuICAgICAgICAgICAgZXZlbnQsXG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQubGVuZ3RoID4gMFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmxlbmd0aCAmJiBjbGlja2VkTWlkUG9pbnQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIHByb2JhYmx5IHdhbnQgdG8gbWFrZSBzdXJlIHRoZSBtaWRwb2ludFxuICAgICAgICAgICAgLy8gaXMgdmlzaWJsZT9cblxuICAgICAgICAgICAgdGhpcy5taWRQb2ludHMuaW5zZXJ0KFxuICAgICAgICAgICAgICAgIGNsaWNrZWRNaWRQb2ludC5pZCBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZGluYXRlUHJlY2lzaW9uXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xpY2tlZEZlYXR1cmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gdGhpcy5zdG9yZS5nZXRQcm9wZXJ0aWVzQ29weShcbiAgICAgICAgICAgICAgICBjbGlja2VkRmVhdHVyZS5pZCBhcyBzdHJpbmdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzbHlTZWxlY3RlZElkID0gdGhpcy5zZWxlY3RlZFswXTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21ldGhpbmcgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICAgICAgICBpZiAocHJldmlvdXNseVNlbGVjdGVkSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIGZlYXR1cmUgaWQsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNseVNlbGVjdGVkSWQgPT09IGNsaWNrZWRGZWF0dXJlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgZGlmZmVyZW50IGZlYXR1cmUgc2V0IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGZhbHNlIG9uIHByZXZpb3VzbHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdW5kZWZpbmVkIGZvciBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IG1vZGVGbGFncyA9IHRoaXMuZmxhZ3NbbW9kZSBhcyBzdHJpbmddO1xuXG4gICAgICAgICAgICAvLyBJZiBmZWF0dXJlIGlzIG5vdCBzZWxlY3RhYmxlIHRoZW4gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIW1vZGVGbGFncyB8fCAhbW9kZUZsYWdzLmZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdCBmZWF0dXJlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gW2NsaWNrZWRGZWF0dXJlLmlkIGFzIHN0cmluZ107XG4gICAgICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVByb3BlcnR5KFtcbiAgICAgICAgICAgICAgICB7IGlkOiBjbGlja2VkRmVhdHVyZS5pZCBhcyBzdHJpbmcsIHByb3BlcnR5OiBcInNlbGVjdGVkXCIsIHZhbHVlOiB0cnVlIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3QoY2xpY2tlZEZlYXR1cmUuaWQgYXMgc3RyaW5nKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjbGlja2VkIGZlYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgY29vcmRpbmF0ZXMgfSA9IHRoaXMuc3RvcmUuZ2V0R2VvbWV0cnlDb3B5KFxuICAgICAgICAgICAgICAgIGNsaWNrZWRGZWF0dXJlLmlkIGFzIHN0cmluZ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkQ29vcmRzOiBQb3NpdGlvbltdIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRDb29yZHMgPSBjb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZENvb3JkcyA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDb29yZHMgJiYgbW9kZUZsYWdzICYmIG1vZGVGbGFncy5mZWF0dXJlLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Qb2ludHMuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENvb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEZlYXR1cmUuaWQgYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlRmxhZ3MuZmVhdHVyZS5jb29yZGluYXRlcy5taWRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWRQb2ludHMuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRDb29yZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja2VkRmVhdHVyZS5pZCBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3JkaW5hdGVQcmVjaXNpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0ZWQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdG9wcGVkKCk7XG4gICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgIH1cblxuICAgIG9uQ2xpY2soZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmlnaHRDbGljayhldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgdGhpcy5vbkxlZnRDbGljayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25LZXlEb3duKCkgeyB9XG4gICAgb25LZXlVcChldmVudDogVGVycmFEcmF3S2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSB0aGlzLmtleUV2ZW50cy5kZWxldGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGFyZSB0ZWNobmljYWxseSBkZXNlbGVjdGluZ1xuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2VsZWN0ZWQgZmVhdHVyZSBpcyBkZWxldGVkXG4gICAgICAgICAgICAvLyBhbmQgd2lsbCBubyBsb25nZXIgZXhpc3Qgb3IgYmUgc2VsZWN0ZWRcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzbHlTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRbMF07XG4gICAgICAgICAgICB0aGlzLm9uRGVzZWxlY3QocHJldmlvdXNseVNlbGVjdGVkKTtcblxuICAgICAgICAgICAgLy8gRGVsZXRlIGFsbCBzZWxlY3RlZCBmZWF0dXJlc1xuICAgICAgICAgICAgdGhpcy5kZWxldGVTZWxlY3RlZCgpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIHNlbGVjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uUG9pbnRzLmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5taWRQb2ludHMuZGVsZXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSB0aGlzLmtleUV2ZW50cy5kZXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW5VcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25EcmFnU3RhcnQoXG4gICAgICAgIGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LFxuICAgICAgICBzZXRNYXBEcmFnZ2FiaWxpdHk6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkXG4gICAgKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBzdG9wIHRoZSBtYXAgZHJhZ2dpbmcgaWZcbiAgICAgICAgLy8gd2UgYWN0dWFsbHkgaGF2ZSBzb21ldGhpbmcgc2VsZWN0ZWRcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkIGZlYXR1cmUgaXMgbm90IGRyYWdnYWJsZVxuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5zdG9yZS5nZXRQcm9wZXJ0aWVzQ29weSh0aGlzLnNlbGVjdGVkWzBdKTtcbiAgICAgICAgY29uc3QgbW9kZUZsYWdzID0gdGhpcy5mbGFnc1twcm9wZXJ0aWVzLm1vZGUgYXMgc3RyaW5nXTtcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlID1cbiAgICAgICAgICAgIG1vZGVGbGFncyAmJlxuICAgICAgICAgICAgbW9kZUZsYWdzLmZlYXR1cmUgJiZcbiAgICAgICAgICAgIChtb2RlRmxhZ3MuZmVhdHVyZS5kcmFnZ2FibGUgfHxcbiAgICAgICAgICAgICAgICAobW9kZUZsYWdzLmZlYXR1cmUuY29vcmRpbmF0ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9kZUZsYWdzLmZlYXR1cmUuY29vcmRpbmF0ZXMuZHJhZ2dhYmxlKSk7XG5cbiAgICAgICAgaWYgKCFkcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcImdyYWJiaW5nXCIpO1xuICAgICAgICB0aGlzLmRyYWdGZWF0dXJlLnBvc2l0aW9uID0gW2V2ZW50LmxuZywgZXZlbnQubGF0XTtcblxuICAgICAgICBzZXRNYXBEcmFnZ2FiaWxpdHkoZmFsc2UpO1xuICAgIH1cblxuICAgIG9uRHJhZyhldmVudDogVGVycmFEcmF3TW91c2VFdmVudCkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZElkID0gdGhpcy5zZWxlY3RlZFswXTtcblxuICAgICAgICAvLyBJZiBub3RoaW5nIHNlbGVjdGVkIG9yIHRoZSBkcmFnIHBvc2l0aW9uIGhhc24ndCBiZWVuIHNldFxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIGlmICghc2VsZWN0ZWRJZCB8fCAhdGhpcy5kcmFnRmVhdHVyZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuc3RvcmUuZ2V0UHJvcGVydGllc0NvcHkoc2VsZWN0ZWRJZCk7XG4gICAgICAgIGNvbnN0IG1vZGVGbGFncyA9IHRoaXMuZmxhZ3NbcHJvcGVydGllcy5tb2RlIGFzIHN0cmluZ107XG5cbiAgICAgICAgLy8gRW5zdXJlIGRyYWcgY291bnQgaXMgaW5jcmVtZW50ZWRcbiAgICAgICAgdGhpcy5kcmFnRXZlbnRDb3VudCsrO1xuXG4gICAgICAgIC8vIFJldHVybiBpZiB3ZSBoYXZlbid0IGhpdCB0aGUgZHJhZyB0aHJvdHRsZSBsaW1pdFxuICAgICAgICAvLyAoaS5lLiB3ZSBvbmx5IHdhbnQgdG8gZHJhZyBldmVyeSBudGggZXZlbnQpXG4gICAgICAgIGlmICh0aGlzLmRyYWdFdmVudENvdW50ICUgdGhpcy5kcmFnRXZlbnRUaHJvdHRsZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2hvdWxkIHJvdGF0ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtb2RlRmxhZ3MgJiZcbiAgICAgICAgICAgIG1vZGVGbGFncy5mZWF0dXJlICYmXG4gICAgICAgICAgICBtb2RlRmxhZ3MuZmVhdHVyZS5yb3RhdGVhYmxlICYmXG4gICAgICAgICAgICBldmVudC5oZWxkS2V5cy5pbmNsdWRlcyhcInJcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZUZlYXR1cmUucm90YXRlKGV2ZW50LCBzZWxlY3RlZElkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHNob3VsZCBzY2FsZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBtb2RlRmxhZ3MgJiZcbiAgICAgICAgICAgIG1vZGVGbGFncy5mZWF0dXJlICYmXG4gICAgICAgICAgICBtb2RlRmxhZ3MuZmVhdHVyZS5zY2FsZWFibGUgJiZcbiAgICAgICAgICAgIGV2ZW50LmhlbGRLZXlzLmluY2x1ZGVzKFwic1wiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVGZWF0dXJlLnNjYWxlKGV2ZW50LCBzZWxlY3RlZElkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGUgaXMgZHJhZ2dhYmxlIGFuZCBpcyBkcmFnZ2VkXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1vZGVGbGFncyAmJlxuICAgICAgICAgICAgbW9kZUZsYWdzLmZlYXR1cmUgJiZcbiAgICAgICAgICAgIG1vZGVGbGFncy5mZWF0dXJlLmNvb3JkaW5hdGVzICYmXG4gICAgICAgICAgICBtb2RlRmxhZ3MuZmVhdHVyZS5jb29yZGluYXRlcy5kcmFnZ2FibGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlV2FzRHJhZ2dlZCA9IHRoaXMuZHJhZ0Nvb3JkaW5hdGUuZHJhZyhldmVudCwgc2VsZWN0ZWRJZCk7XG5cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlV2FzRHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGZlYXR1cmUgaXMgZHJhZ2dhYmxlIGFuZCBpcyBkcmFnZ2VkXG4gICAgICAgIGlmIChtb2RlRmxhZ3MgJiYgbW9kZUZsYWdzLmZlYXR1cmUgJiYgbW9kZUZsYWdzLmZlYXR1cmUuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdGZWF0dXJlLmRyYWcoZXZlbnQsIHNlbGVjdGVkSWQpO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdGZWF0dXJlLnBvc2l0aW9uID0gW2V2ZW50LmxuZywgZXZlbnQubGF0XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRHJhZ0VuZChcbiAgICAgICAgXzogVGVycmFEcmF3TW91c2VFdmVudCxcbiAgICAgICAgc2V0TWFwRHJhZ2dhYmlsaXR5OiAoZW5hYmxlZDogYm9vbGVhbikgPT4gdm9pZFxuICAgICkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcihcImdyYWJcIik7XG4gICAgICAgIHRoaXMuZHJhZ0ZlYXR1cmUucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucm90YXRlRmVhdHVyZS5yZXNldCgpO1xuICAgICAgICB0aGlzLnNjYWxlRmVhdHVyZS5yZXNldCgpO1xuICAgICAgICBzZXRNYXBEcmFnZ2FiaWxpdHkodHJ1ZSk7XG4gICAgfVxuXG4gICAgb25Nb3VzZU1vdmUoZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkLmxlbmd0aCB8fCB0aGlzLmRyYWdGZWF0dXJlLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmVhcmJ5U2VsZWN0aW9uUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taWRQb2ludHMuaWRzLmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGlmIChuZWFyYnlTZWxlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5zdG9yZS5nZXRHZW9tZXRyeUNvcHk8UG9pbnQ+KGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5waXhlbERpc3RhbmNlLm1lYXN1cmUoZXZlbnQsIGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcblxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5wb2ludGVyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBuZWFyYnlTZWxlY3Rpb25Qb2ludCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IElzIHRoZXJlIGEgY2xlYW5lciB3YXkgdG8gaGFuZGxlIHByaW9yaXRpc2luZ1xuICAgICAgICAvLyBkcmFnZ2luZyBzZWxlY3Rpb24gcG9pbnRzP1xuICAgICAgICB0aGlzLnNlbGVjdGlvblBvaW50cy5pZHMuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLnN0b3JlLmdldEdlb21ldHJ5Q29weTxQb2ludD4oaWQpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnBpeGVsRGlzdGFuY2UubWVhc3VyZShldmVudCwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5wb2ludGVyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBuZWFyYnlTZWxlY3Rpb25Qb2ludCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5lYXJieVNlbGVjdGlvblBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihcImNyb3NzaGFpclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKFwidW5zZXRcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCZWhhdmlvckNvbmZpZywgVGVycmFEcmF3TW9kZUJlaGF2aW9yIH0gZnJvbSBcIi4vYmFzZS5iZWhhdmlvclwiO1xuaW1wb3J0IHsgVGVycmFEcmF3TW91c2VFdmVudCB9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IEZlYXR1cmUsIFBvbHlnb24sIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IENsaWNrQm91bmRpbmdCb3hCZWhhdmlvciB9IGZyb20gXCIuL2NsaWNrLWJvdW5kaW5nLWJveC5iZWhhdmlvclwiO1xuaW1wb3J0IHsgQkJveFBvbHlnb24gfSBmcm9tIFwiLi4vc3RvcmUvc3RvcmVcIjtcbmltcG9ydCB7IFBpeGVsRGlzdGFuY2VCZWhhdmlvciB9IGZyb20gXCIuL3BpeGVsLWRpc3RhbmNlLmJlaGF2aW9yXCI7XG5cbmV4cG9ydCBjbGFzcyBTbmFwcGluZ0JlaGF2aW9yIGV4dGVuZHMgVGVycmFEcmF3TW9kZUJlaGF2aW9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBjb25maWc6IEJlaGF2aW9yQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcGl4ZWxEaXN0YW5jZTogUGl4ZWxEaXN0YW5jZUJlaGF2aW9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2xpY2tCb3VuZGluZ0JveDogQ2xpY2tCb3VuZGluZ0JveEJlaGF2aW9yXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNuYXBwYWJsZUNvb3JkaW5hdGUgPSAoXG4gICAgICAgIGV2ZW50OiBUZXJyYURyYXdNb3VzZUV2ZW50LFxuICAgICAgICBjdXJyZW50RmVhdHVyZUlkOiBzdHJpbmdcbiAgICApID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U25hcHBhYmxlKGV2ZW50LCAoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzICYmXG4gICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLm1vZGUgPT09IHRoaXMubW9kZSAmJlxuICAgICAgICAgIGZlYXR1cmUuaWQgIT09IGN1cnJlbnRGZWF0dXJlSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwcml2YXRlIGdldFNuYXBwYWJsZShcbiAgICAgICAgZXZlbnQ6IFRlcnJhRHJhd01vdXNlRXZlbnQsXG4gICAgICAgIGZpbHRlcjogKGZlYXR1cmU6IEZlYXR1cmUpID0+IGJvb2xlYW5cbiAgICApIHtcbiAgICAgICAgY29uc3QgYmJveCA9IHRoaXMuY2xpY2tCb3VuZGluZ0JveC5jcmVhdGUoZXZlbnQpIGFzIEJCb3hQb2x5Z29uO1xuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5zdG9yZS5zZWFyY2goYmJveCwgZmlsdGVyKTtcblxuICAgICAgICBjb25zdCBjbG9zZXN0OiB7IGNvb3JkOiB1bmRlZmluZWQgfCBQb3NpdGlvbjsgbWluRGlzdDogbnVtYmVyIH0gPSB7XG4gICAgICAgICAgICBjb29yZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluRGlzdDogSW5maW5pdHksXG4gICAgICAgIH07XG5cbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvb3JkaW5hdGVzOiBQb3NpdGlvbltdO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaCgoY29vcmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5waXhlbERpc3RhbmNlLm1lYXN1cmUoZXZlbnQsIGNvb3JkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IGNsb3Nlc3QubWluRGlzdCAmJiBkaXN0IDwgdGhpcy5wb2ludGVyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdC5jb29yZCA9IGNvb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2xvc2VzdC5jb29yZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUZXJyYURyYXdCYXNlRHJhd01vZGUgfSBmcm9tIFwiLi4vYmFzZS5tb2RlXCI7XG5cbmV4cG9ydCBjbGFzcyBUZXJyYURyYXdTdGF0aWNNb2RlIGV4dGVuZHMgVGVycmFEcmF3QmFzZURyYXdNb2RlIHtcbiAgICBtb2RlID0gXCJzdGF0aWNcIjtcbiAgICBzdGFydCgpIHt9XG4gICAgc3RvcCgpIHt9XG4gICAgb25LZXlVcCgpIHt9XG4gICAgb25LZXlEb3duKCkge31cbiAgICBvbkNsaWNrKCkge31cbiAgICBvbkRyYWdTdGFydCgpIHt9XG4gICAgb25EcmFnKCkge31cbiAgICBvbkRyYWdFbmQoKSB7fVxuICAgIG9uTW91c2VNb3ZlKCkge31cbn1cbiIsIi8vIElTQyBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTgsIFZsYWRpbWlyIEFnYWZvbmtpblxuXG5leHBvcnQgdHlwZSBDb21wYXJlRnVuY3Rpb248VD4gPSAoYTogVCwgYjogVCkgPT4gbnVtYmVyO1xuXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tzZWxlY3Q8VD4oXG4gICAgYXJyOiBUW10sXG4gICAgazogbnVtYmVyLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICByaWdodDogbnVtYmVyLFxuICAgIGNvbXBhcmU6IENvbXBhcmVGdW5jdGlvbjxUPlxuKSB7XG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICBjb25zdCB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICBjb25zdCBzID0gMC41ICogTWF0aC5leHAoKDIgKiB6KSAvIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2QgPVxuICAgICAgICAwLjUgKiBNYXRoLnNxcnQoKHogKiBzICogKG4gLSBzKSkgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSAobSAqIHMpIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAoKG4gLSBtKSAqIHMpIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHQgPSBhcnJba107XG4gICAgICAgIGxldCBpID0gbGVmdDtcbiAgICAgICAgbGV0IGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkge1xuICAgICAgICAgICAgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXA8VD4oYXJyOiBUW10sIGk6IG51bWJlciwgajogbnVtYmVyKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG4iLCIvLyBCYXNlIG9uIFJidXNoIC0gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2hcbi8vIE1JVCBMaWNlbnNlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgVmxhZGltaXIgQWdhZm9ua2luXG5cbmltcG9ydCB7IENvbXBhcmVGdW5jdGlvbiwgcXVpY2tzZWxlY3QgfSBmcm9tIFwiLi9xdWlja3NlbGVjdFwiO1xuXG5leHBvcnQgdHlwZSBOb2RlID0ge1xuICBjaGlsZHJlbjogTm9kZVtdO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgbGVhZjogYm9vbGVhbjtcbiAgbWluWDogbnVtYmVyO1xuICBtaW5ZOiBudW1iZXI7XG4gIG1heFg6IG51bWJlcjtcbiAgbWF4WTogbnVtYmVyO1xufTtcblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZTogTm9kZSwgdG9CQm94OiAobm9kZTogTm9kZSkgPT4gYW55KSB7XG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChcbiAgICBub2RlOiBOb2RlLFxuICAgIGs6IG51bWJlcixcbiAgICBwOiBudW1iZXIsXG4gICAgdG9CQm94OiAobm9kZTogTm9kZSkgPT4gTm9kZSxcbiAgICBkZXN0Tm9kZT86IE5vZGVcbikge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGxldCBpID0gazsgaSA8IHA7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhOiBOb2RlLCBiOiBOb2RlKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYTogTm9kZSwgYjogTm9kZSkge1xuICAgIHJldHVybiBhLm1pblggLSBiLm1pblg7XG59XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYTogTm9kZSwgYjogTm9kZSkge1xuICAgIHJldHVybiBhLm1pblkgLSBiLm1pblk7XG59XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGE6IE5vZGUpIHtcbiAgICByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTtcbn1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYToge1xuICBtaW5YOiBudW1iZXI7XG4gIG1pblk6IG51bWJlcjtcbiAgbWF4WDogbnVtYmVyO1xuICBtYXhZOiBudW1iZXI7XG59KSB7XG4gICAgcmV0dXJuIGEubWF4WCAtIGEubWluWCArIChhLm1heFkgLSBhLm1pblkpO1xufVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYTogTm9kZSwgYjogTm9kZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYTogTm9kZSwgYjogTm9kZSkge1xuICAgIGNvbnN0IG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCk7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKTtcbiAgICBjb25zdCBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpO1xuICAgIGNvbnN0IG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICogTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhOiBOb2RlLCBiOiBOb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgYS5taW5YIDw9IGIubWluWCAmJiBhLm1pblkgPD0gYi5taW5ZICYmIGIubWF4WCA8PSBhLm1heFggJiYgYi5tYXhZIDw9IGEubWF4WVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYTogTm9kZSwgYjogTm9kZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIGIubWluWCA8PSBhLm1heFggJiYgYi5taW5ZIDw9IGEubWF4WSAmJiBiLm1heFggPj0gYS5taW5YICYmIGIubWF4WSA+PSBhLm1pbllcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuOiBOb2RlW10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5LFxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0PFQ+KFxuICAgIGFycjogVFtdLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICByaWdodDogbnVtYmVyLFxuICAgIG46IG51bWJlcixcbiAgICBjb21wYXJlOiBDb21wYXJlRnVuY3Rpb248VD5cbikge1xuICAgIGNvbnN0IHN0YWNrID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKSBhcyBudW1iZXI7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKSBhcyBudW1iZXI7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUkJ1c2gge1xuICAgIHByaXZhdGUgX21heEVudHJpZXM6IG51bWJlcjtcbiAgICBwcml2YXRlIF9taW5FbnRyaWVzOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBkYXRhITogTm9kZTtcblxuICAgIGNvbnN0cnVjdG9yKG1heEVudHJpZXM6IG51bWJlcikge1xuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZWFyY2goYmJveDogTm9kZSk6IE5vZGVbXSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCByZXN1bHQ6IE5vZGVbXSA9IFtdO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCkgYXMgTm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29sbGlkZXMoYmJveDogTm9kZSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZGF0YTtcblxuICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSBpbnRlcnNlY3RzKGJib3gsIG5vZGUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRoaXMudG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKSBhcyBOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxvYWQoZGF0YTogTm9kZVtdKTogdm9pZCB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5zZXJ0KGl0ZW06IE5vZGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW06IE5vZGUpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5vZGU6IE5vZGUgfCBudWxsID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy50b0JCb3goaXRlbSk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgaW5kZXhlczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgbGV0IGk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHBhcmVudDogTm9kZSB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCkgYXMgTm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCkgYXMgbnVtYmVyO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY3VycmVudCBub2RlXG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZSwgYmJveCkpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpIGFzIG51bWJlcik7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICAoaSBhcyBudW1iZXIpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpIGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b0JCb3g8VD4oaXRlbTogVCk6IFQge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbXBhcmVNaW5YKGE6IE5vZGUsIGI6IE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGEubWluWCAtIGIubWluWDtcbiAgICB9XG4gICAgcHJpdmF0ZSBjb21wYXJlTWluWShhOiBOb2RlLCBiOiBOb2RlKSB7XG4gICAgICAgIHJldHVybiBhLm1pblkgLSBiLm1pblk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWxsKG5vZGU6IE5vZGUsIHJlc3VsdDogTm9kZVtdKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goLi4ubm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpIGFzIE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9idWlsZChpdGVtczogTm9kZVtdLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IE4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICBsZXQgTSA9IHRoaXMuX21heEVudHJpZXM7XG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICBjb25zdCBOMiA9IE1hdGguY2VpbChOIC8gTSk7XG4gICAgICAgIGNvbnN0IE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKTtcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2Nob29zZVN1YnRyZWUoYmJveDogTm9kZSwgbm9kZTogTm9kZSwgbGV2ZWw6IG51bWJlciwgcGF0aDogTm9kZVtdKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcblxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5zZXJ0KGl0ZW06IE5vZGUsIGxldmVsOiBudW1iZXIsIGlzTm9kZT86IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgYmJveCA9IGlzTm9kZSA/IGl0ZW0gOiB0aGlzLnRvQkJveChpdGVtKTtcbiAgICAgICAgY29uc3QgaW5zZXJ0UGF0aDogTm9kZVtdID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIHByaXZhdGUgX3NwbGl0KGluc2VydFBhdGg6IE5vZGVbXSwgbGV2ZWw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF07XG4gICAgICAgIGNvbnN0IE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVOb2RlKFxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KVxuICAgICAgICApO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3BsaXRSb290KG5vZGU6IE5vZGUsIG5ld05vZGU6IE5vZGUpIHtcbiAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jaG9vc2VTcGxpdEluZGV4KG5vZGU6IE5vZGUsIG06IG51bWJlciwgTTogbnVtYmVyKSB7XG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgbGV0IG1pbk92ZXJsYXAgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGNvbnN0IGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleCB8fCBNIC0gbTtcbiAgICB9XG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgcHJpdmF0ZSBfY2hvb3NlU3BsaXRBeGlzKG5vZGU6IE5vZGUsIG06IG51bWJlciwgTTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWDtcbiAgICAgICAgY29uc3QgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZO1xuICAgICAgICBjb25zdCB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCk7XG4gICAgICAgIGNvbnN0IHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBwcml2YXRlIF9hbGxEaXN0TWFyZ2luKFxuICAgICAgICBub2RlOiBOb2RlLFxuICAgICAgICBtOiBudW1iZXIsXG4gICAgICAgIE06IG51bWJlcixcbiAgICAgICAgY29tcGFyZTogQ29tcGFyZUZ1bmN0aW9uPE5vZGU+XG4gICAgKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICBjb25zdCB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICAgICAgY29uc3QgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpO1xuICAgICAgICBjb25zdCByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KTtcbiAgICAgICAgbGV0IG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveDogTm9kZSwgcGF0aDogTm9kZVtdLCBsZXZlbDogbnVtYmVyKSB7XG4gICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2NvbmRlbnNlKHBhdGg6IE5vZGVbXSkge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcbmltcG9ydCB7IEdlb0pTT05TdG9yZUZlYXR1cmVzIH0gZnJvbSBcIi4uL3N0b3JlXCI7XG5pbXBvcnQgeyBSQnVzaCwgTm9kZSB9IGZyb20gXCIuL3JidXNoXCI7XG5cbmV4cG9ydCBjbGFzcyBTcGF0aWFsSW5kZXgge1xuICAgIHByaXZhdGUgdHJlZTogUkJ1c2g7XG4gICAgcHJpdmF0ZSBpZFRvTm9kZTogTWFwPHN0cmluZywgTm9kZT47XG4gICAgcHJpdmF0ZSBub2RlVG9JZDogTWFwPE5vZGUsIHN0cmluZz47XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogeyBtYXhFbnRyaWVzOiBudW1iZXIgfSkge1xuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgUkJ1c2goXG4gICAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMubWF4RW50cmllcyA/IG9wdGlvbnMubWF4RW50cmllcyA6IDlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pZFRvTm9kZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ub2RlVG9JZCA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldE1hcHMoZmVhdHVyZTogR2VvSlNPTlN0b3JlRmVhdHVyZXMsIGJib3g6IE5vZGUpIHtcbiAgICAgICAgdGhpcy5pZFRvTm9kZS5zZXQoU3RyaW5nKGZlYXR1cmUuaWQpLCBiYm94KTtcbiAgICAgICAgdGhpcy5ub2RlVG9JZC5zZXQoYmJveCwgU3RyaW5nKGZlYXR1cmUuaWQpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvQkJveChmZWF0dXJlOiBHZW9KU09OU3RvcmVGZWF0dXJlcykge1xuICAgICAgICBjb25zdCBsb25naXR1ZGVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBsYXRpdHVkZXM6IG51bWJlcltdID0gW107XG5cbiAgICAgICAgbGV0IGNvb3JkaW5hdGVzOiBQb3NpdGlvbltdO1xuICAgICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSBbZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBmZWF0dXJlIHRvIHR1cm4gaW50byBhIGJvdW5kaW5nIGJveFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxhdGl0dWRlcy5wdXNoKGNvb3JkaW5hdGVzW2ldWzFdKTtcbiAgICAgICAgICAgIGxvbmdpdHVkZXMucHVzaChjb29yZGluYXRlc1tpXVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtaW5MYXQgPSBNYXRoLm1pbiguLi5sYXRpdHVkZXMpO1xuICAgICAgICBjb25zdCBtYXhMYXQgPSBNYXRoLm1heCguLi5sYXRpdHVkZXMpO1xuICAgICAgICBjb25zdCBtaW5MbmcgPSBNYXRoLm1pbiguLi5sb25naXR1ZGVzKTtcbiAgICAgICAgY29uc3QgbWF4TG5nID0gTWF0aC5tYXgoLi4ubG9uZ2l0dWRlcyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pblg6IG1pbkxuZyxcbiAgICAgICAgICAgIG1pblk6IG1pbkxhdCxcbiAgICAgICAgICAgIG1heFg6IG1heExuZyxcbiAgICAgICAgICAgIG1heFk6IG1heExhdCxcbiAgICAgICAgfSBhcyBOb2RlO1xuICAgIH1cblxuICAgIGluc2VydChmZWF0dXJlOiBHZW9KU09OU3RvcmVGZWF0dXJlcyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pZFRvTm9kZS5nZXQoU3RyaW5nKGZlYXR1cmUuaWQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmVhdHVyZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy50b0JCb3goZmVhdHVyZSk7XG4gICAgICAgIHRoaXMuc2V0TWFwcyhmZWF0dXJlLCBiYm94KTtcbiAgICAgICAgdGhpcy50cmVlLmluc2VydChiYm94KTtcbiAgICB9XG5cbiAgICBsb2FkKGZlYXR1cmVzOiBHZW9KU09OU3RvcmVGZWF0dXJlc1tdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxvYWQ6IE5vZGVbXSA9IFtdO1xuICAgICAgICBjb25zdCBzZWVuSWRzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmJveCA9IHRoaXMudG9CQm94KGZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXBzKGZlYXR1cmUsIGJib3gpO1xuICAgICAgICAgICAgaWYgKHNlZW5JZHMuaGFzKFN0cmluZyhmZWF0dXJlLmlkKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmZWF0dXJlIElEIGZvdW5kICR7ZmVhdHVyZS5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5JZHMuYWRkKFN0cmluZyhmZWF0dXJlLmlkKSk7XG4gICAgICAgICAgICBsb2FkLnB1c2goYmJveCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyZWUubG9hZChsb2FkKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZmVhdHVyZTogR2VvSlNPTlN0b3JlRmVhdHVyZXMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoZmVhdHVyZS5pZCBhcyBzdHJpbmcpO1xuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy50b0JCb3goZmVhdHVyZSk7XG4gICAgICAgIHRoaXMuc2V0TWFwcyhmZWF0dXJlLCBiYm94KTtcbiAgICAgICAgdGhpcy50cmVlLmluc2VydChiYm94KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZmVhdHVyZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaWRUb05vZGUuZ2V0KGZlYXR1cmVJZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2ZlYXR1cmVJZH0gbm90IGluc2VydGVkIGludG8gdGhlIHNwYXRpYWwgaW5kZXhgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJlZS5yZW1vdmUobm9kZSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHJlZS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlYXJjaChmZWF0dXJlOiBHZW9KU09OU3RvcmVGZWF0dXJlcyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLnRyZWUuc2VhcmNoKHRoaXMudG9CQm94KGZlYXR1cmUpKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVRvSWQuZ2V0KG5vZGUpIGFzIHN0cmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29sbGlkZXMoZmVhdHVyZTogR2VvSlNPTlN0b3JlRmVhdHVyZXMpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5jb2xsaWRlcyh0aGlzLnRvQkJveChmZWF0dXJlKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRmVhdHVyZSwgUG9pbnQsIFBvbHlnb24sIExpbmVTdHJpbmcgfSBmcm9tIFwiZ2VvanNvblwiO1xuaW1wb3J0IHsgdXVpZDQgfSBmcm9tIFwiLi4vdXRpbC9pZFwiO1xuaW1wb3J0IHsgU3BhdGlhbEluZGV4IH0gZnJvbSBcIi4vc3BhdGlhbC1pbmRleC9zcGF0aWFsLWluZGV4XCI7XG5cbnR5cGUgSlNPTiA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsIHwgSlNPTkFycmF5IHwgSlNPTk9iamVjdDtcblxuZXhwb3J0IGludGVyZmFjZSBKU09OT2JqZWN0IHtcbiAgW21lbWJlcjogc3RyaW5nXTogSlNPTjtcbn1cbnR5cGUgSlNPTkFycmF5ID0gQXJyYXk8SlNPTj47XG5cbnR5cGUgRGVmaW5lZFByb3BlcnRpZXMgPSBSZWNvcmQ8c3RyaW5nLCBKU09OPjtcblxuZXhwb3J0IHR5cGUgR2VvSlNPTlN0b3JlR2VvbWV0cmllcyA9IFBvbHlnb24gfCBMaW5lU3RyaW5nIHwgUG9pbnQ7XG5cbmV4cG9ydCB0eXBlIEJCb3hQb2x5Z29uID0gRmVhdHVyZTxQb2x5Z29uLCBEZWZpbmVkUHJvcGVydGllcz47XG5cbmV4cG9ydCB0eXBlIEdlb0pTT05TdG9yZUZlYXR1cmVzID0gRmVhdHVyZTxcbiAgR2VvSlNPTlN0b3JlR2VvbWV0cmllcyxcbiAgRGVmaW5lZFByb3BlcnRpZXNcbj47XG5cbmV4cG9ydCB0eXBlIFN0b3JlQ2hhbmdlRXZlbnRzID0gXCJkZWxldGVcIiB8IFwiY3JlYXRlXCIgfCBcInVwZGF0ZVwiO1xuXG5leHBvcnQgdHlwZSBTdG9yZUNoYW5nZUhhbmRsZXIgPSAoXG4gIGlkczogc3RyaW5nW10sXG4gIGNoYW5nZTogU3RvcmVDaGFuZ2VFdmVudHNcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgR2VvSlNPTlN0b3JlQ29uZmlnID0ge1xuICBkYXRhPzogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXTtcbiAgdHJhY2tlZD86IGJvb2xlYW47XG4gIHZhbGlkYXRlRmVhdHVyZT86IChmZWF0dXJlOiB1bmtub3duLCB0cmFja2VkPzogYm9vbGVhbikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjbGFzcyBHZW9KU09OU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZz86IEdlb0pTT05TdG9yZUNvbmZpZykge1xuICAgICAgICB0aGlzLnN0b3JlID0ge307XG4gICAgICAgIHRoaXMuc3BhdGlhbEluZGV4ID0gbmV3IFNwYXRpYWxJbmRleCgpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgdHJhY2tlZCBoYXMgdG8gaGFwcGVuIGZpcnN0XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgdXNlIGl0IGluIGZlYXR1cmVWYWxpZGF0aW9uXG4gICAgICAgIHRoaXMudHJhY2tlZCA9IGNvbmZpZyAmJiBjb25maWcudHJhY2tlZCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKGNvbmZpZy5kYXRhLCBjb25maWcudmFsaWRhdGVGZWF0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdHJhY2tlZDogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgc3BhdGlhbEluZGV4OiBTcGF0aWFsSW5kZXg7XG5cbiAgICBwcml2YXRlIHN0b3JlOiB7XG4gICAgW2tleTogc3RyaW5nXTogR2VvSlNPTlN0b3JlRmVhdHVyZXM7XG4gIH07XG5cbiAgICAvLyBEZWZhdWx0IHRvIG5vLW9wXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2U6IFN0b3JlQ2hhbmdlSGFuZGxlciA9ICgpID0+IHt9O1xuXG4gICAgcHJpdmF0ZSBnZXRJZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdXVpZDQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb25lPFQ+KG9iajogVCk6IFQge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG5cbiAgICBoYXMoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlW2lkXSk7XG4gICAgfVxuXG4gICAgbG9hZChcbiAgICAgICAgZGF0YTogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXSxcbiAgICAgICAgZmVhdHVyZVZhbGlkYXRpb24/OiAoZmVhdHVyZTogdW5rbm93biwgdHJhY2tlZD86IGJvb2xlYW4pID0+IHZvaWRcbiAgICApIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgb3JpZ2luYWwgZGF0YVxuICAgICAgICBjb25zdCBjbG9uZWREYXRhID0gdGhpcy5jbG9uZShkYXRhKTtcblxuICAgICAgICAvLyBXZSB0cnkgdG8gYmUgYSBiaXQgZm9yZ2l2aW5nIGhlcmUgYXMgbWFueSB1c2Vyc1xuICAgICAgICAvLyBtYXkgbm90IHNldCBhIGZlYXR1cmUgaWQgYXMgVVVJRCBvciBjcmVhdGVkQXQvdXBkYXRlZEF0XG4gICAgICAgIGNsb25lZERhdGEuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlLmlkKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5pZCA9IHV1aWQ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmUucHJvcGVydGllcy5jcmVhdGVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmNyZWF0ZWRBdCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZS5wcm9wZXJ0aWVzLnVwZGF0ZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMudXBkYXRlZEF0ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjaGFuZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjbG9uZWREYXRhLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVWYWxpZGF0aW9uKGZlYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9yZVtmZWF0dXJlLmlkIGFzIHN0cmluZ10gPSBmZWF0dXJlO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGZlYXR1cmUuaWQgYXMgc3RyaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3BhdGlhbEluZGV4LmxvYWQoY2xvbmVkRGF0YSk7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlKGNoYW5nZXMsIFwiY3JlYXRlXCIpO1xuICAgIH1cblxuICAgIHNlYXJjaChcbiAgICAgICAgYmJveDogQkJveFBvbHlnb24sXG4gICAgICAgIGZpbHRlcj86IChmZWF0dXJlOiBHZW9KU09OU3RvcmVGZWF0dXJlcykgPT4gYm9vbGVhblxuICAgICkge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IHRoaXMuc3BhdGlhbEluZGV4LnNlYXJjaChiYm94KS5tYXAoKGlkKSA9PiB0aGlzLnN0b3JlW2lkXSk7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKGZlYXR1cmVzLmZpbHRlcihmaWx0ZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKGZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6IFN0b3JlQ2hhbmdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IChpZHMsIGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UoaWRzLCBjaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEdlb21ldHJ5Q29weTxUIGV4dGVuZHMgR2VvSlNPTlN0b3JlR2VvbWV0cmllcz4oaWQ6IHN0cmluZyk6IFQge1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5zdG9yZVtpZF07XG4gICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBObyBmZWF0dXJlIHdpdGggdGhpcyBpZCAoJHtpZH0pLCBjYW4gbm90IGdldCBnZW9tZXRyeSBjb3B5YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShmZWF0dXJlLmdlb21ldHJ5IGFzIFQpO1xuICAgIH1cblxuICAgIGdldFByb3BlcnRpZXNDb3B5KGlkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuc3RvcmVbaWRdO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgTm8gZmVhdHVyZSB3aXRoIHRoaXMgaWQgKCR7aWR9KSwgY2FuIG5vdCBnZXQgcHJvcGVydGllcyBjb3B5YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZShmZWF0dXJlLnByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIHVwZGF0ZVByb3BlcnR5KFxuICAgICAgICBwcm9wZXJ0aWVzVG9VcGRhdGU6IHsgaWQ6IHN0cmluZzsgcHJvcGVydHk6IHN0cmluZzsgdmFsdWU6IEpTT04gfVtdXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGlkczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgcHJvcGVydGllc1RvVXBkYXRlLmZvckVhY2goKHsgaWQsIHByb3BlcnR5LCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5zdG9yZVtpZF07XG5cbiAgICAgICAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYE5vIGZlYXR1cmUgd2l0aCB0aGlzICgke2lkfSksIGNhbiBub3QgdXBkYXRlIGdlb21ldHJ5YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcblxuICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRpbWUgdGhlIGZlYXR1cmUgd2FzIHVwZGF0ZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMudXBkYXRlZEF0ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoaWRzLCBcInVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUdlb21ldHJ5KFxuICAgICAgICBnZW9tZXRyaWVzVG9VcGRhdGU6IHsgaWQ6IHN0cmluZzsgZ2VvbWV0cnk6IEdlb0pTT05TdG9yZUdlb21ldHJpZXMgfVtdXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGlkczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZ2VvbWV0cmllc1RvVXBkYXRlLmZvckVhY2goKHsgaWQsIGdlb21ldHJ5IH0pID0+IHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcblxuICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuc3RvcmVbaWRdO1xuXG4gICAgICAgICAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBObyBmZWF0dXJlIHdpdGggdGhpcyAoJHtpZH0pLCBjYW4gbm90IHVwZGF0ZSBnZW9tZXRyeWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5ID0gdGhpcy5jbG9uZShnZW9tZXRyeSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3BhdGlhbEluZGV4LnVwZGF0ZShmZWF0dXJlKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHRoZSBmZWF0dXJlIHdhcyB1cGRhdGVkXG4gICAgICAgICAgICBpZiAodGhpcy50cmFja2VkKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnVwZGF0ZWRBdCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKGlkcywgXCJ1cGRhdGVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGUoXG4gICAgICAgIGZlYXR1cmVzOiB7XG4gICAgICBnZW9tZXRyeTogR2VvSlNPTlN0b3JlR2VvbWV0cmllcztcbiAgICAgIHByb3BlcnRpZXM/OiBKU09OT2JqZWN0O1xuICAgIH1bXVxuICAgICk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKCh7IGdlb21ldHJ5LCBwcm9wZXJ0aWVzIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBjcmVhdGVkQXQ7XG4gICAgICAgICAgICBsZXQgY3JlYXRlZFByb3BlcnRpZXMgPSB7IC4uLnByb3BlcnRpZXMgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tlZCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZFByb3BlcnRpZXMuY3JlYXRlZEF0ID1cbiAgICAgICAgICAgIHR5cGVvZiBwcm9wZXJ0aWVzLmNyZWF0ZWRBdCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgID8gcHJvcGVydGllcy5jcmVhdGVkQXRcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZFByb3BlcnRpZXMudXBkYXRlZEF0ID1cbiAgICAgICAgICAgIHR5cGVvZiBwcm9wZXJ0aWVzLnVwZGF0ZWRBdCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgID8gcHJvcGVydGllcy51cGRhdGVkQXRcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkUHJvcGVydGllcyA9IHsgY3JlYXRlZEF0LCB1cGRhdGVkQXQ6IGNyZWF0ZWRBdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldElkKCk7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGNyZWF0ZWRQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgfSBhcyBHZW9KU09OU3RvcmVGZWF0dXJlcztcblxuICAgICAgICAgICAgdGhpcy5zdG9yZVtpZF0gPSBmZWF0dXJlO1xuICAgICAgICAgICAgdGhpcy5zcGF0aWFsSW5kZXguaW5zZXJ0KGZlYXR1cmUpO1xuXG4gICAgICAgICAgICBpZHMucHVzaChpZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoWy4uLmlkc10sIFwiY3JlYXRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG5cbiAgICBkZWxldGUoaWRzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgICAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2lkXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXRpYWxJbmRleC5yZW1vdmUoaWQgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmVhdHVyZSB3aXRoIHRoaXMgaWQsIGNhbiBub3QgZGVsZXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKFsuLi5pZHNdLCBcImRlbGV0ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvcHlBbGwoKTogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLm1hcCgoaWQpID0+IHRoaXMuc3RvcmVbaWRdKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVGVycmFEcmF3R29vZ2xlTWFwc0FkYXB0ZXIgfSBmcm9tIFwiLi9hZGFwdGVycy9nb29nbGUtbWFwcy5hZGFwdGVyXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdMZWFmbGV0QWRhcHRlciB9IGZyb20gXCIuL2FkYXB0ZXJzL2xlYWZsZXQuYWRhcHRlclwiO1xuaW1wb3J0IHsgVGVycmFEcmF3TWFwYm94R0xBZGFwdGVyIH0gZnJvbSBcIi4vYWRhcHRlcnMvbWFwYm94LWdsLmFkYXB0ZXJcIjtcbmltcG9ydCB7XG4gICAgVGVycmFEcmF3TW9kZSxcbiAgICBUZXJyYURyYXdBZGFwdGVyLFxuICAgIFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nLFxufSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IFRlcnJhRHJhd0NpcmNsZU1vZGUgfSBmcm9tIFwiLi9tb2Rlcy9jaXJjbGUvY2lyY2xlLm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd0ZyZWVoYW5kTW9kZSB9IGZyb20gXCIuL21vZGVzL2ZyZWVoYW5kL2ZyZWVoYW5kLm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd0xpbmVTdHJpbmdNb2RlIH0gZnJvbSBcIi4vbW9kZXMvbGluZXN0cmluZy9saW5lc3RyaW5nLm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd1BvaW50TW9kZSB9IGZyb20gXCIuL21vZGVzL3BvaW50L3BvaW50Lm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd1BvbHlnb25Nb2RlIH0gZnJvbSBcIi4vbW9kZXMvcG9seWdvbi9wb2x5Z29uLm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd1NlbGVjdE1vZGUgfSBmcm9tIFwiLi9tb2Rlcy9zZWxlY3Qvc2VsZWN0Lm1vZGVcIjtcbmltcG9ydCB7IFRlcnJhRHJhd1N0YXRpY01vZGUgfSBmcm9tIFwiLi9tb2Rlcy9zdGF0aWMvc3RhdGljLm1vZGVcIjtcbmltcG9ydCB7XG4gICAgR2VvSlNPTlN0b3JlLFxuICAgIEdlb0pTT05TdG9yZUZlYXR1cmVzLFxuICAgIFN0b3JlQ2hhbmdlSGFuZGxlcixcbn0gZnJvbSBcIi4vc3RvcmUvc3RvcmVcIjtcblxudHlwZSBDaGFuZ2VMaXN0ZW5lciA9IChpZHM6IHN0cmluZ1tdLCB0eXBlOiBzdHJpbmcpID0+IHZvaWQ7XG50eXBlIFNlbGVjdExpc3RlbmVyID0gKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG50eXBlIERlc2VsZWN0TGlzdGVuZXIgPSAoKSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgVGVycmFEcmF3RXZlbnRMaXN0ZW5lcnMge1xuICAgIGNoYW5nZTogQ2hhbmdlTGlzdGVuZXI7XG4gICAgc2VsZWN0OiBTZWxlY3RMaXN0ZW5lcjtcbiAgICBkZXNlbGVjdDogRGVzZWxlY3RMaXN0ZW5lcjtcbn1cblxudHlwZSBUZXJyYURyYXdFdmVudHMgPSBrZXlvZiBUZXJyYURyYXdFdmVudExpc3RlbmVycztcblxuY2xhc3MgVGVycmFEcmF3IHtcbiAgICBwcml2YXRlIF9tb2RlczogeyBbbW9kZTogc3RyaW5nXTogVGVycmFEcmF3TW9kZSB9O1xuICAgIHByaXZhdGUgX21vZGU6IFRlcnJhRHJhd01vZGU7XG4gICAgcHJpdmF0ZSBfYWRhcHRlcjogVGVycmFEcmF3QWRhcHRlcjtcbiAgICBwcml2YXRlIF9lbmFibGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfc3RvcmU6IEdlb0pTT05TdG9yZTtcbiAgICBwcml2YXRlIF9ldmVudExpc3RlbmVyczoge1xuICAgICAgICBjaGFuZ2U6IENoYW5nZUxpc3RlbmVyW107XG4gICAgICAgIHNlbGVjdDogU2VsZWN0TGlzdGVuZXJbXTtcbiAgICAgICAgZGVzZWxlY3Q6IERlc2VsZWN0TGlzdGVuZXJbXTtcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczoge1xuICAgICAgICBhZGFwdGVyOiBUZXJyYURyYXdBZGFwdGVyO1xuICAgICAgICBtb2RlczogeyBbbW9kZTogc3RyaW5nXTogVGVycmFEcmF3TW9kZSB9O1xuICAgICAgICBkYXRhPzogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXTtcbiAgICB9KSB7XG4gICAgICAgIHRoaXMuX2FkYXB0ZXIgPSBvcHRpb25zLmFkYXB0ZXI7XG4gICAgICAgIHRoaXMuX21vZGUgPSBuZXcgVGVycmFEcmF3U3RhdGljTW9kZSgpO1xuICAgICAgICB0aGlzLl9tb2RlcyA9IHsgLi4ub3B0aW9ucy5tb2Rlcywgc3RhdGljOiB0aGlzLl9tb2RlIH07XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0geyBjaGFuZ2U6IFtdLCBzZWxlY3Q6IFtdLCBkZXNlbGVjdDogW10gfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZSA9IG5ldyBHZW9KU09OU3RvcmUoeyBkYXRhOiBvcHRpb25zLmRhdGEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZSA9IG5ldyBHZW9KU09OU3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdldENoYW5nZWQgPSAoXG4gICAgICAgICAgICBpZHM6IHN0cmluZ1tdXG4gICAgICAgICk6IHtcbiAgICAgICAgICAgIGNoYW5nZWQ6IEdlb0pTT05TdG9yZUZlYXR1cmVzW107XG4gICAgICAgICAgICB1bmNoYW5nZWQ6IEdlb0pTT05TdG9yZUZlYXR1cmVzW107XG4gICAgICAgIH0gPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZDogR2VvSlNPTlN0b3JlRmVhdHVyZXNbXSA9IFtdO1xuXG4gICAgICAgICAgICBjb25zdCB1bmNoYW5nZWQgPSB0aGlzLl9zdG9yZS5jb3B5QWxsKCkuZmlsdGVyKChmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlkcy5pbmNsdWRlcyhmLmlkIGFzIHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlZCwgdW5jaGFuZ2VkIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25DaGFuZ2U6IFN0b3JlQ2hhbmdlSGFuZGxlciA9IChpZHMsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5jaGFuZ2UuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihpZHMsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZWQsIHVuY2hhbmdlZCB9ID0gZ2V0Q2hhbmdlZChpZHMpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGFwdGVyLnJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5jaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogW11cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRNb2RlU3R5bGVzKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkYXB0ZXIucmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5jaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRNb2RlU3R5bGVzKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkYXB0ZXIucmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICB7IGNyZWF0ZWQ6IFtdLCBkZWxldGVkSWRzOiBpZHMsIHVuY2hhbmdlZCwgdXBkYXRlZDogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRNb2RlU3R5bGVzKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJzdHlsaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGFwdGVyLnJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgeyBjcmVhdGVkOiBbXSwgZGVsZXRlZElkczogW10sIHVuY2hhbmdlZCwgdXBkYXRlZDogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRNb2RlU3R5bGVzKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uU2VsZWN0ID0gKHNlbGVjdGVkSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuc2VsZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoc2VsZWN0ZWRJZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgeyBjaGFuZ2VkLCB1bmNoYW5nZWQgfSA9IGdldENoYW5nZWQoW3NlbGVjdGVkSWRdKTtcblxuICAgICAgICAgICAgdGhpcy5fYWRhcHRlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgeyBjcmVhdGVkOiBbXSwgZGVsZXRlZElkczogW10sIHVuY2hhbmdlZCwgdXBkYXRlZDogY2hhbmdlZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TW9kZVN0eWxlcygpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uRGVzZWxlY3QgPSAoZGVzZWxlY3RlZElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLmRlc2VsZWN0LmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZWQsIHVuY2hhbmdlZCB9ID0gZ2V0Q2hhbmdlZChbZGVzZWxlY3RlZElkXSk7XG5cbiAgICAgICAgICAgIC8vIG9uRGVzZWxlY3QgY2FuIGJlIGNhbGxlZCBhZnRlciBhIGRlbGV0ZSBjYWxsIHdoaWNoIG1lYW5zIHRoYXRcbiAgICAgICAgICAgIC8vIHlvdSBhcmUgZGVzZWxlY3RpbmcgYSBmZWF0dXJlIHRoYXQgaGFzIGJlZW4gZGVsZXRlZC4gV2VcbiAgICAgICAgICAgIC8vIGRvdWJsZSBjaGVjayBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZSBmZWF0dXJlIHN0aWxsIGV4aXN0cy5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRhcHRlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlZElkczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE1vZGVTdHlsZXMoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgc3RvcmVzIGFuZCBjYWxsYmFja3NcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZXMpLmZvckVhY2goKG1vZGVJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbW9kZXNbbW9kZUlkXS5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgICAgbW9kZTogbW9kZUlkLFxuICAgICAgICAgICAgICAgIHN0b3JlOiB0aGlzLl9zdG9yZSxcbiAgICAgICAgICAgICAgICBzZXRDdXJzb3I6IHRoaXMuX2FkYXB0ZXIuc2V0Q3Vyc29yLFxuICAgICAgICAgICAgICAgIHByb2plY3Q6IHRoaXMuX2FkYXB0ZXIucHJvamVjdCxcbiAgICAgICAgICAgICAgICB1bnByb2plY3Q6IHRoaXMuX2FkYXB0ZXIudW5wcm9qZWN0LFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogb25TZWxlY3QsXG4gICAgICAgICAgICAgICAgb25EZXNlbGVjdDogb25EZXNlbGVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB3ZSBwYXNzIGluIGRhdGEsIHdlIHdhbnQgdG8gcmVuZGVyIGl0IG9uIHN0YXJ0dXBcbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBub24gbW9kZSBmZWF0dXJlc1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFJlbmRlciA9IHRoaXMuX3N0b3JlLmNvcHlBbGwoKS5maWx0ZXIoKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyAmJlxuICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LmtleXModGhpcy5fbW9kZXMpLmluY2x1ZGVzKGZlYXR1cmUucHJvcGVydGllcy5tb2RlIGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcmUuZGVsZXRlKFtmZWF0dXJlLmlkIGFzIHN0cmluZ10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2FkYXB0ZXIucmVuZGVyKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogaW5pdGlhbFJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZElkczogW10sXG4gICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZDogW10sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNb2RlU3R5bGVzKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1vZGVTdHlsZXMoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVTdHlsZXM6IHsgW2tleTogc3RyaW5nXTogVGVycmFEcmF3QWRhcHRlclN0eWxpbmcgfSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tb2RlcykuZm9yRWFjaCgobW9kZSkgPT4ge1xuICAgICAgICAgICAgbW9kZVN0eWxlc1ttb2RlXSA9IHRoaXMuX21vZGVzW21vZGVdLnN0eWxpbmc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbW9kZVN0eWxlcztcbiAgICB9XG5cbiAgICBzZXRNb2RlU3R5bGluZyhtb2RlOiBzdHJpbmcsIHN0eWxpbmc6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nKSB7XG4gICAgICAgIHRoaXMuX21vZGVzW21vZGVdLnN0eWxpbmcgPSBzdHlsaW5nO1xuICAgIH1cblxuICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmUuY29weUFsbCgpO1xuICAgIH1cblxuICAgIGdldCBlbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9XG5cbiAgICBzZXQgZW5hYmxlZChfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuYWJsZWQgaXMgcmVhZCBvbmx5XCIpO1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRNb2RlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlLm1vZGU7XG4gICAgfVxuXG4gICAgY2hhbmdlTW9kZShtb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vZGVzW21vZGVdKSB7XG4gICAgICAgICAgICAvLyBCZWZvcmUgd2Ugc3dhcCBtb2RlcyB3ZSB3YW50IHRvXG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBhbnkgc3RhdGUgdGhhdCBoYXMgYmVlbiBsZWZ0IGJlaGluZCxcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlIGN1cnJlbnQgZHJhd2luZyBnZW9tZXRyaWVzXG4gICAgICAgICAgICAvLyBhbmQgbW9kZSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5fbW9kZS5zdG9wKCk7XG5cbiAgICAgICAgICAgIC8vIFN3YXAgdGhlIG1vZGUgdG8gdGhlIG5ldyBtb2RlXG4gICAgICAgICAgICB0aGlzLl9tb2RlID0gdGhpcy5fbW9kZXNbbW9kZV07XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXcgbW9kZVxuICAgICAgICAgICAgdGhpcy5fbW9kZS5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG1vZGUgZG9lc24ndCBleGlzdCwgd2UgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1vZGUgd2l0aCB0aGlzIG5hbWUgcHJlc2VudFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRhcHRlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLm9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleURvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUub25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleVVwOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLm9uS2V5VXAoZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiAoZXZlbnQsIHNldE1hcERyYWdnYWJpbGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUub25EcmFnU3RhcnQoZXZlbnQsIHNldE1hcERyYWdnYWJpbGl0eSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLm9uRHJhZyhldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnRW5kOiAoZXZlbnQsIHNldE1hcERyYWdnYWJpbGl0eSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vZGUub25EcmFnRW5kKGV2ZW50LCBzZXRNYXBEcmFnZ2FiaWxpdHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hZGFwdGVyLnVucmVnaXN0ZXIoKTtcbiAgICB9XG5cbiAgICBvbjxUIGV4dGVuZHMgVGVycmFEcmF3RXZlbnRzPihcbiAgICAgICAgZXZlbnQ6IFQsXG4gICAgICAgIGNhbGxiYWNrOiBUZXJyYURyYXdFdmVudExpc3RlbmVyc1tUXVxuICAgICkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgIF0gYXMgVGVycmFEcmF3RXZlbnRMaXN0ZW5lcnNbVF1bXTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMuaW5jbHVkZXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvZmY8VCBleHRlbmRzIFRlcnJhRHJhd0V2ZW50cz4oXG4gICAgICAgIGV2ZW50OiBUZXJyYURyYXdFdmVudHMsXG4gICAgICAgIGNhbGxiYWNrOiBUZXJyYURyYXdFdmVudExpc3RlbmVyc1tUXVxuICAgICkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgIF0gYXMgVGVycmFEcmF3RXZlbnRMaXN0ZW5lcnNbVF1bXTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5pbmNsdWRlcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHtcbiAgICBUZXJyYURyYXcsXG4gICAgVGVycmFEcmF3U2VsZWN0TW9kZSxcbiAgICBUZXJyYURyYXdQb2ludE1vZGUsXG4gICAgVGVycmFEcmF3TGluZVN0cmluZ01vZGUsXG4gICAgVGVycmFEcmF3UG9seWdvbk1vZGUsXG4gICAgVGVycmFEcmF3Q2lyY2xlTW9kZSxcbiAgICBUZXJyYURyYXdGcmVlaGFuZE1vZGUsXG4gICAgVGVycmFEcmF3R29vZ2xlTWFwc0FkYXB0ZXIsXG4gICAgVGVycmFEcmF3TWFwYm94R0xBZGFwdGVyLFxuICAgIFRlcnJhRHJhd0xlYWZsZXRBZGFwdGVyLFxufTtcbiIsImltcG9ydCB7IEZlYXR1cmUsIExpbmVTdHJpbmcsIFBvbHlnb24sIFBvc2l0aW9uIH0gZnJvbSBcImdlb2pzb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBvbHlnb24oXG4gICAgY29vcmRpbmF0ZXM6IFBvc2l0aW9uW11bXSA9IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgWzAsIDFdLFxuICAgICAgICAgICAgWzEsIDFdLFxuICAgICAgICAgICAgWzEsIDBdLFxuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICBdLFxuICAgIF1cbik6IEZlYXR1cmU8UG9seWdvbj4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlcyxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxpbmVTdHJpbmcoY29vcmRpbmF0ZXM6IFBvc2l0aW9uW10pOiBGZWF0dXJlPExpbmVTdHJpbmc+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIH07XG59XG4iLCJleHBvcnQgY29uc3QgdXVpZDQgPSBmdW5jdGlvbiAoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXG4gICAgICAgICAgICB2ID0gYyA9PSBcInhcIiA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG4iLCJpbXBvcnQgeyBUZXJyYURyYXdBZGFwdGVyU3R5bGluZyB9IGZyb20gXCIuLi9jb21tb25cIjtcblxuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRTdHlsaW5nID0gKCk6IFRlcnJhRHJhd0FkYXB0ZXJTdHlsaW5nID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2x5Z29uRmlsbENvbG9yOiBcIiMzZjk3ZTBcIixcbiAgICAgICAgcG9seWdvbk91dGxpbmVDb2xvcjogXCIjM2Y5N2UwXCIsXG4gICAgICAgIHBvbHlnb25PdXRsaW5lV2lkdGg6IDQsXG4gICAgICAgIHBvbHlnb25GaWxsT3BhY2l0eTogMC4zLFxuICAgICAgICBwb2ludENvbG9yOiBcIiMzZjk3ZTBcIixcbiAgICAgICAgcG9pbnRPdXRsaW5lQ29sb3I6IFwiIzNmOTdlMFwiLFxuICAgICAgICBwb2ludFdpZHRoOiA2LFxuICAgICAgICBsaW5lU3RyaW5nQ29sb3I6IFwiIzNmOTdlMFwiLFxuICAgICAgICBsaW5lU3RyaW5nV2lkdGg6IDQsXG4gICAgICAgIHNlbGVjdGVkQ29sb3I6IFwiIzI2YTljOFwiLFxuICAgICAgICBzZWxlY3RlZFBvaW50T3V0bGluZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgc2VsZWN0aW9uUG9pbnRXaWR0aDogNixcbiAgICAgICAgbWlkUG9pbnRDb2xvcjogXCIjM2Y5N2UwXCIsXG4gICAgICAgIG1pZFBvaW50T3V0bGluZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgbWlkUG9pbnRXaWR0aDogNCxcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IGdlb21SZWR1Y2UgfSBmcm9tIFwiQHR1cmYvbWV0YVwiO1xuLy8gTm90ZTogY2hhbmdlIFJBRElVUyA9PiBlYXJ0aFJhZGl1c1xudmFyIFJBRElVUyA9IDYzNzgxMzc7XG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIGZlYXR1cmVzIGFuZCByZXR1cm5zIHRoZWlyIGFyZWEgaW4gc3F1YXJlIG1ldGVycy5cbiAqXG4gKiBAbmFtZSBhcmVhXG4gKiBAcGFyYW0ge0dlb0pTT059IGdlb2pzb24gaW5wdXQgR2VvSlNPTiBmZWF0dXJlKHMpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhcmVhIGluIHNxdWFyZSBtZXRlcnNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1sxMjUsIC0xNV0sIFsxMTMsIC0yMl0sIFsxNTQsIC0yN10sIFsxNDQsIC0xNV0sIFsxMjUsIC0xNV1dXSk7XG4gKlxuICogdmFyIGFyZWEgPSB0dXJmLmFyZWEocG9seWdvbik7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW3BvbHlnb25dXG4gKiBwb2x5Z29uLnByb3BlcnRpZXMuYXJlYSA9IGFyZWFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJlYShnZW9qc29uKSB7XG4gICAgcmV0dXJuIGdlb21SZWR1Y2UoZ2VvanNvbiwgZnVuY3Rpb24gKHZhbHVlLCBnZW9tKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGNhbGN1bGF0ZUFyZWEoZ2VvbSk7XG4gICAgfSwgMCk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBBcmVhXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb20gR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhcmVhXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFyZWEoZ2VvbSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChnZW9tLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uQXJlYShnZW9tLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20uY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBwb2x5Z29uQXJlYShnZW9tLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgaWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvIHRoZSBlYXJ0aC5cbiAqIE5vdGUgdGhhdCB0aGlzIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSBpZiByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsXG4gKiBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwczovL3Rycy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZHMgUmluZyBDb29yZGluYXRlc1xuICogQHJldHVybnMge251bWJlcn0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZSBtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBwMTtcbiAgICB2YXIgcDI7XG4gICAgdmFyIHAzO1xuICAgIHZhciBsb3dlckluZGV4O1xuICAgIHZhciBtaWRkbGVJbmRleDtcbiAgICB2YXIgdXBwZXJJbmRleDtcbiAgICB2YXIgaTtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBjb29yZHNMZW5ndGggPSBjb29yZHMubGVuZ3RoO1xuICAgIGlmIChjb29yZHNMZW5ndGggPiAyKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGNvb3Jkc0xlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAvLyBpID0gTi0yXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGNvb3Jkc0xlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSBjb29yZHNMZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGkgPSBOLTFcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpID0gMCB0byBOLTNcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBpICsgMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAxID0gY29vcmRzW2xvd2VySW5kZXhdO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbbWlkZGxlSW5kZXhdO1xuICAgICAgICAgICAgcDMgPSBjb29yZHNbdXBwZXJJbmRleF07XG4gICAgICAgICAgICB0b3RhbCArPSAocmFkKHAzWzBdKSAtIHJhZChwMVswXSkpICogTWF0aC5zaW4ocmFkKHAyWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgPSAodG90YWwgKiBSQURJVVMgKiBSQURJVVMpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufVxuZnVuY3Rpb24gcmFkKG51bSkge1xuICAgIHJldHVybiAobnVtICogTWF0aC5QSSkgLyAxODA7XG59XG4iLCJpbXBvcnQgeyBnZXRDb29yZCB9IGZyb20gXCJAdHVyZi9pbnZhcmlhbnRcIjtcbmltcG9ydCB7IHJhZGlhbnNUb0xlbmd0aCwgZGVncmVlc1RvUmFkaWFucywgfSBmcm9tIFwiQHR1cmYvaGVscGVyc1wiO1xuLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vL2h0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGluIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzLlxuICogVGhpcyB1c2VzIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpIHRvIGFjY291bnQgZm9yIGdsb2JhbCBjdXJ2YXR1cmUuXG4gKlxuICogQG5hbWUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Q29vcmQgfCBQb2ludH0gZnJvbSBvcmlnaW4gcG9pbnQgb3IgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtDb29yZCB8IFBvaW50fSB0byBkZXN0aW5hdGlvbiBwb2ludCBvciBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51bml0cz0na2lsb21ldGVycyddIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xuICogQGV4YW1wbGVcbiAqIHZhciBmcm9tID0gdHVyZi5wb2ludChbLTc1LjM0MywgMzkuOTg0XSk7XG4gKiB2YXIgdG8gPSB0dXJmLnBvaW50KFstNzUuNTM0LCAzOS4xMjNdKTtcbiAqIHZhciBvcHRpb25zID0ge3VuaXRzOiAnbWlsZXMnfTtcbiAqXG4gKiB2YXIgZGlzdGFuY2UgPSB0dXJmLmRpc3RhbmNlKGZyb20sIHRvLCBvcHRpb25zKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbZnJvbSwgdG9dO1xuICogZnJvbS5wcm9wZXJ0aWVzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gKiB0by5wcm9wZXJ0aWVzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgY29vcmRpbmF0ZXMxID0gZ2V0Q29vcmQoZnJvbSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMiA9IGdldENvb3JkKHRvKTtcbiAgICB2YXIgZExhdCA9IGRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMyWzFdIC0gY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgZExvbiA9IGRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMyWzBdIC0gY29vcmRpbmF0ZXMxWzBdKTtcbiAgICB2YXIgbGF0MSA9IGRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgbGF0MiA9IGRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMyWzFdKTtcbiAgICB2YXIgYSA9IE1hdGgucG93KE1hdGguc2luKGRMYXQgLyAyKSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhNYXRoLnNpbihkTG9uIC8gMiksIDIpICogTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgICByZXR1cm4gcmFkaWFuc1RvTGVuZ3RoKDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSksIG9wdGlvbnMudW5pdHMpO1xufVxuZXhwb3J0IGRlZmF1bHQgZGlzdGFuY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgaGVscGVyc1xuICovXG4vKipcbiAqIEVhcnRoIFJhZGl1cyB1c2VkIHdpdGggdGhlIEhhcnZlc2luZSBmb3JtdWxhIGFuZCBhcHByb3hpbWF0ZXMgdXNpbmcgYSBzcGhlcmljYWwgKG5vbi1lbGxpcHNvaWQpIEVhcnRoLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIGVhcnRoUmFkaXVzID0gNjM3MTAwOC44O1xuLyoqXG4gKiBVbml0IG9mIG1lYXN1cmVtZW50IGZhY3RvcnMgdXNpbmcgYSBzcGhlcmljYWwgKG5vbi1lbGxpcHNvaWQpIGVhcnRoIHJhZGl1cy5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0IHZhciBmYWN0b3JzID0ge1xuICAgIGNlbnRpbWV0ZXJzOiBlYXJ0aFJhZGl1cyAqIDEwMCxcbiAgICBjZW50aW1ldHJlczogZWFydGhSYWRpdXMgKiAxMDAsXG4gICAgZGVncmVlczogZWFydGhSYWRpdXMgLyAxMTEzMjUsXG4gICAgZmVldDogZWFydGhSYWRpdXMgKiAzLjI4MDg0LFxuICAgIGluY2hlczogZWFydGhSYWRpdXMgKiAzOS4zNyxcbiAgICBraWxvbWV0ZXJzOiBlYXJ0aFJhZGl1cyAvIDEwMDAsXG4gICAga2lsb21ldHJlczogZWFydGhSYWRpdXMgLyAxMDAwLFxuICAgIG1ldGVyczogZWFydGhSYWRpdXMsXG4gICAgbWV0cmVzOiBlYXJ0aFJhZGl1cyxcbiAgICBtaWxlczogZWFydGhSYWRpdXMgLyAxNjA5LjM0NCxcbiAgICBtaWxsaW1ldGVyczogZWFydGhSYWRpdXMgKiAxMDAwLFxuICAgIG1pbGxpbWV0cmVzOiBlYXJ0aFJhZGl1cyAqIDEwMDAsXG4gICAgbmF1dGljYWxtaWxlczogZWFydGhSYWRpdXMgLyAxODUyLFxuICAgIHJhZGlhbnM6IDEsXG4gICAgeWFyZHM6IGVhcnRoUmFkaXVzICogMS4wOTM2LFxufTtcbi8qKlxuICogVW5pdHMgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgdmFyIHVuaXRzRmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogMTAwLFxuICAgIGNlbnRpbWV0cmVzOiAxMDAsXG4gICAgZGVncmVlczogMSAvIDExMTMyNSxcbiAgICBmZWV0OiAzLjI4MDg0LFxuICAgIGluY2hlczogMzkuMzcsXG4gICAga2lsb21ldGVyczogMSAvIDEwMDAsXG4gICAga2lsb21ldHJlczogMSAvIDEwMDAsXG4gICAgbWV0ZXJzOiAxLFxuICAgIG1ldHJlczogMSxcbiAgICBtaWxlczogMSAvIDE2MDkuMzQ0LFxuICAgIG1pbGxpbWV0ZXJzOiAxMDAwLFxuICAgIG1pbGxpbWV0cmVzOiAxMDAwLFxuICAgIG5hdXRpY2FsbWlsZXM6IDEgLyAxODUyLFxuICAgIHJhZGlhbnM6IDEgLyBlYXJ0aFJhZGl1cyxcbiAgICB5YXJkczogMS4wOTM2MTMzLFxufTtcbi8qKlxuICogQXJlYSBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIGJhc2VkIG9uIDEgc3F1YXJlIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnQgdmFyIGFyZWFGYWN0b3JzID0ge1xuICAgIGFjcmVzOiAwLjAwMDI0NzEwNSxcbiAgICBjZW50aW1ldGVyczogMTAwMDAsXG4gICAgY2VudGltZXRyZXM6IDEwMDAwLFxuICAgIGZlZXQ6IDEwLjc2MzkxMDQxNyxcbiAgICBoZWN0YXJlczogMC4wMDAxLFxuICAgIGluY2hlczogMTU1MC4wMDMxMDAwMDYsXG4gICAga2lsb21ldGVyczogMC4wMDAwMDEsXG4gICAga2lsb21ldHJlczogMC4wMDAwMDEsXG4gICAgbWV0ZXJzOiAxLFxuICAgIG1ldHJlczogMSxcbiAgICBtaWxlczogMy44NmUtNyxcbiAgICBtaWxsaW1ldGVyczogMTAwMDAwMCxcbiAgICBtaWxsaW1ldHJlczogMTAwMDAwMCxcbiAgICB5YXJkczogMS4xOTU5OTAwNDYsXG59O1xuLyoqXG4gKiBXcmFwcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBpbiBhIEdlb0pTT04ge0BsaW5rIEZlYXR1cmV9LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGlucHV0IGdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmV9IGEgR2VvSlNPTiBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0ge1xuICogICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDUwXVxuICogfTtcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZShnZW9tZXRyeSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZmVhdCA9IHsgdHlwZTogXCJGZWF0dXJlXCIgfTtcbiAgICBpZiAob3B0aW9ucy5pZCA9PT0gMCB8fCBvcHRpb25zLmlkKSB7XG4gICAgICAgIGZlYXQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iYm94KSB7XG4gICAgICAgIGZlYXQuYmJveCA9IG9wdGlvbnMuYmJveDtcbiAgICB9XG4gICAgZmVhdC5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcbiAgICBmZWF0Lmdlb21ldHJ5ID0gZ2VvbTtcbiAgICByZXR1cm4gZmVhdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIEdlb0pTT04ge0BsaW5rIEdlb21ldHJ5fSBmcm9tIGEgR2VvbWV0cnkgc3RyaW5nIHR5cGUgJiBjb29yZGluYXRlcy5cbiAqIEZvciBHZW9tZXRyeUNvbGxlY3Rpb24gdHlwZSB1c2UgYGhlbHBlcnMuZ2VvbWV0cnlDb2xsZWN0aW9uYFxuICpcbiAqIEBuYW1lIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBHZW9tZXRyeSBUeXBlXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtHZW9tZXRyeX0gYSBHZW9KU09OIEdlb21ldHJ5XG4gKiBAZXhhbXBsZVxuICogdmFyIHR5cGUgPSBcIlBvaW50XCI7XG4gKiB2YXIgY29vcmRpbmF0ZXMgPSBbMTEwLCA1MF07XG4gKiB2YXIgZ2VvbWV0cnkgPSB0dXJmLmdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzKTtcbiAqIC8vID0+IGdlb21ldHJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW9tZXRyeSh0eXBlLCBjb29yZGluYXRlcywgX29wdGlvbnMpIHtcbiAgICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkgeyBfb3B0aW9ucyA9IHt9OyB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIHBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIG11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcykuZ2VvbWV0cnk7XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgICAgIHJldHVybiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYSBQb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBsb25naXR1ZGUsIGxhdGl0dWRlIHBvc2l0aW9uIChlYWNoIGluIGRlY2ltYWwgZGVncmVlcylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICAgIH1cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKGNvb3JkaW5hdGVzWzBdKSB8fCAhaXNOdW1iZXIoY29vcmRpbmF0ZXNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3QgY29udGFpbiBudW1iZXJzXCIpO1xuICAgIH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvaW50IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGVhY2ggRmVhdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBQb2ludCBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucG9pbnRzKFtcbiAqICAgWy03NSwgMzldLFxuICogICBbLTgwLCA0NV0sXG4gKiAgIFstNzgsIDUwXVxuICogXSk7XG4gKlxuICogLy89cG9pbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9pbnQoY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9KSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYW4gQXJyYXkgb2YgTGluZWFyUmluZ3MuXG4gKlxuICogQG5hbWUgcG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01LCA1Ml0sIFstNCwgNTZdLCBbLTIsIDUxXSwgWy03LCA1NF0sIFstNSwgNTJdXV0sIHsgbmFtZTogJ3BvbHkxJyB9KTtcbiAqXG4gKiAvLz1wb2x5Z29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvb3JkaW5hdGVzXzEgPSBjb29yZGluYXRlczsgX2kgPCBjb29yZGluYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzXzFbX2ldO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdbcmluZy5sZW5ndGggLSAxXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmlyc3QgcG9pbnQgb2YgUG9seWdvbiBjb250YWlucyB0d28gbnVtYmVyc1xuICAgICAgICAgICAgaWYgKHJpbmdbcmluZy5sZW5ndGggLSAxXVtqXSAhPT0gcmluZ1swXVtqXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2x5Z29ufSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IGZyb20gYW4gQXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uc1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gUG9seWdvbiBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29ucyA9IHR1cmYucG9seWdvbnMoW1xuICogICBbW1stNSwgNTJdLCBbLTQsIDU2XSwgWy0yLCA1MV0sIFstNywgNTRdLCBbLTUsIDUyXV1dLFxuICogICBbW1stMTUsIDQyXSwgWy0xNCwgNDZdLCBbLTEyLCA0MV0sIFstMTcsIDQ0XSwgWy0xNSwgNDJdXV0sXG4gKiBdKTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbnMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9seWdvbihjb29yZHMsIHByb3BlcnRpZXMpO1xuICAgIH0pLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBQb3NpdGlvbnMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IExpbmVTdHJpbmcgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5nMSA9IHR1cmYubGluZVN0cmluZyhbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSwge25hbWU6ICdsaW5lIDEnfSk7XG4gKiB2YXIgbGluZXN0cmluZzIgPSB0dXJmLmxpbmVTdHJpbmcoW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV0sIHtuYW1lOiAnbGluZSAyJ30pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0d28gb3IgbW9yZSBwb3NpdGlvbnNcIik7XG4gICAgfVxuICAgIHZhciBnZW9tID0ge1xuICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLFxuICAgIH07XG4gICAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIExpbmVTdHJpbmcgY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gTGluZVN0cmluZyBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5ncyA9IHR1cmYubGluZVN0cmluZ3MoW1xuICogICBbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSxcbiAqICAgW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV1cbiAqIF0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5ncyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBsaW5lU3RyaW5nKGNvb3JkcywgcHJvcGVydGllcyk7XG4gICAgfSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSB7QGxpbmsgRmVhdHVyZXxGZWF0dXJlc30gYW5kIGNyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmVbXX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBGZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBsb2NhdGlvbkEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdLCB7bmFtZTogJ0xvY2F0aW9uIEEnfSk7XG4gKiB2YXIgbG9jYXRpb25CID0gdHVyZi5wb2ludChbLTc1LjgzMywgMzkuMjg0XSwge25hbWU6ICdMb2NhdGlvbiBCJ30pO1xuICogdmFyIGxvY2F0aW9uQyA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10sIHtuYW1lOiAnTG9jYXRpb24gQyd9KTtcbiAqXG4gKiB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICBsb2NhdGlvbkEsXG4gKiAgIGxvY2F0aW9uQixcbiAqICAgbG9jYXRpb25DXG4gKiBdKTtcbiAqXG4gKiAvLz1jb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZjID0geyB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgfTtcbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgICBmYy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJib3gpIHtcbiAgICAgICAgZmMuYmJveCA9IG9wdGlvbnMuYmJveDtcbiAgICB9XG4gICAgZmMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICByZXR1cm4gZmM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpTGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVTdHJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYSBNdWx0aUxpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1tbMCwwXSxbMTAsMTBdXV0pO1xuICpcbiAqIC8vPW11bHRpTGluZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLFxuICAgIH07XG4gICAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvaW50Pn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvaW50XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvaW50Pn0gYSBNdWx0aVBvaW50IGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUHQgPSB0dXJmLm11bHRpUG9pbnQoW1swLDBdLFsxMCwxMF1dKTtcbiAqXG4gKiAvLz1tdWx0aVB0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJNdWx0aVBvaW50XCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyxcbiAgICB9O1xuICAgIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvbHlnb24+fSBhIG11bHRpcG9seWdvbiBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbW1tbMCwwXSxbMCwxMF0sWzEwLDEwXSxbMTAsMF0sWzAsMF1dXV0pO1xuICpcbiAqIC8vPW11bHRpUG9seVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpUG9seWdvbihjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyxcbiAgICB9O1xuICAgIHJldHVybiBmZWF0dXJlKGdlb20sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+fSBnZW9tZXRyaWVzIGFuIGFycmF5IG9mIEdlb0pTT04gR2VvbWV0cmllc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPEdlb21ldHJ5Q29sbGVjdGlvbj59IGEgR2VvSlNPTiBHZW9tZXRyeUNvbGxlY3Rpb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYuZ2VvbWV0cnkoXCJQb2ludFwiLCBbMTAwLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYuZ2VvbWV0cnkoXCJMaW5lU3RyaW5nXCIsIFtbMTAxLCAwXSwgWzEwMiwgMV1dKTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy8gPT4gY29sbGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBnZW9tID0ge1xuICAgICAgICB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFxuICAgICAgICBnZW9tZXRyaWVzOiBnZW9tZXRyaWVzLFxuICAgIH07XG4gICAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIFJvdW5kIG51bWJlciB0byBwcmVjaXNpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gUHJlY2lzaW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByb3VuZGVkIG51bWJlclxuICogQGV4YW1wbGVcbiAqIHR1cmYucm91bmQoMTIwLjQzMjEpXG4gKiAvLz0xMjBcbiAqXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxLCAyKVxuICogLy89MTIwLjQzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChudW0sIHByZWNpc2lvbikge1xuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAwOyB9XG4gICAgaWYgKHByZWNpc2lvbiAmJiAhKHByZWNpc2lvbiA+PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmVjaXNpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbn1cbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSByYWRpYW5zIHRvIGEgbW9yZSBmcmllbmRseSB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9MZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gZGlzdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnNUb0xlbmd0aChyYWRpYW5zLCB1bml0cykge1xuICAgIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7IHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG4gICAgaWYgKCFmYWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59XG4vKipcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCAoYXNzdW1pbmcgYSBzcGhlcmljYWwgRWFydGgpIGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byByYWRpYW5zXG4gKiBWYWxpZCB1bml0czogbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldGVycywgbWV0cmVzLCBraWxvbWV0ZXJzLCBjZW50aW1ldGVycywgZmVldFxuICpcbiAqIEBuYW1lIGxlbmd0aFRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0cmVzLFxuICogbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoVG9SYWRpYW5zKGRpc3RhbmNlLCB1bml0cykge1xuICAgIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7IHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0c107XG4gICAgaWYgKCFmYWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3RhbmNlIC8gZmFjdG9yO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgKGFzc3VtaW5nIGEgc3BoZXJpY2FsIEVhcnRoKSBmcm9tIGEgcmVhbC13b3JsZCB1bml0IGludG8gZGVncmVlc1xuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywgY2VudGltZXRlcnMsIGtpbG9tZXRyZXMsIGZlZXRcbiAqXG4gKiBAbmFtZSBsZW5ndGhUb0RlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPVwia2lsb21ldGVyc1wiXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aFRvRGVncmVlcyhkaXN0YW5jZSwgdW5pdHMpIHtcbiAgICByZXR1cm4gcmFkaWFuc1RvRGVncmVlcyhsZW5ndGhUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFueSBiZWFyaW5nIGFuZ2xlIGZyb20gdGhlIG5vcnRoIGxpbmUgZGlyZWN0aW9uIChwb3NpdGl2ZSBjbG9ja3dpc2UpXG4gKiBhbmQgcmV0dXJucyBhbiBhbmdsZSBiZXR3ZWVuIDAtMzYwIGRlZ3JlZXMgKHBvc2l0aXZlIGNsb2Nrd2lzZSksIDAgYmVpbmcgdGhlIG5vcnRoIGxpbmVcbiAqXG4gKiBAbmFtZSBiZWFyaW5nVG9BemltdXRoXG4gKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBhbmdsZSwgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlYXJpbmdUb0F6aW11dGgoYmVhcmluZykge1xuICAgIHZhciBhbmdsZSA9IGJlYXJpbmcgJSAzNjA7XG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBhbmdsZTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYW5nbGUgaW4gcmFkaWFucyB0byBkZWdyZWVzXG4gKlxuICogQG5hbWUgcmFkaWFuc1RvRGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge251bWJlcn0gZGVncmVlcyBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICB2YXIgZGVncmVlcyA9IHJhZGlhbnMgJSAoMiAqIE1hdGguUEkpO1xuICAgIHJldHVybiAoZGVncmVlcyAqIDE4MCkgLyBNYXRoLlBJO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhbmdsZSBpbiBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqXG4gKiBAbmFtZSBkZWdyZWVzVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgJSAzNjA7XG4gICAgcmV0dXJuIChyYWRpYW5zICogTWF0aC5QSSkgLyAxODA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGVuZ3RoIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIG9mIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgbGVuZ3RoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TGVuZ3RoKGxlbmd0aCwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHsgb3JpZ2luYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHsgZmluYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICBpZiAoIShsZW5ndGggPj0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgfVxuICAgIHJldHVybiByYWRpYW5zVG9MZW5ndGgobGVuZ3RoVG9SYWRpYW5zKGxlbmd0aCwgb3JpZ2luYWxVbml0KSwgZmluYWxVbml0KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBhcmVhIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBraWxvbWV0ZXJzLCBraWxvbWV0cmVzLCBtZXRlcnMsIG1ldHJlcywgY2VudGltZXRyZXMsIG1pbGxpbWV0ZXJzLCBhY3JlcywgbWlsZXMsIHlhcmRzLCBmZWV0LCBpbmNoZXMsIGhlY3RhcmVzXG4gKiBAcGFyYW0ge251bWJlcn0gYXJlYSB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJtZXRlcnNcIl0gb2YgdGhlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge1VuaXRzfSBbZmluYWxVbml0PVwia2lsb21ldGVyc1wiXSByZXR1cm5lZCB1bml0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY29udmVydGVkIGFyZWFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRBcmVhKGFyZWEsIG9yaWdpbmFsVW5pdCwgZmluYWxVbml0KSB7XG4gICAgaWYgKG9yaWdpbmFsVW5pdCA9PT0gdm9pZCAwKSB7IG9yaWdpbmFsVW5pdCA9IFwibWV0ZXJzXCI7IH1cbiAgICBpZiAoZmluYWxVbml0ID09PSB2b2lkIDApIHsgZmluYWxVbml0ID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICBpZiAoIShhcmVhID49IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFyZWEgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RmFjdG9yID0gYXJlYUZhY3RvcnNbb3JpZ2luYWxVbml0XTtcbiAgICBpZiAoIXN0YXJ0RmFjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3JpZ2luYWwgdW5pdHNcIik7XG4gICAgfVxuICAgIHZhciBmaW5hbEZhY3RvciA9IGFyZWFGYWN0b3JzW2ZpbmFsVW5pdF07XG4gICAgaWYgKCFmaW5hbEZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbmFsIHVuaXRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZWEgLyBzdGFydEZhY3RvcikgKiBmaW5hbEZhY3Rvcjtcbn1cbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG51bSkge1xuICAgIHJldHVybiAhaXNOYU4obnVtKSAmJiBudW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobnVtKTtcbn1cbi8qKlxuICogaXNPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IGlucHV0IHZhcmlhYmxlIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZVxuICogQGV4YW1wbGVcbiAqIHR1cmYuaXNPYmplY3Qoe2VsZXZhdGlvbjogMTB9KVxuICogLy89dHJ1ZVxuICogdHVyZi5pc09iamVjdCgnZm9vJylcbiAqIC8vPWZhbHNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIHJldHVybiAhIWlucHV0ICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG4vKipcbiAqIFZhbGlkYXRlIEJCb3hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IEJCb3ggdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyBFcnJvciBpZiBCQm94IGlzIG5vdCB2YWxpZFxuICogQGV4YW1wbGVcbiAqIHZhbGlkYXRlQkJveChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPU9LXG4gKiB2YWxpZGF0ZUJCb3goWy0xODAsIC00MF0pXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVCQm94KCdGb28nKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCg1KVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveChudWxsKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCh1bmRlZmluZWQpXG4gKiAvLz1FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCQm94KGJib3gpIHtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKGJib3gubGVuZ3RoICE9PSA0ICYmIGJib3gubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheSBvZiA0IG9yIDYgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgYmJveC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihudW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3Qgb25seSBjb250YWluIG51bWJlcnNcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogVmFsaWRhdGUgSWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCBJZCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIEVycm9yIGlmIElkIGlzIG5vdCB2YWxpZFxuICogQGV4YW1wbGVcbiAqIHZhbGlkYXRlSWQoWy0xODAsIC00MCwgMTEwLCA1MF0pXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVJZChbLTE4MCwgLTQwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKCdGb28nKVxuICogLy89T0tcbiAqIHZhbGlkYXRlSWQoNSlcbiAqIC8vPU9LXG4gKiB2YWxpZGF0ZUlkKG51bGwpXG4gKiAvLz1FcnJvclxuICogdmFsaWRhdGVJZCh1bmRlZmluZWQpXG4gKiAvLz1FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJZChpZCkge1xuICAgIGlmICghaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGlmIChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0uaW5kZXhPZih0eXBlb2YgaWQpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzTnVtYmVyLCB9IGZyb20gXCJAdHVyZi9oZWxwZXJzXCI7XG4vKipcbiAqIFVud3JhcCBhIGNvb3JkaW5hdGUgZnJvbSBhIFBvaW50IEZlYXR1cmUsIEdlb21ldHJ5IG9yIGEgc2luZ2xlIGNvb3JkaW5hdGUuXG4gKlxuICogQG5hbWUgZ2V0Q29vcmRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxHZW9tZXRyeTxQb2ludD58RmVhdHVyZTxQb2ludD59IGNvb3JkIEdlb0pTT04gUG9pbnQgb3IgYW4gQXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0gdHVyZi5wb2ludChbMTAsIDEwXSk7XG4gKlxuICogdmFyIGNvb3JkID0gdHVyZi5nZXRDb29yZChwdCk7XG4gKiAvLz0gWzEwLCAxMF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3JkKGNvb3JkKSB7XG4gICAgaWYgKCFjb29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkKSkge1xuICAgICAgICBpZiAoY29vcmQudHlwZSA9PT0gXCJGZWF0dXJlXCIgJiZcbiAgICAgICAgICAgIGNvb3JkLmdlb21ldHJ5ICE9PSBudWxsICYmXG4gICAgICAgICAgICBjb29yZC5nZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmQudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmQuY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmQpICYmXG4gICAgICAgIGNvb3JkLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KGNvb3JkWzBdKSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShjb29yZFsxXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZCBtdXN0IGJlIEdlb0pTT04gUG9pbnQgb3IgYW4gQXJyYXkgb2YgbnVtYmVyc1wiKTtcbn1cbi8qKlxuICogVW53cmFwIGNvb3JkaW5hdGVzIGZyb20gYSBGZWF0dXJlLCBHZW9tZXRyeSBPYmplY3Qgb3IgYW4gQXJyYXlcbiAqXG4gKiBAbmFtZSBnZXRDb29yZHNcbiAqIEBwYXJhbSB7QXJyYXk8YW55PnxHZW9tZXRyeXxGZWF0dXJlfSBjb29yZHMgRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seSA9IHR1cmYucG9seWdvbihbW1sxMTkuMzIsIC04LjddLCBbMTE5LjU1LCAtOC42OV0sIFsxMTkuNTEsIC04LjU0XSwgWzExOS4zMiwgLTguN11dXSk7XG4gKlxuICogdmFyIGNvb3JkcyA9IHR1cmYuZ2V0Q29vcmRzKHBvbHkpO1xuICogLy89IFtbWzExOS4zMiwgLTguN10sIFsxMTkuNTUsIC04LjY5XSwgWzExOS41MSwgLTguNTRdLCBbMTE5LjMyLCAtOC43XV1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29yZHMoY29vcmRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cbiAgICAvLyBGZWF0dXJlXG4gICAgaWYgKGNvb3Jkcy50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgICAgICBpZiAoY29vcmRzLmdlb21ldHJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBHZW9tZXRyeVxuICAgICAgICBpZiAoY29vcmRzLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmNvb3JkaW5hdGVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkcyBtdXN0IGJlIEdlb0pTT04gRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XCIpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgY29vcmRpbmF0ZXMgY29udGFpbnMgYSBudW1iZXJcbiAqXG4gKiBAbmFtZSBjb250YWluc051bWJlclxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBjb29yZGluYXRlcyBHZW9KU09OIENvb3JkaW5hdGVzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBBcnJheSBjb250YWlucyBhIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNOdW1iZXIoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMSAmJlxuICAgICAgICBpc051bWJlcihjb29yZGluYXRlc1swXSkgJiZcbiAgICAgICAgaXNOdW1iZXIoY29vcmRpbmF0ZXNbMV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkgJiYgY29vcmRpbmF0ZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc051bWJlcihjb29yZGluYXRlc1swXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkaW5hdGVzIG11c3Qgb25seSBjb250YWluIG51bWJlcnNcIik7XG59XG4vKipcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIEdlb0pTT04gb2JqZWN0cyBmb3IgVHVyZi5cbiAqXG4gKiBAbmFtZSBnZW9qc29uVHlwZVxuICogQHBhcmFtIHtHZW9KU09OfSB2YWx1ZSBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvanNvblR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBpZiAoIXR5cGUgfHwgIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBhbmQgbmFtZSByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgK1xuICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICBcIjogbXVzdCBiZSBhIFwiICtcbiAgICAgICAgICAgIHR5cGUgK1xuICAgICAgICAgICAgXCIsIGdpdmVuIFwiICtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmV9IGlucHV0cyBmb3IgVHVyZi5cbiAqIEludGVybmFsbHkgdGhpcyB1c2VzIHtAbGluayBnZW9qc29uVHlwZX0gdG8ganVkZ2UgZ2VvbWV0cnkgdHlwZXMuXG4gKlxuICogQG5hbWUgZmVhdHVyZU9mXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgYSBmZWF0dXJlIHdpdGggYW4gZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBlcnJvciBpZiB2YWx1ZSBpcyBub3QgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZWF0dXJlT2YoZmVhdHVyZSwgdHlwZSwgbmFtZSkge1xuICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmZWF0dXJlIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5mZWF0dXJlT2YoKSByZXF1aXJlcyBhIG5hbWVcIik7XG4gICAgfVxuICAgIGlmICghZmVhdHVyZSB8fCBmZWF0dXJlLnR5cGUgIT09IFwiRmVhdHVyZVwiIHx8ICFmZWF0dXJlLmdlb21ldHJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCIsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICtcbiAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgXCI6IG11c3QgYmUgYSBcIiArXG4gICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgIFwiLCBnaXZlbiBcIiArXG4gICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBpbnB1dHMgZm9yIFR1cmYuXG4gKiBJbnRlcm5hbGx5IHRoaXMgdXNlcyB7QGxpbmsgZ2VvanNvblR5cGV9IHRvIGp1ZGdlIGdlb21ldHJ5IHR5cGVzLlxuICpcbiAqIEBuYW1lIGNvbGxlY3Rpb25PZlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmVhdHVyZUNvbGxlY3Rpb24gYSBGZWF0dXJlQ29sbGVjdGlvbiBmb3Igd2hpY2ggZmVhdHVyZXMgd2lsbCBiZSBqdWRnZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdGlvbk9mKGZlYXR1cmVDb2xsZWN0aW9uLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmZWF0dXJlQ29sbGVjdGlvbiBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIuY29sbGVjdGlvbk9mKCkgcmVxdWlyZXMgYSBuYW1lXCIpO1xuICAgIH1cbiAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uIHx8IGZlYXR1cmVDb2xsZWN0aW9uLnR5cGUgIT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICsgbmFtZSArIFwiLCBGZWF0dXJlQ29sbGVjdGlvbiByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IF9hW19pXTtcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gXCJGZWF0dXJlXCIgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCIsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICtcbiAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICBcIjogbXVzdCBiZSBhIFwiICtcbiAgICAgICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgICAgICBcIiwgZ2l2ZW4gXCIgK1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdldCBHZW9tZXRyeSBmcm9tIEZlYXR1cmUgb3IgR2VvbWV0cnkgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeSBPYmplY3RcbiAqIEByZXR1cm5zIHtHZW9tZXRyeXxudWxsfSBHZW9KU09OIEdlb21ldHJ5IE9iamVjdFxuICogQHRocm93cyB7RXJyb3J9IGlmIGdlb2pzb24gaXMgbm90IGEgRmVhdHVyZSBvciBHZW9tZXRyeSBPYmplY3RcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNDBdXG4gKiAgIH1cbiAqIH1cbiAqIHZhciBnZW9tID0gdHVyZi5nZXRHZW9tKHBvaW50KVxuICogLy89e1widHlwZVwiOiBcIlBvaW50XCIsIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNDBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvbShnZW9qc29uKSB7XG4gICAgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICAgICAgcmV0dXJuIGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgfVxuICAgIHJldHVybiBnZW9qc29uO1xufVxuLyoqXG4gKiBHZXQgR2VvSlNPTiBvYmplY3QncyB0eXBlLCBHZW9tZXRyeSB0eXBlIGlzIHByaW9yaXRpemUuXG4gKlxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9XCJnZW9qc29uXCJdIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGRpc3BsYXkgaW4gZXJyb3IgbWVzc2FnZSAodW51c2VkKVxuICogQHJldHVybnMge3N0cmluZ30gR2VvSlNPTiB0eXBlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDQwXVxuICogICB9XG4gKiB9XG4gKiB2YXIgZ2VvbSA9IHR1cmYuZ2V0VHlwZShwb2ludClcbiAqIC8vPVwiUG9pbnRcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZShnZW9qc29uLCBfbmFtZSkge1xuICAgIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gXCJGZWF0dXJlQ29sbGVjdGlvblwiO1xuICAgIH1cbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiO1xuICAgIH1cbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBnZW9qc29uLmdlb21ldHJ5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZW9qc29uLmdlb21ldHJ5LnR5cGU7XG4gICAgfVxuICAgIHJldHVybiBnZW9qc29uLnR5cGU7XG59XG4iLCJpbXBvcnQgZGlzdGFuY2UgZnJvbSBcIkB0dXJmL2Rpc3RhbmNlXCI7XG5pbXBvcnQgeyBzZWdtZW50UmVkdWNlIH0gZnJvbSBcIkB0dXJmL21ldGFcIjtcbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgR2VvSlNPTn0gYW5kIG1lYXN1cmVzIGl0cyBsZW5ndGggaW4gdGhlIHNwZWNpZmllZCB1bml0cywge0BsaW5rIChNdWx0aSlQb2ludH0ncyBkaXN0YW5jZSBhcmUgaWdub3JlZC5cbiAqXG4gKiBAbmFtZSBsZW5ndGhcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZz59IGdlb2pzb24gR2VvSlNPTiB0byBtZWFzdXJlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51bml0cz1raWxvbWV0ZXJzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGxlbmd0aCBvZiBHZW9KU09OXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMTUsIC0zMl0sIFsxMzEsIC0yMl0sIFsxNDMsIC0yNV0sIFsxNTAsIC0zNF1dKTtcbiAqIHZhciBsZW5ndGggPSB0dXJmLmxlbmd0aChsaW5lLCB7dW5pdHM6ICdtaWxlcyd9KTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZV07XG4gKiBsaW5lLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBsZW5ndGg7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxlbmd0aChnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSAyLXZlcnRleCBsaW5lIHNlZ21lbnRzXG4gICAgcmV0dXJuIHNlZ21lbnRSZWR1Y2UoZ2VvanNvbiwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIHNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHNlZ21lbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgZGlzdGFuY2UoY29vcmRzWzBdLCBjb29yZHNbMV0sIG9wdGlvbnMpO1xuICAgIH0sIDApO1xufVxuIiwiaW1wb3J0IHsgZmVhdHVyZSwgbGluZVN0cmluZywgaXNPYmplY3QsIHBvaW50IH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBjYWxsYmFjayBjb29yZEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBjb29yZEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRcbiAqICAgLy89Y29vcmRJbmRleFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChnZW9qc29uLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBHZW9KU09OXG4gIGlmIChnZW9qc29uID09PSBudWxsKSByZXR1cm47XG4gIHZhciBqLFxuICAgIGssXG4gICAgbCxcbiAgICBnZW9tZXRyeSxcbiAgICBzdG9wRyxcbiAgICBjb29yZHMsXG4gICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgd3JhcFNocmluayA9IDAsXG4gICAgY29vcmRJbmRleCA9IDAsXG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgdHlwZSA9IGdlb2pzb24udHlwZSxcbiAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gdHlwZSA9PT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgIGlzRmVhdHVyZSA9IHR5cGUgPT09IFwiRmVhdHVyZVwiLFxuICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gIC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgZm9yICh2YXIgZmVhdHVyZUluZGV4ID0gMDsgZmVhdHVyZUluZGV4IDwgc3RvcDsgZmVhdHVyZUluZGV4KyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5XG4gICAgICA6IGlzRmVhdHVyZVxuICAgICAgPyBnZW9qc29uLmdlb21ldHJ5XG4gICAgICA6IGdlb2pzb247XG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvblxuICAgICAgPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGhcbiAgICAgIDogMTtcblxuICAgIGZvciAodmFyIGdlb21JbmRleCA9IDA7IGdlb21JbmRleCA8IHN0b3BHOyBnZW9tSW5kZXgrKykge1xuICAgICAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDtcbiAgICAgIHZhciBnZW9tZXRyeUluZGV4ID0gMDtcbiAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb25cbiAgICAgICAgPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2dlb21JbmRleF1cbiAgICAgICAgOiBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbjtcblxuICAgICAgLy8gSGFuZGxlcyBudWxsIEdlb21ldHJ5IC0tIFNraXBzIHRoaXMgZ2VvbWV0cnlcbiAgICAgIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIHZhciBnZW9tVHlwZSA9IGdlb21ldHJ5LnR5cGU7XG5cbiAgICAgIHdyYXBTaHJpbmsgPVxuICAgICAgICBleGNsdWRlV3JhcENvb3JkICYmXG4gICAgICAgIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIgfHwgZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiAwO1xuXG4gICAgICBzd2l0Y2ggKGdlb21UeXBlKSB7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgICAgY29vcmRJbmRleCxcbiAgICAgICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleFxuICAgICAgICAgICAgKSA9PT0gZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBjb29yZHNbal0sXG4gICAgICAgICAgICAgICAgY29vcmRJbmRleCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleFxuICAgICAgICAgICAgICApID09PSBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgY29vcmRzW2pdW2tdLFxuICAgICAgICAgICAgICAgICAgY29vcmRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4LFxuICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleFxuICAgICAgICAgICAgICAgICkgPT09IGZhbHNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgIGlmIChnZW9tVHlwZSA9PT0gXCJQb2x5Z29uXCIpIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdlb21UeXBlID09PSBcIlBvbHlnb25cIikgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5SW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgY29vcmRzW2pdW2tdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGwrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbal1ba11bbF0sXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgICAgICAgICAgICkgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvb3JkSW5kZXgrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnZW9tZXRyeUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOlxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjb29yZEVhY2goZ2VvbWV0cnkuZ2VvbWV0cmllc1tqXSwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpID09PVxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9tZXRyeSBUeXBlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBjb29yZFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIGNvb3JkUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGN1cnJlbnRDb29yZCBUaGUgY3VycmVudCBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb29yZEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBjb29yZGluYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIFN0YXJ0cyBhdCBpbmRleCAwLCBpZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQsIGFuZCBhdCBpbmRleCAxIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKlxuICogQG5hbWUgY29vcmRSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258R2VvbWV0cnl8RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleGNsdWRlV3JhcENvb3JkPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRoZSBmaW5hbCBjb29yZGluYXRlIG9mIExpbmVhclJpbmdzIHRoYXQgd3JhcHMgdGhlIHJpbmcgaW4gaXRzIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge1wiZm9vXCI6IFwiYmFyXCJ9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge1wiaGVsbG9cIjogXCJ3b3JsZFwifSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuY29vcmRSZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50Q29vcmRcbiAqICAgLy89Y29vcmRJbmRleFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogICByZXR1cm4gY3VycmVudENvb3JkO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUsIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGNvb3JkRWFjaChcbiAgICBnZW9qc29uLFxuICAgIGZ1bmN0aW9uIChcbiAgICAgIGN1cnJlbnRDb29yZCxcbiAgICAgIGNvb3JkSW5kZXgsXG4gICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICBtdWx0aUZlYXR1cmVJbmRleCxcbiAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICApIHtcbiAgICAgIGlmIChjb29yZEluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gY3VycmVudENvb3JkO1xuICAgICAgZWxzZVxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2soXG4gICAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICBjdXJyZW50Q29vcmQsXG4gICAgICAgICAgY29vcmRJbmRleCxcbiAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgZ2VvbWV0cnlJbmRleFxuICAgICAgICApO1xuICAgIH0sXG4gICAgZXhjbHVkZVdyYXBDb29yZFxuICApO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgcHJvcEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKlxuICogQG5hbWUgcHJvcEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLnByb3BFYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBwcm9wRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICB2YXIgaTtcbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRmVhdHVyZVwiOlxuICAgICAgY2FsbGJhY2soZ2VvanNvbi5wcm9wZXJ0aWVzLCAwKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHByb3BSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBwcm9wUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0geyp9IGN1cnJlbnRQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZSxcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIGlzIHVubmVjZXNzYXJ5LlxuICpcbiAqIEBuYW1lIHByb3BSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYucHJvcFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50UHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0aWVzXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcFJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBwcm9wRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICBwcmV2aW91c1ZhbHVlID0gY3VycmVudFByb3BlcnRpZXM7XG4gICAgZWxzZVxuICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpO1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVFYWNoXG4gKlxuICogQGNhbGxiYWNrIGZlYXR1cmVFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxhbnk+fSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5mZWF0dXJlRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpIHtcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUVhY2goZ2VvanNvbiwgY2FsbGJhY2spIHtcbiAgaWYgKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICBjYWxsYmFjayhnZW9qc29uLCAwKTtcbiAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhbGxiYWNrKGdlb2pzb24uZmVhdHVyZXNbaV0sIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5mZWF0dXJlUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudEZlYXR1cmVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGZlYXR1cmVFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmVJbmRleCA9PT0gMCAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtcbiAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KTtcbiAgfSk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhbnkgR2VvSlNPTiBvYmplY3QuXG4gKlxuICogQG5hbWUgY29vcmRBbGxcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZSBwb3NpdGlvbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdmFyIGNvb3JkcyA9IHR1cmYuY29vcmRBbGwoZmVhdHVyZXMpO1xuICogLy89IFtbMjYsIDM3XSwgWzM2LCA1M11dXG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGdlb2pzb24pIHtcbiAgdmFyIGNvb3JkcyA9IFtdO1xuICBjb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgY29vcmRzLnB1c2goY29vcmQpO1xuICB9KTtcbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIHZhciBpLFxuICAgIGosXG4gICAgZyxcbiAgICBnZW9tZXRyeSxcbiAgICBzdG9wRyxcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbixcbiAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcbiAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICBmZWF0dXJlQkJveCxcbiAgICBmZWF0dXJlSWQsXG4gICAgZmVhdHVyZUluZGV4ID0gMCxcbiAgICBpc0ZlYXR1cmVDb2xsZWN0aW9uID0gZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgaXNGZWF0dXJlID0gZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIixcbiAgICBzdG9wID0gaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gIGZvciAoaSA9IDA7IGkgPCBzdG9wOyBpKyspIHtcbiAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IGlzRmVhdHVyZUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeVxuICAgICAgOiBpc0ZlYXR1cmVcbiAgICAgID8gZ2VvanNvbi5nZW9tZXRyeVxuICAgICAgOiBnZW9qc29uO1xuICAgIGZlYXR1cmVQcm9wZXJ0aWVzID0gaXNGZWF0dXJlQ29sbGVjdGlvblxuICAgICAgPyBnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXNcbiAgICAgIDogaXNGZWF0dXJlXG4gICAgICA/IGdlb2pzb24ucHJvcGVydGllc1xuICAgICAgOiB7fTtcbiAgICBmZWF0dXJlQkJveCA9IGlzRmVhdHVyZUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5iYm94XG4gICAgICA6IGlzRmVhdHVyZVxuICAgICAgPyBnZW9qc29uLmJib3hcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGZlYXR1cmVJZCA9IGlzRmVhdHVyZUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvanNvbi5mZWF0dXJlc1tpXS5pZFxuICAgICAgOiBpc0ZlYXR1cmVcbiAgICAgID8gZ2VvanNvbi5pZFxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvblxuICAgICAgPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb25cbiAgICAgID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGhcbiAgICAgIDogMTtcblxuICAgIGZvciAoZyA9IDA7IGcgPCBzdG9wRzsgZysrKSB7XG4gICAgICBnZW9tZXRyeSA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICAgID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXVxuICAgICAgICA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAvLyBIYW5kbGUgbnVsbCBHZW9tZXRyeVxuICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgICAgICAgIGZlYXR1cmVCQm94LFxuICAgICAgICAgICAgZmVhdHVyZUlkXG4gICAgICAgICAgKSA9PT0gZmFsc2VcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICBmZWF0dXJlQkJveCxcbiAgICAgICAgICAgICAgZmVhdHVyZUlkXG4gICAgICAgICAgICApID09PSBmYWxzZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5nZW9tZXRyaWVzW2pdLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICBmZWF0dXJlQkJveCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlSWRcbiAgICAgICAgICAgICAgKSA9PT0gZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvbWV0cnkgVHlwZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBpbmNyZWFzZSBgZmVhdHVyZUluZGV4YCBwZXIgZWFjaCBmZWF0dXJlXG4gICAgZmVhdHVyZUluZGV4Kys7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbVJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIGdlb21SZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGN1cnJlbnRHZW9tZXRyeSBUaGUgY3VycmVudCBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlUHJvcGVydGllcyBUaGUgY3VycmVudCBGZWF0dXJlIFByb3BlcnRpZXMgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmZWF0dXJlQkJveCBUaGUgY3VycmVudCBGZWF0dXJlIEJCb3ggYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmZWF0dXJlSWQgVGhlIGN1cnJlbnQgRmVhdHVyZSBJZCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZ2VvbWV0cnkgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGdlb21SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEdlb21ldHJ5XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1mZWF0dXJlUHJvcGVydGllc1xuICogICAvLz1mZWF0dXJlQkJveFxuICogICAvLz1mZWF0dXJlSWRcbiAqICAgcmV0dXJuIGN1cnJlbnRHZW9tZXRyeVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZ2VvbUVhY2goXG4gICAgZ2VvanNvbixcbiAgICBmdW5jdGlvbiAoXG4gICAgICBjdXJyZW50R2VvbWV0cnksXG4gICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgIGZlYXR1cmVCQm94LFxuICAgICAgZmVhdHVyZUlkXG4gICAgKSB7XG4gICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gY3VycmVudEdlb21ldHJ5O1xuICAgICAgZWxzZVxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gY2FsbGJhY2soXG4gICAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICBjdXJyZW50R2VvbWV0cnksXG4gICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzLFxuICAgICAgICAgIGZlYXR1cmVCQm94LFxuICAgICAgICAgIGZlYXR1cmVJZFxuICAgICAgICApO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZsYXR0ZW5FYWNoXG4gKlxuICogQGNhbGxiYWNrIGZsYXR0ZW5FYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZX0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgZmxhdHRlbmVkIGZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGZsYXR0ZW5lZCBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmxhdHRlbkVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5tdWx0aVBvaW50KFtbNDAsIDMwXSwgWzM2LCA1M11dLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5mbGF0dGVuRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBwcm9wZXJ0aWVzLCBiYm94LCBpZCkge1xuICAgIC8vIENhbGxiYWNrIGZvciBzaW5nbGUgZ2VvbWV0cnlcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5ID09PSBudWxsID8gbnVsbCA6IGdlb21ldHJ5LnR5cGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBmZWF0dXJlKGdlb21ldHJ5LCBwcm9wZXJ0aWVzLCB7IGJib3g6IGJib3gsIGlkOiBpZCB9KSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApID09PSBmYWxzZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdlb21UeXBlO1xuXG4gICAgLy8gQ2FsbGJhY2sgZm9yIG11bHRpLWdlb21ldHJ5XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9pbnRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgIGdlb21UeXBlID0gXCJMaW5lU3RyaW5nXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgICBnZW9tVHlwZSA9IFwiUG9seWdvblwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDtcbiAgICAgIG11bHRpRmVhdHVyZUluZGV4IDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrK1xuICAgICkge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBnZW9tZXRyeS5jb29yZGluYXRlc1ttdWx0aUZlYXR1cmVJbmRleF07XG4gICAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogZ2VvbVR5cGUsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlLFxuICAgICAgfTtcbiAgICAgIGlmIChcbiAgICAgICAgY2FsbGJhY2soZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzKSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkgPT09XG4gICAgICAgIGZhbHNlXG4gICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlblJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlblJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgZmxhdHRlbkVhY2goXG4gICAgZ2VvanNvbixcbiAgICBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZmVhdHVyZUluZGV4ID09PSAwICYmXG4gICAgICAgIG11bHRpRmVhdHVyZUluZGV4ID09PSAwICYmXG4gICAgICAgIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICApXG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50RmVhdHVyZTtcbiAgICAgIGVsc2VcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKFxuICAgICAgICAgIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgY3VycmVudEZlYXR1cmUsXG4gICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4XG4gICAgICAgICk7XG4gICAgfVxuICApO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIDItdmVydGV4IGxpbmUgc2VnbWVudCBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICpcbiAqIC8vIEl0ZXJhdGUgb3ZlciBHZW9KU09OIGJ5IDItdmVydGV4IHNlZ21lbnRzXG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIC8vPXNlZ21lbnRJbmRleFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciB0b3RhbCA9IDA7XG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0b3RhbCsrO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IDA7XG5cbiAgICAvLyBFeGNsdWRlIG51bGwgR2VvbWV0cmllc1xuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSkgcmV0dXJuO1xuICAgIC8vIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJQb2ludFwiIHx8IHR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSByZXR1cm47XG5cbiAgICAvLyBHZW5lcmF0ZSAyLXZlcnRleCBsaW5lIHNlZ21lbnRzXG4gICAgdmFyIHByZXZpb3VzQ29vcmRzO1xuICAgIHZhciBwcmV2aW91c0ZlYXR1cmVJbmRleCA9IDA7XG4gICAgdmFyIHByZXZpb3VzTXVsdGlJbmRleCA9IDA7XG4gICAgdmFyIHByZXZHZW9tSW5kZXggPSAwO1xuICAgIGlmIChcbiAgICAgIGNvb3JkRWFjaChcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnRDb29yZCxcbiAgICAgICAgICBjb29yZEluZGV4LFxuICAgICAgICAgIGZlYXR1cmVJbmRleENvb3JkLFxuICAgICAgICAgIG11bHRpUGFydEluZGV4Q29vcmQsXG4gICAgICAgICAgZ2VvbWV0cnlJbmRleFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBTaW11bGF0aW5nIGEgbWV0YS5jb29yZFJlZHVjZSgpIHNpbmNlIGByZWR1Y2VgIG9wZXJhdGlvbnMgY2Fubm90IGJlIHN0b3BwZWQgYnkgcmV0dXJuaW5nIGBmYWxzZWBcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcmV2aW91c0Nvb3JkcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBmZWF0dXJlSW5kZXggPiBwcmV2aW91c0ZlYXR1cmVJbmRleCB8fFxuICAgICAgICAgICAgbXVsdGlQYXJ0SW5kZXhDb29yZCA+IHByZXZpb3VzTXVsdGlJbmRleCB8fFxuICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCA+IHByZXZHZW9tSW5kZXhcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ29vcmRzID0gY3VycmVudENvb3JkO1xuICAgICAgICAgICAgcHJldmlvdXNGZWF0dXJlSW5kZXggPSBmZWF0dXJlSW5kZXg7XG4gICAgICAgICAgICBwcmV2aW91c011bHRpSW5kZXggPSBtdWx0aVBhcnRJbmRleENvb3JkO1xuICAgICAgICAgICAgcHJldkdlb21JbmRleCA9IGdlb21ldHJ5SW5kZXg7XG4gICAgICAgICAgICBzZWdtZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnQgPSBsaW5lU3RyaW5nKFxuICAgICAgICAgICAgW3ByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRdLFxuICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQsXG4gICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXgsXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmRleFxuICAgICAgICAgICAgKSA9PT0gZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgc2VnbWVudEluZGV4Kys7XG4gICAgICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgICAgIH1cbiAgICAgICkgPT09IGZhbHNlXG4gICAgKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHNlZ21lbnRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudFNlZ21lbnQgVGhlIGN1cnJlbnQgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgU2VnbWVudCBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgMi12ZXJ0ZXggbGluZSBzZWdtZW50IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKVxuICogKE11bHRpKVBvaW50IGdlb21ldHJpZXMgZG8gbm90IGNvbnRhaW4gc2VnbWVudHMgdGhlcmVmb3JlIHRoZXkgYXJlIGlnbm9yZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFNlZ21lbnQsIGN1cnJlbnRJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNTAsIDVdLCBbLTQwLCAtMTBdLCBbLTUwLCAtMTBdLCBbLTQwLCA1XSwgWy01MCwgNV1dXSk7XG4gKlxuICogLy8gSXRlcmF0ZSBvdmVyIEdlb0pTT04gYnkgMi12ZXJ0ZXggc2VnbWVudHNcbiAqIHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNTZWdtZW50LCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPSBwcmV2aW91c1NlZ21lbnRcbiAqICAgLy89IGN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPSBmZWF0dXJlSW5kZXhcbiAqICAgLy89IG11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPSBnZW9tZXRyeUluZGV4XG4gKiAgIC8vPSBzZWdtZW50SW5kZXhcbiAqICAgcmV0dXJuIGN1cnJlbnRTZWdtZW50XG4gKiB9KTtcbiAqXG4gKiAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50c1xuICogdmFyIGluaXRpYWxWYWx1ZSA9IDBcbiAqIHZhciB0b3RhbCA9IHR1cmYuc2VnbWVudFJlZHVjZShwb2x5Z29uLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSkge1xuICogICAgIHByZXZpb3VzVmFsdWUrKztcbiAqICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAqIH0sIGluaXRpYWxWYWx1ZSk7XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgc2VnbWVudEVhY2goXG4gICAgZ2VvanNvbixcbiAgICBmdW5jdGlvbiAoXG4gICAgICBjdXJyZW50U2VnbWVudCxcbiAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgIG11bHRpRmVhdHVyZUluZGV4LFxuICAgICAgZ2VvbWV0cnlJbmRleCxcbiAgICAgIHNlZ21lbnRJbmRleFxuICAgICkge1xuICAgICAgaWYgKHN0YXJ0ZWQgPT09IGZhbHNlICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBwcmV2aW91c1ZhbHVlID0gY3VycmVudFNlZ21lbnQ7XG4gICAgICBlbHNlXG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgIGN1cnJlbnRTZWdtZW50LFxuICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCxcbiAgICAgICAgICBnZW9tZXRyeUluZGV4LFxuICAgICAgICAgIHNlZ21lbnRJbmRleFxuICAgICAgICApO1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICApO1xuICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgbGluZUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgbGluZUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50TGluZSBUaGUgY3VycmVudCBMaW5lU3RyaW5nfExpbmVhclJpbmcgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGxpbmUgb3IgcmluZyBjb29yZGluYXRlcyBpbiBMaW5lU3RyaW5nLCBQb2x5Z29uLCBNdWx0aUxpbmVTdHJpbmcsIE11bHRpUG9seWdvbiBGZWF0dXJlcyBvciBHZW9tZXRyaWVzLFxuICogc2ltaWxhciB0byBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGxpbmVFYWNoXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgW1syNiwgMzddLCBbMzUsIDQ1XV0sXG4gKiAgIFtbMzYsIDUzXSwgWzM4LCA1MF0sIFs0MSwgNTVdXVxuICogXSk7XG4gKlxuICogdHVyZi5saW5lRWFjaChtdWx0aUxpbmUsIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50TGluZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gIC8vIHZhbGlkYXRpb25cbiAgaWYgKCFnZW9qc29uKSB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIHJlcXVpcmVkXCIpO1xuXG4gIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybjtcbiAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgIGlmIChjYWxsYmFjayhmZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCAwLCAwKSA9PT0gZmFsc2UpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGdlb21ldHJ5SW5kZXggPSAwO1xuICAgICAgICAgIGdlb21ldHJ5SW5kZXggPCBjb29yZHMubGVuZ3RoO1xuICAgICAgICAgIGdlb21ldHJ5SW5kZXgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgbGluZVN0cmluZyhjb29yZHNbZ2VvbWV0cnlJbmRleF0sIGZlYXR1cmUucHJvcGVydGllcyksXG4gICAgICAgICAgICAgIGZlYXR1cmVJbmRleCxcbiAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgICAgICkgPT09IGZhbHNlXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBsaW5lUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBsaW5lUmVkdWNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbXG4gKiAgIHR1cmYucG9seWdvbihbW1sxMiw0OF0sWzIsNDFdLFsyNCwzOF0sWzEyLDQ4XV0sIFtbOSw0NF0sWzEzLDQxXSxbMTMsNDVdLFs5LDQ0XV1dKSxcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzUsIDVdLCBbMCwgMF0sIFsyLCAyXSwgWzQsIDRdLCBbNSwgNV1dXSlcbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZVJlZHVjZShtdWx0aVBvbHksIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50TGluZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGluZUVhY2goXG4gICAgZ2VvanNvbixcbiAgICBmdW5jdGlvbiAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAgICAgIGlmIChmZWF0dXJlSW5kZXggPT09IDAgJiYgaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBjdXJyZW50TGluZTtcbiAgICAgIGVsc2VcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKFxuICAgICAgICAgIHByZXZpb3VzVmFsdWUsXG4gICAgICAgICAgY3VycmVudExpbmUsXG4gICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4LFxuICAgICAgICAgIGdlb21ldHJ5SW5kZXhcbiAgICAgICAgKTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgcGFydGljdWxhciAyLXZlcnRleCBMaW5lU3RyaW5nIFNlZ21lbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICogUG9pbnQgJiBNdWx0aVBvaW50IHdpbGwgYWx3YXlzIHJldHVybiBudWxsLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2VnbWVudEluZGV4PTBdIFNlZ21lbnQgSW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgUHJvcGVydGllcyB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5pZD17fV0gVHJhbnNsYXRlIElkIHRvIG91dHB1dCBMaW5lU3RyaW5nXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIExpbmVTdHJpbmdcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1xuICogICAgIFtbMTAsIDEwXSwgWzUwLCAzMF0sIFszMCwgNDBdXSxcbiAqICAgICBbWy0xMCwgLTEwXSwgWy01MCwgLTMwXSwgWy0zMCwgLTQwXV1cbiAqIF0pO1xuICpcbiAqIC8vIEZpcnN0IFNlZ21lbnQgKGRlZmF1bHRzIGFyZSAwKVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUpO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbMTAsIDEwXSwgWzUwLCAzMF1dPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIDJuZCBNdWx0aSBGZWF0dXJlXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAxfSk7XG4gKiAvLyA9PiBGZWF0dXJlPExpbmVTdHJpbmc8W1stMTAsIC0xMF0sIFstNTAsIC0zMF1dPj5cbiAqXG4gKiAvLyBMYXN0IFNlZ21lbnQgb2YgTGFzdCBNdWx0aSBGZWF0dXJlXG4gKiB0dXJmLmZpbmRTZWdtZW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAtMSwgc2VnbWVudEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXT4+XG4gKi9cbmZ1bmN0aW9uIGZpbmRTZWdtZW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO1xuICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleCB8fCAwO1xuICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICB2YXIgc2VnbWVudEluZGV4ID0gb3B0aW9ucy5zZWdtZW50SW5kZXggfHwgMDtcblxuICAvLyBGaW5kIEZlYXR1cmVJbmRleFxuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIGdlb21ldHJ5O1xuXG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMClcbiAgICAgICAgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG4gIH1cblxuICAvLyBGaW5kIFNlZ21lbnRJbmRleFxuICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gIHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApIHNlZ21lbnRJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoXG4gICAgICAgIFtjb29yZHNbc2VnbWVudEluZGV4XSwgY29vcmRzW3NlZ21lbnRJbmRleCArIDFdXSxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICBpZiAoc2VnbWVudEluZGV4IDwgMClcbiAgICAgICAgc2VnbWVudEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhcbiAgICAgICAgW1xuICAgICAgICAgIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXhdLFxuICAgICAgICAgIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXSxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKVxuICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKVxuICAgICAgICBzZWdtZW50SW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICByZXR1cm4gbGluZVN0cmluZyhcbiAgICAgICAgW1xuICAgICAgICAgIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4XSxcbiAgICAgICAgICBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleCArIDFdLFxuICAgICAgICBdLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApXG4gICAgICAgIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKVxuICAgICAgICBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKHNlZ21lbnRJbmRleCA8IDApXG4gICAgICAgIHNlZ21lbnRJbmRleCA9XG4gICAgICAgICAgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoXG4gICAgICAgIFtcbiAgICAgICAgICBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sXG4gICAgICAgICAgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXSxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG59XG5cbi8qKlxuICogRmluZHMgYSBwYXJ0aWN1bGFyIFBvaW50IGZyb20gYSBHZW9KU09OIHVzaW5nIGBAdHVyZi9tZXRhYCBpbmRleGVzLlxuICpcbiAqIE5lZ2F0aXZlIGluZGV4ZXMgYXJlIHBlcm1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gQW55IEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmVhdHVyZUluZGV4PTBdIEZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleD0wXSBNdWx0aS1GZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZ2VvbWV0cnlJbmRleD0wXSBHZW9tZXRyeSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvb3JkSW5kZXg9MF0gQ29vcmQgSW5kZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9wZXJ0aWVzPXt9XSBUcmFuc2xhdGUgUHJvcGVydGllcyB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7QkJveH0gW29wdGlvbnMuYmJveD17fV0gVHJhbnNsYXRlIEJCb3ggdG8gb3V0cHV0IFBvaW50XG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmlkPXt9XSBUcmFuc2xhdGUgSWQgdG8gb3V0cHV0IFBvaW50XG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IDItdmVydGV4IEdlb0pTT04gRmVhdHVyZSBQb2ludFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgICAgW1sxMCwgMTBdLCBbNTAsIDMwXSwgWzMwLCA0MF1dLFxuICogICAgIFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdLCBbLTMwLCAtNDBdXVxuICogXSk7XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCAoZGVmYXVsdHMgYXJlIDApXG4gKiB0dXJmLmZpbmRQb2ludChtdWx0aUxpbmUpO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbMTAsIDEwXT4+XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCBvZiB0aGUgMm5kIE11bHRpLUZlYXR1cmVcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAxfSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFstMTAsIC0xMF0+PlxuICpcbiAqIC8vIExhc3QgU2VnbWVudCBvZiBsYXN0IE11bHRpLUZlYXR1cmVcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSwge211bHRpRmVhdHVyZUluZGV4OiAtMSwgY29vcmRJbmRleDogLTF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0zMCwgLTQwXT4+XG4gKi9cbmZ1bmN0aW9uIGZpbmRQb2ludChnZW9qc29uLCBvcHRpb25zKSB7XG4gIC8vIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgaXMgaW52YWxpZFwiKTtcbiAgdmFyIGZlYXR1cmVJbmRleCA9IG9wdGlvbnMuZmVhdHVyZUluZGV4IHx8IDA7XG4gIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IG9wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXggfHwgMDtcbiAgdmFyIGdlb21ldHJ5SW5kZXggPSBvcHRpb25zLmdlb21ldHJ5SW5kZXggfHwgMDtcbiAgdmFyIGNvb3JkSW5kZXggPSBvcHRpb25zLmNvb3JkSW5kZXggfHwgMDtcblxuICAvLyBGaW5kIEZlYXR1cmVJbmRleFxuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIGdlb21ldHJ5O1xuXG4gIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6XG4gICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMClcbiAgICAgICAgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBnZW9qc29uLmZlYXR1cmVzW2ZlYXR1cmVJbmRleF0ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZW9qc29uIGlzIGludmFsaWRcIik7XG4gIH1cblxuICAvLyBGaW5kIENvb3JkIEluZGV4XG4gIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgaWYgKG11bHRpRmVhdHVyZUluZGV4IDwgMClcbiAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXggPSBjb29yZHMubGVuZ3RoICsgbXVsdGlGZWF0dXJlSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW211bHRpRmVhdHVyZUluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMCkgY29vcmRJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KGNvb3Jkc1tjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKVxuICAgICAgICBjb29yZEluZGV4ID0gY29vcmRzW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICByZXR1cm4gcG9pbnQoY29vcmRzW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKVxuICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMClcbiAgICAgICAgY29vcmRJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgIHJldHVybiBwb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKVxuICAgICAgICBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMClcbiAgICAgICAgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF0ubGVuZ3RoICsgZ2VvbWV0cnlJbmRleDtcbiAgICAgIGlmIChjb29yZEluZGV4IDwgMClcbiAgICAgICAgY29vcmRJbmRleCA9XG4gICAgICAgICAgY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBjb29yZEluZGV4O1xuICAgICAgcmV0dXJuIHBvaW50KFxuICAgICAgICBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImdlb2pzb24gaXMgaW52YWxpZFwiKTtcbn1cblxuZXhwb3J0IHsgY29vcmRBbGwsIGNvb3JkRWFjaCwgY29vcmRSZWR1Y2UsIGZlYXR1cmVFYWNoLCBmZWF0dXJlUmVkdWNlLCBmaW5kUG9pbnQsIGZpbmRTZWdtZW50LCBmbGF0dGVuRWFjaCwgZmxhdHRlblJlZHVjZSwgZ2VvbUVhY2gsIGdlb21SZWR1Y2UsIGxpbmVFYWNoLCBsaW5lUmVkdWNlLCBwcm9wRWFjaCwgcHJvcFJlZHVjZSwgc2VnbWVudEVhY2gsIHNlZ21lbnRSZWR1Y2UgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgKiBhcyBMIGZyb20gXCJsZWFmbGV0XCI7XG5pbXBvcnQgYXJlYSBmcm9tIFwiQHR1cmYvYXJlYVwiO1xuaW1wb3J0IGxlbmd0aCBmcm9tIFwiQHR1cmYvbGVuZ3RoXCI7XG5cbmltcG9ydCB7XG4gIFRlcnJhRHJhdyxcbiAgVGVycmFEcmF3UG9pbnRNb2RlLFxuICBUZXJyYURyYXdDaXJjbGVNb2RlLFxuICBUZXJyYURyYXdMaW5lU3RyaW5nTW9kZSxcbiAgVGVycmFEcmF3UG9seWdvbk1vZGUsXG4gIFRlcnJhRHJhd1NlbGVjdE1vZGUsXG4gIFRlcnJhRHJhd0ZyZWVoYW5kTW9kZSxcbiAgVGVycmFEcmF3TGVhZmxldEFkYXB0ZXIsXG59IGZyb20gXCIuLi8uLi9zcmMvdGVycmEtZHJhd1wiO1xuaW1wb3J0IHsgYWRkTW9kZUNoYW5nZUhhbmRsZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2FkZE1vZGVDaGFuZ2VIYW5kbGVyXCI7XG5pbXBvcnQgeyBUZXJyYURyYXdSZW5kZXJNb2RlIH0gZnJvbSBcIi4uLy4uL3NyYy9tb2Rlcy9yZW5kZXIvcmVuZGVyLm1vZGVcIjtcblxubGV0IGN1cnJlbnRTZWxlY3RlZDogeyBidXR0b246IHVuZGVmaW5lZCB8IEhUTUxCdXR0b25FbGVtZW50OyBtb2RlOiBzdHJpbmcgfSA9IHtcbiAgYnV0dG9uOiB1bmRlZmluZWQsXG4gIG1vZGU6IFwic3RhdGljXCIsXG59O1xuXG5jb25zdCBleGFtcGxlID0ge1xuICBsbmc6IC0wLjExODA5MixcbiAgbGF0OiA1MS41MDk4NjUsXG4gIHpvb206IDEyLFxuICBpbml0aWFsaXNlZDogW10gYXMgc3RyaW5nW10sXG4gIGluaXRMZWFmbGV0KGlkOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXNlZC5pbmNsdWRlcyhcImxlYWZsZXRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGxuZywgbGF0LCB6b29tIH0gPSB0aGlzO1xuXG4gICAgY29uc3QgbWFwID0gTC5tYXAoaWQsIHtcbiAgICAgIGNlbnRlcjogW2xhdCwgbG5nXSxcbiAgICAgIHpvb206IHpvb20gKyAxLCAvLyBzdGFydGluZyB6b29tXG4gICAgfSk7XG5cbiAgICBMLnRpbGVMYXllcihcImh0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nXCIsIHtcbiAgICAgIGF0dHJpYnV0aW9uOlxuICAgICAgICAnJmNvcHk7IDxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiBjb250cmlidXRvcnMnLFxuICAgIH0pLmFkZFRvKG1hcCk7XG5cbiAgICBjb25zdCBkcmF3ID0gbmV3IFRlcnJhRHJhdyh7XG4gICAgICBhZGFwdGVyOiBuZXcgVGVycmFEcmF3TGVhZmxldEFkYXB0ZXIoe1xuICAgICAgICBsaWI6IEwsXG4gICAgICAgIG1hcCxcbiAgICAgICAgY29vcmRpbmF0ZVByZWNpc2lvbjogOSxcbiAgICAgIH0pLFxuICAgICAgbW9kZXM6IHtcbiAgICAgICAgc2VsZWN0OiBuZXcgVGVycmFEcmF3U2VsZWN0TW9kZSh7XG4gICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgIGFyYml0YXJ5OiB7XG4gICAgICAgICAgICAgIGZlYXR1cmU6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvbHlnb246IHtcbiAgICAgICAgICAgICAgZmVhdHVyZToge1xuICAgICAgICAgICAgICAgIHNjYWxlYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByb3RhdGVhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczoge1xuICAgICAgICAgICAgICAgICAgbWlkcG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVsZXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZXN0cmluZzoge1xuICAgICAgICAgICAgICBmZWF0dXJlOiB7XG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICAgICAgICBtaWRwb2ludHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkZWxldGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaXJjbGU6IHtcbiAgICAgICAgICAgICAgZmVhdHVyZToge1xuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICBmZWF0dXJlOiB7XG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyZWVoYW5kOiB7XG4gICAgICAgICAgICAgIGZlYXR1cmU6IHtcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICBwb2ludDogbmV3IFRlcnJhRHJhd1BvaW50TW9kZSgpLFxuICAgICAgICBsaW5lc3RyaW5nOiBuZXcgVGVycmFEcmF3TGluZVN0cmluZ01vZGUoe1xuICAgICAgICAgIHNuYXBwaW5nOiB0cnVlLFxuICAgICAgICAgIGFsbG93U2VsZkludGVyc2VjdGlvbnM6IGZhbHNlLFxuICAgICAgICB9KSxcbiAgICAgICAgcG9seWdvbjogbmV3IFRlcnJhRHJhd1BvbHlnb25Nb2RlKHtcbiAgICAgICAgICAvLyBzbmFwcGluZzogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1NlbGZJbnRlcnNlY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgfSksXG4gICAgICAgIGNpcmNsZTogbmV3IFRlcnJhRHJhd0NpcmNsZU1vZGUoKSxcbiAgICAgICAgZnJlZWhhbmQ6IG5ldyBUZXJyYURyYXdGcmVlaGFuZE1vZGUoKSxcbiAgICAgICAgYXJiaXRhcnk6IG5ldyBUZXJyYURyYXdSZW5kZXJNb2RlKHtcbiAgICAgICAgICBzdHlsaW5nOiB7XG4gICAgICAgICAgICBwb2x5Z29uRmlsbENvbG9yOiBcIiM0MzU3QURcIixcbiAgICAgICAgICAgIHBvbHlnb25PdXRsaW5lQ29sb3I6IFwiIzQ4QTlBNlwiLFxuICAgICAgICAgICAgcG9seWdvbk91dGxpbmVXaWR0aDogMixcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBkcmF3LnN0YXJ0KCk7XG5cbiAgICBjb25zdCBnZXRISE1NU1MgPSAodGltZXN0YW1wOiBudW1iZXIpID0+XG4gICAgICBuZXcgRGF0ZSh0aW1lc3RhbXApLnRvVGltZVN0cmluZygpLnNwbGl0KFwiIFwiKVswXTtcblxuICAgIGNvbnN0IHNldEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGRyYXcuZ2V0U25hcHNob3QoKTtcbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gc25hcHNob3QuZmlsdGVyKFxuICAgICAgICAoZikgPT4gIWYucHJvcGVydGllcy5zZWxlY3Rpb25Qb2ludCAmJiAhZi5wcm9wZXJ0aWVzLm1pZFBvaW50XG4gICAgICApO1xuXG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHNuYXBzaG90LmZpbmQoKGYpID0+IGYucHJvcGVydGllcy5zZWxlY3RlZCk7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9cIik7XG5cbiAgICAgIGlmICghZGl2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGl2LmlubmVySFRNTCA9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjdXJyZW50XCI+XG4gICAgICAgIDxoMz4gQ3VycmVudCBGZWF0dXJlIDwvaDM+XG4gICAgICAgIDxzcGFuPjxiPklEPC9iPiAke3NlbGVjdGVkID8gc2VsZWN0ZWQuaWQgOiBcIk4vQVwifSA8L3NwYW4+XG4gICAgICAgIDxzcGFuPjxiPkdlb21ldHJ5IFR5cGU8L2I+ICR7XG4gICAgICAgICAgc2VsZWN0ZWQgPyBzZWxlY3RlZC5nZW9tZXRyeS50eXBlIDogXCJOL0FcIlxuICAgICAgICB9IDwvc3Bhbj5cbiAgICAgICAgPHNwYW4+PGI+Q3JlYXRlZDwvYj4gJHtcbiAgICAgICAgICBzZWxlY3RlZCA/IGdldEhITU1TUyhzZWxlY3RlZC5wcm9wZXJ0aWVzLmNyZWF0ZWRBdCBhcyBudW1iZXIpIDogXCJOL0FcIlxuICAgICAgICB9IDwvc3Bhbj5cbiAgICAgICAgPHNwYW4+PGI+VXBkYXRlZDwvYj4gJHtcbiAgICAgICAgICBzZWxlY3RlZCA/IGdldEhITU1TUyhzZWxlY3RlZC5wcm9wZXJ0aWVzLnVwZGF0ZWRBdCBhcyBudW1iZXIpIDogXCJOL0FcIlxuICAgICAgICB9IDwvc3Bhbj5cbiAgICAgICAgPHNwYW4+PGI+Q29vcmRpbmF0ZXM8L2I+ICR7XG4gICAgICAgICAgc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2x5Z29uXCJcbiAgICAgICAgICAgID8gc2VsZWN0ZWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoXG4gICAgICAgICAgICA6IHNlbGVjdGVkICYmIHNlbGVjdGVkLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiXG4gICAgICAgICAgICA/IHNlbGVjdGVkLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aFxuICAgICAgICAgICAgOiBcIk4vQVwiXG4gICAgICAgIH08L2I+IDwvc3Bhbj5cbiAgICAgICAgJHtcbiAgICAgICAgICBzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIlxuICAgICAgICAgICAgPyBgPHNwYW4+PGI+QXJlYSAobTIpPC9iPiAke2FyZWEoc2VsZWN0ZWQpLnRvRml4ZWQoMil9IDwvc3Bhbj5gXG4gICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgfVxuICAgICAgICAke1xuICAgICAgICAgIHNlbGVjdGVkICYmIHNlbGVjdGVkLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiXG4gICAgICAgICAgICA/IGA8c3Bhbj48Yj5MZW5ndGggKGttKTwvYj4gJHtsZW5ndGgoc2VsZWN0ZWQpLnRvRml4ZWQoMil9IDwvc3Bhbj5gXG4gICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJhbGxcIj5cbiAgICAgICAgPGgzPiBBbGwgRmVhdHVyZXMgPC9oMz5cbiAgICAgICAgPHNwYW4+PGI+VG90YWw8L2I+ICR7ZmVhdHVyZXMubGVuZ3RofTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+PGI+UG9seWdvbnM6PC9iPiAke1xuICAgICAgICAgIGZlYXR1cmVzLmZpbHRlcigoZikgPT4gZi5nZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikubGVuZ3RoXG4gICAgICAgIH08L3NwYW4+XG4gICAgICAgIDxzcGFuPjxiPkxpbmVTdHJpbmdzOjwvYj4gJHtcbiAgICAgICAgICBmZWF0dXJlcy5maWx0ZXIoKGYpID0+IGYuZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpLmxlbmd0aFxuICAgICAgICB9PC9zcGFuPlxuICAgICAgICA8c3Bhbj48Yj5Qb2ludHM6PC9iPiAke1xuICAgICAgICAgIGZlYXR1cmVzLmZpbHRlcigoZikgPT4gZi5nZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpLmxlbmd0aFxuICAgICAgICB9PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICB9O1xuXG4gICAgc2V0SW5mbygpO1xuXG4gICAgZHJhdy5vbihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBzZXRJbmZvKCk7XG4gICAgfSk7XG5cbiAgICBhZGRNb2RlQ2hhbmdlSGFuZGxlcihkcmF3LCBjdXJyZW50U2VsZWN0ZWQpO1xuXG4gICAgdGhpcy5pbml0aWFsaXNlZC5wdXNoKFwibGVhZmxldFwiKTtcbiAgfSxcbn07XG5cbmV4YW1wbGUuaW5pdExlYWZsZXQoXCJsZWFmbGV0LW1hcFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==